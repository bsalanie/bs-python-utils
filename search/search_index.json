{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"bs-python-utils","text":"<p>My Python utilities.</p> <ul> <li>Github repository: https://github.com/bsalanie/bs-python-utils/</li> <li>Documentation https://bsalanie.github.io/bs-python-utils/</li> </ul>"},{"location":"index.html#release-notes","title":"Release notes","text":""},{"location":"index.html#064-november-26-2023","title":"0.6.4 (November 26, 2023)","text":"<p>Moved to Altair 5.0; made timing optional in <code>bs_opt</code>.</p>"},{"location":"index.html#063-november-26-2023","title":"0.6.3 (November 26, 2023)","text":"<p>Updated statsmodels dependency.</p>"},{"location":"index.html#061-and-062-november-18-2023","title":"0.6.1 and 0.6.2 (November 18, 2023)","text":"<p>Added a Matplotlib plot for discrete choice models, a boxplot for Altair, and a density plot for Seaborn.</p>"},{"location":"index.html#06-november-9-2023","title":"0.6 (November 9, 2023)","text":"<p>Added matrix heatmap plot in Altair and Streamlit utility code.</p>"},{"location":"index.html#055-october-23-2023","title":"0.5.5 (October 23, 2023)","text":"<p>Added <code>fstring***</code> in <code>bsutils</code>.</p>"},{"location":"index.html#052-august-16-2023","title":"0.5.2 (August 16, 2023)","text":"<p>Added two interpolation routines from values at the Chebyshev nodes in <code>chebyshev</code> module.</p>"},{"location":"index.html#051-august-14-2023","title":"0.5.1 (August 14, 2023)","text":"<p>Added two functions to draw random samples in <code>bsstats</code> module.</p>"},{"location":"index.html#05-august-7-2023","title":"0.5 (August 7, 2023)","text":"<p>Added 1-dimensional root finding in <code>chebyshev</code> module.</p>"},{"location":"index.html#042-august-2-2023","title":"0.4.2 (August 2, 2023)","text":"<p>Updated the docs.</p>"},{"location":"index.html#041-july-23-2023","title":"0.4.1 (July 23, 2023)","text":"<p>Only print if verbose in bivariate quantiles.</p>"},{"location":"index.html#04-july-22-2023","title":"0.4 (July 22, 2023)","text":"<p>Added bivariate quantiles and ranks \u00e0 la optimal transportation.</p>"},{"location":"index.html#03-july-21-2023","title":"0.3 (July 21, 2023)","text":"<p>Added in Numpy utils a function to set upper and lower triangle to a scalar; and <code>minimize_free</code> in <code>bs_opt</code>.</p>"},{"location":"index.html#02-july-17-2023","title":"0.2 (July 17, 2023)","text":"<p>Fixed printing in accelerated gradient descent.</p>"},{"location":"index.html#01-june-20-2023","title":"0.1 (June 20, 2023)","text":"<p>Added <code>grid_function</code> and the <code>chebyshev</code> module.</p>"},{"location":"index.html#006-may-9-2023","title":"0.0.6 (May 9, 2023)","text":"<p>Improved docs.</p>"},{"location":"index.html#005-may-8-2023","title":"0.0.5 (May 8, 2023)","text":"<p>Added <code>final_s</code> in <code>bsutils</code>.</p>"},{"location":"index.html#004-may-2-2023","title":"0.0.4 (May 2, 2023)","text":"<p>Added Legendre polynomials and quantile routines in <code>bsnputils</code>.</p>"},{"location":"index.html#003-april-24-2023","title":"0.0.3 (April 24, 2023)","text":"<p>Satisfied mypy.</p>"},{"location":"index.html#002-april-24-2023","title":"0.0.2 (April 24, 2023)","text":"<p>Fixed main PyPI page.</p>"},{"location":"Timer.html","title":"Timer module","text":"<p>Utilities to time code:</p> <ul> <li>a <code>Timer</code> class that can be used as a context manager</li> <li>a <code>timeit</code> decorator for functions.</li> </ul>"},{"location":"Timer.html#bs_python_utils.Timer.Timer","title":"<code>Timer</code>","text":"<p>A timer that can be started, stopped, and reset as needed by the user. It keeps track of the total elapsed time in the <code>elapsed</code> attribute::</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; with Timer() as t:\n&gt;&gt;&gt;  ....\n&gt;&gt;&gt; print(f\"... took {t.elapsed} seconds\")\n</code></pre> <p>use <code>Timer(time.process_time)</code> to get only CPU time.</p> <p>can also do:</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; t = Timer()\n&gt;&gt;&gt; t.start()\n&gt;&gt;&gt; t.stop()\n&gt;&gt;&gt; t.start()   # will add to the same counter\n&gt;&gt;&gt; t.stop()\n&gt;&gt;&gt; print(f\"{t.elapsed} seconds total\")\n</code></pre> Source code in <code>bs_python_utils/Timer.py</code> <pre><code>class Timer:\n    \"\"\"\n    A timer that can be started, stopped, and reset as needed by the user.\n    It keeps track of the total elapsed time in the `elapsed` attribute::\n\n    Examples:\n        &gt;&gt;&gt; with Timer() as t:\n        &gt;&gt;&gt;  ....\n        &gt;&gt;&gt; print(f\"... took {t.elapsed} seconds\")\n\n    use `Timer(time.process_time)` to get only CPU time.\n\n    can also do:\n\n    Examples:\n        &gt;&gt;&gt; t = Timer()\n        &gt;&gt;&gt; t.start()\n        &gt;&gt;&gt; t.stop()\n        &gt;&gt;&gt; t.start()   # will add to the same counter\n        &gt;&gt;&gt; t.stop()\n        &gt;&gt;&gt; print(f\"{t.elapsed} seconds total\")\n    \"\"\"\n\n    def __init__(self, func: Callable = time.perf_counter) -&gt; None:\n        self.elapsed = 0.0\n        self._func = func\n        self._start = None\n\n    def start(self) -&gt; None:\n        if self._start is not None:\n            raise RuntimeError(\"Already started\")\n        self._start = self._func()\n\n    def stop(self) -&gt; None:\n        if self._start is None:\n            raise RuntimeError(\"Not started\")\n        end = self._func()\n        self.elapsed += end - self._start\n        self._start = None\n\n    def reset(self) -&gt; None:\n        self.elapsed = 0.0\n\n    @property\n    def running(self) -&gt; bool:\n        return self._start is not None\n\n    def __enter__(self) -&gt; Any:\n        self.start()\n        return self\n\n    def __exit__(self, *args: Iterable) -&gt; None:\n        self.stop()\n</code></pre>"},{"location":"Timer.html#bs_python_utils.Timer.timeit","title":"<code>timeit(func)</code>","text":"<p>Decorator to time a function</p> Source code in <code>bs_python_utils/Timer.py</code> <pre><code>def timeit(func: Callable) -&gt; Callable:\n    \"\"\"\n    Decorator to time a function\n    \"\"\"\n\n    @wraps(func)\n    def wrapper(*args: Iterable, **kwargs: dict) -&gt; Any:\n        start = time.perf_counter()\n        result = func(*args, **kwargs)\n        end = time.perf_counter()\n        print(f\"{func.__name__} executed in {end - start:.3f} seconds\")\n        return result\n\n    return wrapper\n</code></pre>"},{"location":"bivariate_quantiles.html","title":"bivariate_quantiles module","text":"<p>This takes in observations of a bivariate random variable <code>y</code> and computes vector quantiles and vector ranks \u00e0 la Chernozhukov-Galichon-Hallin-Henry (Ann. Stats. 2017).</p> Note <p>if the math looks strange in the documentation, just reload the page.</p> <p>The sequence of steps is as follows:</p> <ul> <li>choose a  number of Chebyshev nodes for numerical integration and optimize the weights: <code>v = solve_for_v(y, n_nodes)</code></li> <li>to obtain the \\((u_1,u_2)\\) quantiles for \\((u_1, u_2)\\in [0,1]\\), run <code>qtiles_y = bivariate_quantiles_v(y, v, u1, u2)</code></li> <li>to compute the vector ranks for all points in the sample (the barycenters of the cells in the power diagram): <code>ranks_y = bivariate_ranks_v(y, v, n_nodes)</code></li> </ul> <p>Steps 1 and 2 can be combined: <code>qtiles_y = bivariate_quantiles(y, v, u1, u2, n_nodes)</code></p> <p>Steps 1 and 3 can be combined: <code>ranks_y = bivariate_ranks(y, n_nodes)</code></p>"},{"location":"bivariate_quantiles.html#bs_python_utils.bivariate_quantiles.bivariate_quantiles","title":"<code>bivariate_quantiles(y, u, n_nodes=32, verbose=False)</code>","text":"<p>computes the bivariate quantiles of <code>y</code> at the quantiles <code>u</code></p> <p>Parameters:</p> Name Type Description Default <code>y</code> <code>ndarray</code> <p>the observations, an <code>(n, 2)</code> matrix</p> required <code>u</code> <code>ndarray</code> <p>the quantiles at which to compute the bivariate quantiles, an <code>(m, 2)</code> matrix</p> required <code>n_nodes</code> <code>int</code> <p>the number of nodes to use for the quadrature</p> <code>32</code> <code>verbose</code> <code>bool</code> <p>if <code>True</code>, print some information</p> <code>False</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>an <code>(m, 2)</code> matrix of bivariate quantiles</p> Source code in <code>bs_python_utils/bivariate_quantiles.py</code> <pre><code>def bivariate_quantiles(\n    y: np.ndarray, u: np.ndarray, n_nodes: int = 32, verbose: bool = False\n) -&gt; np.ndarray:\n    \"\"\"computes the bivariate quantiles of `y` at the quantiles `u`\n\n    Args:\n        y: the observations, an `(n, 2)` matrix\n        u: the quantiles at which to compute the bivariate quantiles,\n            an `(m, 2)` matrix\n        n_nodes: the number of nodes to use for the quadrature\n        verbose: if `True`, print some information\n\n    Returns:\n        an `(m, 2)` matrix of bivariate quantiles\n    \"\"\"\n    v = solve_for_v_(y, n_nodes, verbose)\n    return bivariate_quantiles_v(y, u, v)\n</code></pre>"},{"location":"bivariate_quantiles.html#bs_python_utils.bivariate_quantiles.bivariate_quantiles_v","title":"<code>bivariate_quantiles_v(y, u, v)</code>","text":"<p>computes the vector quantiles of <code>y</code> at values <code>u</code>, given the converged <code>v</code></p> <p>Parameters:</p> Name Type Description Default <code>y</code> <code>ndarray</code> <p>the observations, an <code>(n,2)</code> matrix</p> required <code>u</code> <code>ndarray</code> <p>the values where we want the quantiles, an <code>(m,2)</code> matrix in \\([0,1]\\)</p> required <code>v</code> <code>ndarray</code> <p>the converged values of the weights, an <code>n</code>-vector</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>an <code>(m,2)</code> matrix with the quantiles of <code>y</code> at the values <code>u</code></p> Source code in <code>bs_python_utils/bivariate_quantiles.py</code> <pre><code>def bivariate_quantiles_v(y: np.ndarray, u: np.ndarray, v: np.ndarray) -&gt; np.ndarray:\n    \"\"\"computes the vector quantiles of `y` at values `u`, given the converged `v`\n\n    Args:\n        y: the observations, an `(n,2)` matrix\n        u: the values where we want the quantiles, an `(m,2)` matrix in $[0,1]$\n        v: the converged values of the weights, an `n`-vector\n\n    Returns:\n        an `(m,2)` matrix with the quantiles of `y` at the values `u`\n    \"\"\"\n    net_val = u @ y.T - v\n    k_max = np.argmax(net_val, 1)\n    return cast(np.ndarray, y[k_max])\n</code></pre>"},{"location":"bivariate_quantiles.html#bs_python_utils.bivariate_quantiles.bivariate_ranks","title":"<code>bivariate_ranks(y, n_nodes=32, verbose=False)</code>","text":"<p>computes the bivariate ranks of <code>y</code></p> <p>Parameters:</p> Name Type Description Default <code>y</code> <code>ndarray</code> <p>the observations, an <code>(n, 2)</code> matrix</p> required <code>n_nodes</code> <code>int</code> <p>the number of nodes to use for the quadrature</p> <code>32</code> <code>verbose</code> <code>bool</code> <p>if <code>True</code>, print some information</p> <code>False</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>the <code>(n, 2)</code> matrix of bivariate average ranks</p> Source code in <code>bs_python_utils/bivariate_quantiles.py</code> <pre><code>def bivariate_ranks(\n    y: np.ndarray, n_nodes: int = 32, verbose: bool = False\n) -&gt; np.ndarray:\n    \"\"\"computes the bivariate ranks of `y`\n\n    Args:\n        y: the observations, an `(n, 2)` matrix\n        n_nodes: the number of nodes to use for the quadrature\n        verbose: if `True`, print some information\n\n    Returns:\n        the `(n, 2)` matrix of bivariate average ranks\n    \"\"\"\n    v = solve_for_v_(y, n_nodes, verbose)\n    return bivariate_ranks_v(y, v, n_nodes)\n</code></pre>"},{"location":"bivariate_quantiles.html#bs_python_utils.bivariate_quantiles.bivariate_ranks_v","title":"<code>bivariate_ranks_v(y, v, n_nodes=32, presorted=False)</code>","text":"<p>computes the vector ranks of <code>y</code>, given the converged <code>v</code></p> <p>Parameters:</p> Name Type Description Default <code>y</code> <code>ndarray</code> <p>the observations, an <code>(n,2)</code> matrix</p> required <code>v</code> <code>ndarray</code> <p>the converged values of the weights, an <code>n</code>-vector</p> required <code>n_nodes</code> <code>int</code> <p>the number of nodes for Chebyshev integration</p> <code>32</code> <code>presorted</code> <code>bool</code> <p>if <code>True</code>, then <code>y</code> and <code>v</code> are sorted by increasing <code>y[:, 1]</code>.</p> <code>False</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>an <code>(n,2)</code> matrix with the average ranks of <code>y</code></p> Source code in <code>bs_python_utils/bivariate_quantiles.py</code> <pre><code>def bivariate_ranks_v(\n    y: np.ndarray, v: np.ndarray, n_nodes: int = 32, presorted: bool = False\n) -&gt; np.ndarray:\n    \"\"\"computes the vector ranks of `y`, given the converged `v`\n\n    Args:\n        y: the observations, an `(n,2)` matrix\n        v: the converged values of the weights, an `n`-vector\n        n_nodes: the number of nodes for Chebyshev integration\n        presorted: if `True`, then `y` and `v` are sorted by increasing `y[:, 1]`.\n\n    Returns:\n        an `(n,2)` matrix with the average ranks of `y`\n    \"\"\"\n    n, d = y.shape\n\n    if d != 2:\n        bs_error_abort(f\"only works for 2-dimensional y, not for {d}\")\n\n    interval01 = Interval(0.0, 1.0)\n    u1_nodes, u1_weights = cheb_get_nodes_1d(interval01, n_nodes)\n\n    if presorted:\n        sort_order = np.arange(n)\n        y_sorted = y\n        v_sorted = v\n    else:\n        sort_order = np.argsort(y[:, 1])\n        y_sorted = y[sort_order, :]\n        v_sorted = v[sort_order]\n\n    a_mat, b_mat = _compute_ab(y_sorted, v_sorted)\n\n    average_ranks = np.zeros((n, 2))\n\n    for k in range(n):\n        left_bounds, right_bounds = _compute_u2_bounds(k, u1_nodes, a_mat, b_mat)\n        pos_diffs = np.maximum(right_bounds - left_bounds, 0.0)\n        pos_diffs_sq = np.maximum(\n            right_bounds * right_bounds - left_bounds * left_bounds, 0.0\n        )\n        prob_k = pos_diffs @ u1_weights\n        average_ranks[sort_order[k], 0] = ((u1_nodes * pos_diffs) @ u1_weights) / prob_k\n        average_ranks[sort_order[k], 1] = ((pos_diffs_sq @ u1_weights) / 2.0) / prob_k\n\n    return average_ranks\n</code></pre>"},{"location":"bs_altair.html","title":"bs_altair module","text":"<p>Some Altair plots.</p> <ul> <li><code>alt_lineplot</code>, <code>alt_superposed_lineplot</code>, <code>alt_superposed_faceted_lineplot</code></li> <li><code>alt_plot_fun</code>: plots a function</li> <li><code>alt_density</code>, <code>alt_faceted_densities</code>: plots the density of <code>x</code>, or of <code>x</code> conditional on a category</li> <li><code>alt_superposed_faceted_densities</code>: plots the density of <code>x</code> superposed by <code>f</code> and faceted by <code>g</code></li> <li><code>alt_scatterplot</code>, <code>alt_scatterplot_with_histo</code>, <code>alt-linked_scatterplots</code>: variants of scatter plots</li> <li><code>alt_histogram_by</code>, <code>alt_histogram_continuous</code>: histograms of <code>x</code> by <code>y</code>, and of a continuous <code>x</code></li> <li><code>alt_stacked_area</code>,<code>alt_stacked_area_facets</code>: stacked area plots</li> <li><code>plot_parameterized_estimates</code>: plots densities of estimates of coefficients, with the true values,  as a function of a parameter</li> <li><code>plot_true_sim_facets, plot_true_sim2_facets</code>:  plot two simulated values and  the true values of statistics as a function of a parameter</li> <li><code>alt_tick_plots</code>: vertically arranged tick plots of variables</li> <li><code>alt_matrix_heatmap</code>: plots a heatmap of a matrix.</li> </ul>"},{"location":"bs_altair.html#bs_python_utils.bs_altair.alt_boxes","title":"<code>alt_boxes(df, continuous_var, discrete_var, group_var, max_cols=3, title=None, save=None)</code>","text":"<p>horizontal boxplots of <code>df[continuous_var]</code> by <code>df[discrete_var]</code> and <code>df[group_var]</code></p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>datframe with the three variables</p> required <code>continuous_var</code> <code>str</code> <p>name of the continuous variable</p> required <code>discrete_var</code> <code>str</code> <p>name of the discrete variable</p> required <code>group_var</code> <code>str</code> <p>name of the grouping variable</p> required <code>max_cols</code> <code>int</code> <p>maximum number of columns. Defaults to 3.</p> <code>3</code> <code>title</code> <code>str | None</code> <p>a plot title. Defaults to None.</p> <code>None</code> <code>save</code> <code>str | None</code> <p>the name of a file to save to (HTML extension will be added). Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Chart</code> <p>the chart.</p> Source code in <code>bs_python_utils/bs_altair.py</code> <pre><code>def alt_boxes(\n    df: pd.DataFrame,\n    continuous_var: str,\n    discrete_var: str,\n    group_var: str,\n    max_cols: int = 3,\n    title: str | None = None,\n    save: str | None = None,\n) -&gt; alt.Chart:\n    \"\"\"horizontal boxplots of `df[continuous_var]` by `df[discrete_var]` and `df[group_var]`\n\n    Args:\n        df: datframe with the three variables\n        continuous_var: name of the continuous variable\n        discrete_var: name of the discrete variable\n        group_var: name of the grouping variable\n        max_cols: maximum number of columns. Defaults to 3.\n        title: a plot title. Defaults to None.\n        save: the name of a file to save to (HTML extension will be added). Defaults to None.\n\n    Returns:\n        the chart.\n    \"\"\"\n    boxes = (\n        (\n            alt.Chart(df)\n            .mark_boxplot()\n            .encode(\n                x=f\"{continuous_var}:Q\", y=f\"{discrete_var}:O\", color=f\"{group_var}:N\"\n            )\n            .properties(width=180, height=180)\n        )\n        .facet(f\"{group_var}:N\", columns=max_cols)\n        .resolve_scale(y=\"independent\")\n    )\n    if title:\n        boxes = boxes.properties(title=title)\n    _maybe_save(boxes, save)\n    return cast(alt.Chart, boxes)\n</code></pre>"},{"location":"bs_altair.html#bs_python_utils.bs_altair.alt_density","title":"<code>alt_density(df, str_x, save=None)</code>","text":"<p>Plots the density of <code>df[str_x]</code>.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>the data with the <code>str_x</code> variable</p> required <code>str_x</code> <code>str</code> <p>the name of a continuous column</p> required <code>save</code> <code>str | None</code> <p>the name of a file to save to (HTML extension will be added)</p> <code>None</code> <p>Returns:</p> Type Description <code>Chart</code> <p>the <code>alt.Chart</code> object.</p> Source code in <code>bs_python_utils/bs_altair.py</code> <pre><code>def alt_density(df: pd.DataFrame, str_x: str, save: str | None = None) -&gt; alt.Chart:\n    \"\"\"Plots the density of `df[str_x]`.\n\n    Args:\n        df: the data with the `str_x` variable\n        str_x: the name of a continuous column\n        save: the name of a file to save to (HTML extension will be added)\n\n    Returns:\n        the `alt.Chart` object.\n    \"\"\"\n    ch = (\n        alt.Chart(df)\n        .transform_density(\n            str_x,\n            as_=[str_x, \"Density\"],\n        )\n        .mark_area(opacity=0.4)\n        .encode(\n            x=f\"{str_x}:Q\",\n            y=\"Density:Q\",\n        )\n    )\n\n    _maybe_save(ch, save)\n    return cast(alt.Chart, ch)\n</code></pre>"},{"location":"bs_altair.html#bs_python_utils.bs_altair.alt_faceted_densities","title":"<code>alt_faceted_densities(df, str_x, str_f, legend_title=None, save=None, max_cols=4)</code>","text":"<p>Plots the density of <code>df[str_x]</code> by <code>df[str_f]</code> in column facets</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>the data with the <code>str_x</code> and <code>str_f</code> variables</p> required <code>str_x</code> <code>str</code> <p>the name of a continuous column</p> required <code>str_f</code> <code>str</code> <p>the name of a categorical column</p> required <code>legend_title</code> <code>str | None</code> <p>a title for the legend</p> <code>None</code> <code>save</code> <code>str | None</code> <p>the name of a file to save to (HTML extension will be added)</p> <code>None</code> <code>max_cols</code> <code>int | None</code> <p>we wrap after that number of columns</p> <code>4</code> <p>Returns:</p> Type Description <code>Chart</code> <p>the <code>alt.Chart</code> object.</p> Source code in <code>bs_python_utils/bs_altair.py</code> <pre><code>def alt_faceted_densities(\n    df: pd.DataFrame,\n    str_x: str,\n    str_f: str,\n    legend_title: str | None = None,\n    save: str | None = None,\n    max_cols: int | None = 4,\n) -&gt; alt.Chart:\n    \"\"\"\n    Plots the density of `df[str_x]` by `df[str_f]` in column facets\n\n    Args:\n        df: the data with the `str_x` and `str_f` variables\n        str_x: the name of a continuous column\n        str_f: the name of a categorical column\n        legend_title: a title for the legend\n        save: the name of a file to save to (HTML extension will be added)\n        max_cols: we wrap after that number of columns\n\n    Returns:\n        the `alt.Chart` object.\n    \"\"\"\n    our_legend_title = str_f if legend_title is None else legend_title\n    ch = (\n        alt.Chart(df)\n        .transform_density(\n            str_x,\n            groupby=[str_f],\n            as_=[str_x, \"Density\"],\n        )\n        .mark_area(opacity=0.4)\n        .encode(\n            x=f\"{str_x}:Q\",\n            y=\"Density:Q\",\n            color=alt.Color(f\"{str_f}:N\", title=our_legend_title),\n        )\n        .facet(f\"{str_f}:N\", columns=max_cols)\n    )\n\n    _maybe_save(ch, save)\n    return cast(alt.Chart, ch)\n</code></pre>"},{"location":"bs_altair.html#bs_python_utils.bs_altair.alt_histogram_by","title":"<code>alt_histogram_by(df, str_x, str_y, str_agg='mean', save=None)</code>","text":"<p>Plots a histogram of a statistic of <code>str_y</code> by <code>str_x</code></p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>a dataframe with columns <code>str_x</code> and <code>str_y</code></p> required <code>str_x</code> <code>str</code> <p>a categorical variable</p> required <code>str_y</code> <code>str</code> <p>a continuous variable</p> required <code>str_agg</code> <code>str | None</code> <p>how we aggregate the values of <code>str_y</code> by <code>str_x</code></p> <code>'mean'</code> <code>save</code> <code>str | None</code> <p>the name of a file to save to (HTML extension will be added)</p> <code>None</code> <p>Returns:</p> Type Description <code>Chart</code> <p>the Altair chart.</p> Source code in <code>bs_python_utils/bs_altair.py</code> <pre><code>def alt_histogram_by(\n    df: pd.DataFrame,\n    str_x: str,\n    str_y: str,\n    str_agg: str | None = \"mean\",\n    save: str | None = None,\n) -&gt; alt.Chart:\n    \"\"\"\n    Plots a histogram of a statistic of `str_y` by `str_x`\n\n    Args:\n        df: a dataframe with columns `str_x` and `str_y`\n        str_x: a categorical variable\n        str_y: a continuous variable\n        str_agg: how we aggregate the values of `str_y` by `str_x`\n        save: the name of a file to save to (HTML extension will be added)\n\n    Returns:\n        the Altair chart.\n    \"\"\"\n    ch = (\n        alt.Chart(df)\n        .mark_bar()\n        .encode(x=str_x, y=f\"{str_agg}({str_y}):Q\")\n        .properties(height=300, width=400)\n    )\n    _maybe_save(ch, save)\n    return cast(alt.Chart, ch)\n</code></pre>"},{"location":"bs_altair.html#bs_python_utils.bs_altair.alt_histogram_continuous","title":"<code>alt_histogram_continuous(df, str_x, save=None)</code>","text":"<p>Histogram of a continuous variable <code>df[str_x]</code></p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>the data with the <code>str_x</code>, <code>str_y</code>, and <code>str_f</code> variables</p> required <code>str_x</code> <code>str</code> <p>the name of a continuous column</p> required <code>save</code> <code>str | None</code> <p>the name of a file to save to (HTML extension will be added)</p> <code>None</code> <p>Returns:</p> Type Description <code>Chart</code> <p>the <code>alt.Chart</code> object.</p> Source code in <code>bs_python_utils/bs_altair.py</code> <pre><code>def alt_histogram_continuous(\n    df: pd.DataFrame, str_x: str, save: str | None = None\n) -&gt; alt.Chart:\n    \"\"\"\n    Histogram of a continuous variable `df[str_x]`\n\n    Args:\n        df: the data with the `str_x`, `str_y`, and `str_f` variables\n        str_x: the name of a continuous column\n        save: the name of a file to save to (HTML extension will be added)\n\n    Returns:\n        the `alt.Chart` object.\n    \"\"\"\n    ch = alt.Chart(df).mark_bar().encode(alt.X(str_x, bin=True), y=\"count()\")\n    _maybe_save(ch, save)\n    return cast(alt.Chart, ch)\n</code></pre>"},{"location":"bs_altair.html#bs_python_utils.bs_altair.alt_lineplot","title":"<code>alt_lineplot(df, str_x, str_y, time_series=False, save=None, aggreg=None, **kwargs)</code>","text":"<p>Scatterplot of <code>df[str_x]</code> vs <code>df[str_y]</code></p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>the data with columns <code>str_x</code> and <code>str_y</code></p> required <code>str_x</code> <code>str</code> <p>the name of a continuous column</p> required <code>str_y</code> <code>str</code> <p>the name of a continuous column</p> required <code>time_series</code> <code>bool</code> <p><code>True</code> if x is a time series</p> <code>False</code> <code>save</code> <code>str | None</code> <p>the name of a file to save to (HTML extension will be added)</p> <code>None</code> <code>aggreg</code> <code>str | None</code> <p>the name of an aggregating function for <code>y</code></p> <code>None</code> <p>Returns:</p> Type Description <code>Chart</code> <p>the <code>alt.Chart</code> object.</p> Source code in <code>bs_python_utils/bs_altair.py</code> <pre><code>def alt_lineplot(\n    df: pd.DataFrame,\n    str_x: str,\n    str_y: str,\n    time_series: bool = False,\n    save: str | None = None,\n    aggreg: str | None = None,\n    **kwargs,\n) -&gt; alt.Chart:\n    \"\"\"\n    Scatterplot of `df[str_x]` vs `df[str_y]`\n\n    Args:\n        df: the data with columns `str_x` and `str_y`\n        str_x: the name of a continuous column\n        str_y: the name of a continuous column\n        time_series: `True` if x is a time series\n        save: the name of a file to save to (HTML extension will be added)\n        aggreg: the name of an aggregating function for `y`\n\n    Returns:\n        the `alt.Chart` object.\n    \"\"\"\n    type_x = \"T\" if time_series else \"Q\"\n    var_y = f\"{aggreg}({str_y}):Q\" if aggreg is not None else str_y\n\n    ch = alt.Chart(df).mark_line().encode(x=f\"{str_x}:{type_x}\", y=var_y)\n    if \"title\" in kwargs:\n        ch = ch.properties(title=kwargs[\"title\"])\n    _maybe_save(ch, save)\n    return cast(alt.Chart, ch)\n</code></pre>"},{"location":"bs_altair.html#bs_python_utils.bs_altair.alt_linked_scatterplots","title":"<code>alt_linked_scatterplots(df, str_x1, str_x2, str_y, str_f, save=None)</code>","text":"<p>Creates two scatterplots: of <code>df[str_x1]</code> vs <code>df[str_y]</code> and of <code>df[str_x2]</code> vs <code>df[str_y]</code>, both with color as per <code>df[str_f]</code>. Selecting an interval in one shows up in the other.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> required <code>str_x1</code> <code>str</code> <p>the name of a continuous column</p> required <code>str_x2</code> <code>str</code> <p>the name of a continuous column</p> required <code>str_y</code> <code>str</code> <p>the name of a continuous column</p> required <code>str_f</code> <code>str</code> <p>the name of a categorical column</p> required <code>save</code> <code>str | None</code> <p>the name of a file to save to (HTML extension will be added)</p> <code>None</code> <p>Returns:</p> Type Description <code>Chart</code> <p>the <code>alt.Chart</code> object.</p> Source code in <code>bs_python_utils/bs_altair.py</code> <pre><code>def alt_linked_scatterplots(\n    df: pd.DataFrame,\n    str_x1: str,\n    str_x2: str,\n    str_y: str,\n    str_f: str,\n    save: str | None = None,\n) -&gt; alt.Chart:\n    \"\"\"\n    Creates two scatterplots: of `df[str_x1]` vs `df[str_y]` and of `df[str_x2]` vs `df[str_y]`,\n    both with color as per `df[str_f]`. Selecting an interval in one shows up in the other.\n\n    Args:\n        df:\n        str_x1: the name of a continuous column\n        str_x2: the name of a continuous column\n        str_y: the name of a continuous column\n        str_f: the name of a categorical column\n        save: the name of a file to save to (HTML extension will be added)\n\n    Returns:\n          the `alt.Chart` object.\n    \"\"\"\n    interval = alt.selection_interval()\n\n    base = (\n        alt.Chart(df)\n        .mark_point()\n        .encode(\n            y=f\"{str_y}:Q\", color=alt.condition(interval, str_f, alt.value(\"lightgray\"))\n        )\n        .add_params(interval)\n    )\n\n    ch = base.encode(x=f\"{str_x1}:Q\") | base.encode(x=f\"{str_x2}:Q\")\n\n    _maybe_save(ch, save)\n    return cast(alt.Chart, ch)\n</code></pre>"},{"location":"bs_altair.html#bs_python_utils.bs_altair.alt_matrix_heatmap","title":"<code>alt_matrix_heatmap(mat, str_format, multiple=1.0, title=None, str_rows='Row', str_cols='Column', save=None)</code>","text":"<p>Plots a heatmap of a matrix</p> <p>Parameters:</p> Name Type Description Default <code>mat</code> <code>ndarray</code> <p>the matrix to plot</p> required <code>str_format</code> <code>str</code> <p>the string to format the values, e.g. \"d\" or \".3f\"</p> required <code>multiple</code> <code>float</code> <p>increases the size of the circles</p> <code>1.0</code> <code>title</code> <code>str | None</code> <p>a title, if any</p> <code>None</code> <code>str_rows</code> <code>str | None</code> <p>the name of the variable in the rows</p> <code>'Row'</code> <code>str_cols</code> <code>str | None</code> <p>the name of the variable in the columns</p> <code>'Column'</code> <code>save</code> <code>str | None</code> <p>the name of a file to save to (HTML extension will be added)</p> <code>None</code> <p>Returns:</p> Type Description <code>Chart</code> <p>the heatmap</p> Source code in <code>bs_python_utils/bs_altair.py</code> <pre><code>def alt_matrix_heatmap(\n    mat: np.ndarray,\n    str_format: str,\n    multiple: float = 1.0,\n    title: str | None = None,\n    str_rows: str | None = \"Row\",\n    str_cols: str | None = \"Column\",\n    save: str | None = None,\n) -&gt; alt.Chart:\n    \"\"\"Plots a heatmap of a matrix\n\n    Args:\n        mat: the matrix to plot\n        str_format: the string to format the values, e.g. \"d\" or \".3f\"\n        multiple: increases the size of the circles\n        title: a title, if any\n        str_rows: the name of the variable in the rows\n        str_cols: the name of the variable in the columns\n        save: the name of a file to save to (HTML extension will be added)\n\n    Returns:\n        the heatmap\n    \"\"\"\n    n_rows, n_cols = check_matrix(mat)\n    mat_arr = np.empty((mat.size, 4))\n    type_vals = \"float\"\n    if \"d\" in str_format:  # integer values\n        mat = np.round(mat)\n        type_vals = \"int\"\n    mat_min = np.min(mat)\n    i = 0\n    for ix in range(n_rows):\n        for iy in range(n_cols):\n            m = mat[ix, iy]\n            s = m - mat_min + 1\n            mat_arr[i, :] = np.array([ix, iy, m, s])\n            i += 1\n\n    mat_df = pd.DataFrame(mat_arr, columns=[str_rows, str_cols, \"Value\", \"Size\"])\n    if type_vals == \"int\":\n        mat_df = mat_df.astype(\n            dtype={str_rows: int, str_cols: int, \"Value\": int, \"Size\": float}\n        )\n    else:\n        mat_df = mat_df.astype(\n            dtype={str_rows: int, str_cols: int, \"Value\": float, \"Size\": float}\n        )\n    base = alt.Chart(mat_df).encode(\n        x=f\"{str_rows}:O\", y=alt.Y(f\"{str_cols}:O\", sort=\"descending\")\n    )\n    mat_map = base.mark_circle(opacity=0.4).encode(\n        size=alt.Size(\n            \"Size:Q\",\n            legend=None,\n            scale=alt.Scale(range=[1000 * multiple, 10000 * multiple]),\n        )\n    )\n    text = base.mark_text(baseline=\"middle\", fontSize=16).encode(\n        text=alt.Text(\"Value:Q\", format=str_format),\n    )\n    if title is None:\n        both = (mat_map + text).properties(width=500, height=500)\n    else:\n        both = (mat_map + text).properties(title=title, width=400, height=400)\n\n    _maybe_save(both, save)\n    return cast(alt.Chart, both)\n</code></pre>"},{"location":"bs_altair.html#bs_python_utils.bs_altair.alt_plot_fun","title":"<code>alt_plot_fun(f, start, end, npoints=100, save=None)</code>","text":"<p>Plots the function <code>f</code> from <code>start</code> to <code>end</code>.</p> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>Callable</code> <p>returns a Numpy array from a Numpy array</p> required <code>start</code> <code>float</code> <p>first point on <code>x</code> axis</p> required <code>end</code> <code>float</code> <p>last point on <code>x</code> axis</p> required <code>npoints</code> <code>int</code> <p>number of points</p> <code>100</code> <code>save</code> <code>str | None</code> <p>the name of a file to save to (HTML extension will be added)</p> <code>None</code> <p>Returns:</p> Type Description <code>Chart</code> <p>the <code>alt.Chart</code> object.</p> Source code in <code>bs_python_utils/bs_altair.py</code> <pre><code>def alt_plot_fun(\n    f: Callable,\n    start: float,\n    end: float,\n    npoints: int = 100,\n    save: str | None = None,\n) -&gt; alt.Chart:\n    \"\"\"\n    Plots the function `f` from `start` to `end`.\n\n    Args:\n        f: returns a Numpy array from a Numpy array\n        start: first point on `x` axis\n        end: last point on `x` axis\n        npoints: number of points\n        save: the name of a file to save to (HTML extension will be added)\n\n    Returns:\n        the `alt.Chart` object.\n    \"\"\"\n    step = (end - start) / npoints\n    points = np.arange(start, end + step, step)\n    fun_data = pd.DataFrame({\"x\": points, \"y\": f(points)})\n\n    ch = (\n        alt.Chart(fun_data)\n        .mark_line()\n        .encode(\n            x=\"x:Q\",\n            y=\"y:Q\",\n        )\n    )\n\n    _maybe_save(ch, save)\n    return cast(alt.Chart, ch)\n</code></pre>"},{"location":"bs_altair.html#bs_python_utils.bs_altair.alt_scatterplot","title":"<code>alt_scatterplot(df, str_x, str_y, time_series=False, save=None, xlabel=None, ylabel=None, size=30, title=None, color=None, aggreg=None, selection=False)</code>","text":"<p>Scatterplot of <code>df[str_x]</code> vs <code>df[str_y]</code>.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>the data with columns for x, y</p> required <code>str_x</code> <code>str</code> <p>the name of a continuous x column</p> required <code>str_y</code> <code>str</code> <p>the name of a continuous y column</p> required <code>time_series</code> <code>bool</code> <p><code>True</code> if x is a time series</p> <code>False</code> <code>xlabel</code> <code>str | None</code> <p>label for the horizontal axis</p> <code>None</code> <code>ylabel</code> <code>str | None</code> <p>label for the vertical axis</p> <code>None</code> <code>title</code> <code>str | None</code> <p>title for the graph</p> <code>None</code> <code>size</code> <code>int | None</code> <p>radius of the circles</p> <code>30</code> <code>color</code> <code>str | None</code> <p>variable that determines the color of the circles</p> <code>None</code> <code>selection</code> <code>bool</code> <p>if <code>True</code>, the user can select interactively from the <code>color</code> legend, if any</p> <code>False</code> <code>save</code> <code>str | None</code> <p>the name of a file to save to (HTML extension will be added)</p> <code>None</code> <code>aggreg</code> <code>str | None</code> <p>the name of an aggregating function for <code>y</code></p> <code>None</code> <p>Returns:</p> Type Description <code>Chart</code> <p>the <code>alt.Chart</code> object.</p> Source code in <code>bs_python_utils/bs_altair.py</code> <pre><code>def alt_scatterplot(\n    df: pd.DataFrame,\n    str_x: str,\n    str_y: str,\n    time_series: bool = False,\n    save: str | None = None,\n    xlabel: str | None = None,\n    ylabel: str | None = None,\n    size: int | None = 30,\n    title: str | None = None,\n    color: str | None = None,\n    aggreg: str | None = None,\n    selection: bool = False,\n) -&gt; alt.Chart:\n    \"\"\"\n    Scatterplot of `df[str_x]` vs `df[str_y]`.\n\n    Args:\n        df: the data with columns for x, y\n        str_x: the name of a continuous x column\n        str_y: the name of a continuous y column\n        time_series: `True` if x is a time series\n        xlabel: label for the horizontal axis\n        ylabel: label for the vertical axis\n        title: title for the graph\n        size: radius of the circles\n        color: variable that determines the color of the circles\n        selection: if `True`, the user can select interactively from the `color` legend, if any\n        save: the name of a file to save to (HTML extension will be added)\n        aggreg: the name of an aggregating function for `y`\n\n    Returns:\n        the `alt.Chart` object.\n    \"\"\"\n    type_x = \"T\" if time_series else \"Q\"\n    var_x = alt.X(f\"{str_x}:{type_x}\")\n\n    if xlabel is not None:\n        if isinstance(xlabel, str):\n            var_x = alt.X(f\"{str_x}:{type_x}\", axis=alt.Axis(title=xlabel))\n        else:\n            bs_error_abort(f\"xlabel must be a string, not {xlabel}\")\n\n    var_y = f\"{aggreg}({str_y}):Q\" if aggreg is not None else str_y\n\n    if ylabel is not None:\n        if isinstance(ylabel, str):\n            var_y_lab = alt.Y(var_y, axis=alt.Axis(title=ylabel))\n        else:\n            bs_error_abort(f\"ylabel must be a string, not {ylabel}\")\n\n    if isinstance(size, int):\n        circles_size = size\n    else:\n        bs_error_abort(f\"size must be an integer, not {size}\")\n\n    if color is not None:\n        if isinstance(color, str):\n            if selection:\n                selection_criterion = alt.selection_multi(fields=[color], bind=\"legend\")\n                ch = (\n                    alt.Chart(df)\n                    .mark_circle(size=circles_size)\n                    .encode(\n                        x=var_x,\n                        y=var_y if ylabel is None else var_y_lab,\n                        color=color,\n                        opacity=alt.condition(\n                            selection_criterion, alt.value(1), alt.value(0.1)\n                        ),\n                    )\n                    .add_params(selection_criterion)\n                )\n            else:\n                ch = (\n                    alt.Chart(df)\n                    .mark_circle(size=circles_size)\n                    .encode(x=var_x, y=var_y, color=color)\n                )\n        else:\n            bs_error_abort(f\"color must be a string, not {color}\")\n    else:\n        ch = alt.Chart(df).mark_circle(size=circles_size).encode(x=var_x, y=var_y)\n\n    ch = _add_title(ch, title)\n    _maybe_save(ch, save)\n    return cast(alt.Chart, ch)\n</code></pre>"},{"location":"bs_altair.html#bs_python_utils.bs_altair.alt_scatterplot_with_histo","title":"<code>alt_scatterplot_with_histo(df, str_x, str_y, str_f, save=None)</code>","text":"<p>Scatterplot of <code>df[str_x]</code> vs <code>df[str_y]</code> with colors as per <code>df[str_f]</code> allows to select an interval and histograns the counts of <code>df[str_f]</code> in the interval.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>the data with the <code>str_x</code> and <code>str_f</code> variables</p> required <code>str_x</code> <code>str</code> <p>the name of a continuous column</p> required <code>str_y</code> <code>str</code> <p>the name of a continuous column</p> required <code>str_f</code> <code>str</code> <p>the name of a categorical column</p> required <code>save</code> <code>str | None</code> <p>the name of a file to save to (HTML extension will be added)</p> <code>None</code> <p>Returns:</p> Type Description <code>Chart</code> <p>the <code>alt.Chart</code> object.</p> Source code in <code>bs_python_utils/bs_altair.py</code> <pre><code>def alt_scatterplot_with_histo(\n    df: pd.DataFrame, str_x: str, str_y: str, str_f: str, save: str | None = None\n) -&gt; alt.Chart:\n    \"\"\"\n    Scatterplot of `df[str_x]` vs `df[str_y]` with colors as per `df[str_f]`\n    allows to select an interval and histograns the counts of `df[str_f]` in the interval.\n\n    Args:\n        df: the data with the `str_x` and `str_f` variables\n        str_x: the name of a continuous column\n        str_y: the name of a continuous column\n        str_f: the name of a categorical column\n        save: the name of a file to save to (HTML extension will be added)\n\n    Returns:\n          the `alt.Chart` object.\n    \"\"\"\n    interval = alt.selection_interval()\n\n    points = (\n        alt.Chart(df)\n        .mark_point()\n        .encode(\n            x=f\"{str_x}:Q\",\n            y=f\"{str_y}:Q\",\n            color=alt.condition(interval, str_f, alt.value(\"lightgray\")),\n        )\n        .add_params(interval)\n    )\n\n    histogram = (\n        alt.Chart(df)\n        .mark_bar()\n        .encode(\n            x=\"count()\",\n            y=str_f,\n            color=str_f,\n        )\n        .transform_filter(interval)\n    )\n\n    ch = points &amp; histogram\n\n    _maybe_save(ch, save)\n    return cast(alt.Chart, ch)\n</code></pre>"},{"location":"bs_altair.html#bs_python_utils.bs_altair.alt_stacked_area","title":"<code>alt_stacked_area(df, str_x, str_y, str_f, time_series=False, title=None, save=None)</code>","text":"<p>Normalized stacked lineplots of <code>df[str_x]</code> vs <code>df[str_y]</code> by <code>df[str_f]</code></p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>the data with columns for <code>str_x</code>, <code>str_y</code>, and <code>str_f</code></p> required <code>str_x</code> <code>str</code> <p>the name of a continuous column</p> required <code>str_y</code> <code>str</code> <p>the name of a continuous column</p> required <code>str_f</code> <code>str</code> <p>the name of a categorical column</p> required <code>time_series</code> <code>bool</code> <p><code>True</code> if <code>str_x</code> is a time series</p> <code>False</code> <code>title</code> <code>str | None</code> <p>a title for the plot</p> <code>None</code> <code>save</code> <code>str | None</code> <p>the name of a file to save to (HTML extension will be added)</p> <code>None</code> <p>Returns:</p> Type Description <code>Chart</code> <p>the <code>alt.Chart</code> object.</p> Source code in <code>bs_python_utils/bs_altair.py</code> <pre><code>def alt_stacked_area(\n    df: pd.DataFrame,\n    str_x: str,\n    str_y: str,\n    str_f: str,\n    time_series: bool = False,\n    title: str | None = None,\n    save: str | None = None,\n) -&gt; alt.Chart:\n    \"\"\"\n    Normalized stacked lineplots of `df[str_x]` vs `df[str_y]` by `df[str_f]`\n\n    Args:\n        df: the data with columns for `str_x`, `str_y`, and `str_f`\n        str_x: the name of a continuous column\n        str_y: the name of a continuous column\n        str_f: the name of a categorical column\n        time_series: `True` if `str_x` is a time series\n        title: a title for the plot\n        save: the name of a file to save to (HTML extension will be added)\n\n    Returns:\n        the `alt.Chart` object.\n    \"\"\"\n    type_x = \"T\" if time_series else \"Q\"\n    ch = (\n        alt.Chart(df)\n        .mark_area()\n        .encode(\n            x=f\"{str_x}:{type_x}\",\n            y=alt.Y(f\"{str_y}:Q\", stack=\"normalize\"),\n            color=f\"{str_f}:N\",\n        )\n    )\n    if title is not None:\n        ch = ch.properties(title=title)\n\n    _maybe_save(ch, save)\n    return cast(alt.Chart, ch)\n</code></pre>"},{"location":"bs_altair.html#bs_python_utils.bs_altair.alt_stacked_area_facets","title":"<code>alt_stacked_area_facets(df, str_x, str_y, str_f, str_g, time_series=False, max_cols=5, title=None, save=None)</code>","text":"<p>Normalized stacked lineplots of <code>df[str_x]</code> vs <code>df[str_y]</code> by <code>df[str_f]</code>, faceted by <code>df[str_g]</code></p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>the data with columns for <code>str_x</code>, <code>str_y</code>, and <code>str_f</code></p> required <code>str_x</code> <code>str</code> <p>the name of a continuous column</p> required <code>str_y</code> <code>str</code> <p>the name of a continuous column</p> required <code>str_f</code> <code>str</code> <p>the name of a categorical column</p> required <code>str_g</code> <code>str</code> <p>the name of a categorical column</p> required <code>time_series</code> <code>bool</code> <p><code>True</code> if <code>str_x</code> is a time series</p> <code>False</code> <code>title</code> <code>str | None</code> <p>a title for the plot</p> <code>None</code> <code>save</code> <code>str | None</code> <p>the name of a file to save to (HTML extension will be added)</p> <code>None</code> <p>Returns:</p> Type Description <code>Chart</code> <p>the <code>alt.Chart</code> object.</p> Source code in <code>bs_python_utils/bs_altair.py</code> <pre><code>def alt_stacked_area_facets(\n    df: pd.DataFrame,\n    str_x: str,\n    str_y: str,\n    str_f: str,\n    str_g: str,\n    time_series: bool = False,\n    max_cols: int | None = 5,\n    title: str | None = None,\n    save: str | None = None,\n) -&gt; alt.Chart:\n    \"\"\"\n    Normalized stacked lineplots of `df[str_x]` vs `df[str_y]` by `df[str_f]`, faceted by `df[str_g]`\n\n    Args:\n        df: the data with columns for `str_x`, `str_y`, and `str_f`\n        str_x: the name of a continuous column\n        str_y: the name of a continuous column\n        str_f: the name of a categorical column\n        str_g: the name of a categorical column\n        time_series: `True` if `str_x` is a time series\n        title: a title for the plot\n        save: the name of a file to save to (HTML extension will be added)\n\n    Returns:\n        the `alt.Chart` object.\n    \"\"\"\n    type_x = \"T\" if time_series else \"Q\"\n    ch = (\n        alt.Chart(df)\n        .mark_area()\n        .encode(\n            x=f\"{str_x}:{type_x}\",\n            y=alt.Y(f\"{str_y}:Q\", stack=\"normalize\"),\n            color=f\"{str_f}:N\",\n            facet=(\n                alt.Facet(f\"{str_g}:N\", columns=max_cols)\n                if max_cols is not None\n                else alt.Facet(f\"{str_g}:N\")\n            ),\n        )\n    )\n    _maybe_save(ch, save)\n    return cast(alt.Chart, ch)\n</code></pre>"},{"location":"bs_altair.html#bs_python_utils.bs_altair.alt_superposed_faceted_densities","title":"<code>alt_superposed_faceted_densities(df, str_x, str_f, str_g, max_cols=4, save=None)</code>","text":"<p>Creates density plots of <code>df[str_x]</code> by <code>df[str_f]</code> and <code>df[str_g]</code> with color as per <code>df[str_f]</code> and faceted by <code>df[str_g]</code>. that is: facets by <code>str_g</code>, with densities conditional on <code>str_f</code> superposed.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>a Pandas dataframe wity columns <code>str_x</code>, <code>str_f</code>, <code>str_g</code></p> required <code>str_x</code> <code>str</code> <p>the name of a continuous column</p> required <code>str_f</code> <code>str</code> <p>the name of a categorical column</p> required <code>str_g</code> <code>str</code> <p>the name of a categorical column</p> required <code>max_cols</code> <code>int | None</code> <p>the number of columns after whcih we wrap</p> <code>4</code> <code>save</code> <code>str | None</code> <p>the name of a file to save to (HTML extension will be added)</p> <code>None</code> <p>Returns:</p> Type Description <code>Chart</code> <p>the <code>alt.Chart</code> object.</p> Source code in <code>bs_python_utils/bs_altair.py</code> <pre><code>def alt_superposed_faceted_densities(\n    df: pd.DataFrame,\n    str_x: str,\n    str_f: str,\n    str_g: str,\n    max_cols: int | None = 4,\n    save: str | None = None,\n) -&gt; alt.Chart:\n    \"\"\"\n    Creates density plots of `df[str_x]` by `df[str_f]` and `df[str_g]`\n    with color as per `df[str_f]` and faceted by `df[str_g]`.\n    that is: facets by `str_g`, with densities conditional on `str_f` superposed.\n\n    Args:\n        df: a Pandas dataframe wity columns `str_x`, `str_f`, `str_g`\n        str_x: the name of a continuous column\n        str_f: the name of a categorical column\n        str_g: the name of a categorical column\n        max_cols: the number of columns after whcih we wrap\n        save: the name of a file to save to (HTML extension will be added)\n\n    Returns:\n          the `alt.Chart` object.\n    \"\"\"\n    densities = (\n        alt.Chart(df)\n        .transform_density(\n            str_x,\n            groupby=[str_f, str_g],\n            as_=[str_x, \"Density\"],\n        )\n        .mark_line()\n        .encode(\n            x=f\"{str_x}:Q\",\n            y=\"Density:Q\",\n            color=f\"{str_f}:N\",\n        )\n        .facet(column=f\"{str_g}:N\", columns=max_cols)\n        .resolve_scale(x=\"independent\", y=\"independent\")\n    )\n    _maybe_save(densities, save)\n\n    return cast(alt.Chart, densities)\n</code></pre>"},{"location":"bs_altair.html#bs_python_utils.bs_altair.alt_superposed_faceted_lineplot","title":"<code>alt_superposed_faceted_lineplot(df, str_x, str_y, str_f, str_g, time_series=False, legend_title=None, max_cols=5, save=None)</code>","text":"<p>Plots <code>df[str_x]</code> vs <code>df[str_y]</code> superposed by <code>df[str_f]</code> and faceted by <code>df[str_g]</code></p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>the data with the <code>str_x</code>, <code>str_y</code>, and <code>str_f</code> variables</p> required <code>str_x</code> <code>str</code> <p>the name of a continuous column</p> required <code>str_y</code> <code>str</code> <p>the name of a continuous column</p> required <code>str_f</code> <code>str</code> <p>the name of a categorical column</p> required <code>str_g</code> <code>str</code> <p>the name of a categorical column</p> required <code>time_series</code> <code>bool</code> <p><code>True</code> if <code>str_x</code> is a time series</p> <code>False</code> <code>legend_title</code> <code>str | None</code> <p>a title for the legend</p> <code>None</code> <code>save</code> <code>str | None</code> <p>the name of a file to save to (HTML extension will be added)</p> <code>None</code> <code>max_cols</code> <code>int | None</code> <p>we wrap after that number of columns</p> <code>5</code> <p>Returns:</p> Type Description <code>Chart</code> <p>the <code>alt.Chart</code> object.</p> Source code in <code>bs_python_utils/bs_altair.py</code> <pre><code>def alt_superposed_faceted_lineplot(\n    df: pd.DataFrame,\n    str_x: str,\n    str_y: str,\n    str_f: str,\n    str_g: str,\n    time_series: bool = False,\n    legend_title: str | None = None,\n    max_cols: int | None = 5,\n    save: str | None = None,\n) -&gt; alt.Chart:\n    \"\"\"\n    Plots `df[str_x]` vs `df[str_y]` superposed by `df[str_f]` and faceted by `df[str_g]`\n\n    Args:\n        df: the data with the `str_x`, `str_y`, and `str_f` variables\n        str_x: the name of a continuous column\n        str_y: the name of a continuous column\n        str_f: the name of a categorical column\n        str_g: the name of a categorical column\n        time_series: `True` if `str_x` is a time series\n        legend_title: a title for the legend\n        save: the name of a file to save to (HTML extension will be added)\n        max_cols: we wrap after that number of columns\n\n\n    Returns:\n        the `alt.Chart` object.\n    \"\"\"\n    type_x = \"T\" if time_series else \"Q\"\n    our_title = str_f if legend_title is None else legend_title\n    ch = (\n        alt.Chart(df)\n        .mark_line()\n        .encode(\n            x=f\"{str_x}:{type_x}\",\n            y=f\"{str_y}:Q\",\n            color=alt.Color(f\"{str_f}:N\", title=our_title),\n            facet=(\n                alt.Facet(f\"{str_g}:N\", columns=max_cols)\n                if max_cols is not None\n                else alt.Facet(f\"{str_g}:N\")\n            ),\n        )\n    )\n    _maybe_save(ch, save)\n    return cast(alt.Chart, ch)\n</code></pre>"},{"location":"bs_altair.html#bs_python_utils.bs_altair.alt_superposed_lineplot","title":"<code>alt_superposed_lineplot(df, str_x, str_y, str_f, time_series=False, legend_title=None, save=None)</code>","text":"<p>Plots <code>df[str_x]</code> vs <code>df[str_y]</code> by <code>df[str_f]</code> on one plot</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>the data with the <code>str_x</code>, <code>str_y</code>, and <code>str_f</code> variables</p> required <code>str_x</code> <code>str</code> <p>the name of a continuous <code>x</code> column</p> required <code>str_y</code> <code>str</code> <p>the name of a continuous <code>y</code> column</p> required <code>str_f</code> <code>str</code> <p>the name of a categorical <code>f</code> column</p> required <code>time_series</code> <code>bool</code> <p><code>True</code> if <code>str_x</code> is a time series</p> <code>False</code> <code>legend_title</code> <code>str | None</code> <p>a title for the legend</p> <code>None</code> <code>save</code> <code>str | None</code> <p>the name of a file to save to (HTML extension will be added)</p> <code>None</code> <p>Returns:</p> Type Description <code>Chart</code> <p>the <code>alt.Chart</code> object.</p> Source code in <code>bs_python_utils/bs_altair.py</code> <pre><code>def alt_superposed_lineplot(\n    df: pd.DataFrame,\n    str_x: str,\n    str_y: str,\n    str_f: str,\n    time_series: bool = False,\n    legend_title: str | None = None,\n    save: str | None = None,\n) -&gt; alt.Chart:\n    \"\"\"\n    Plots `df[str_x]` vs `df[str_y]` by `df[str_f]` on one plot\n\n    Args:\n        df: the data with the `str_x`, `str_y`, and `str_f` variables\n        str_x: the name of a continuous `x` column\n        str_y: the name of a continuous `y` column\n        str_f: the name of a categorical `f` column\n        time_series: `True` if `str_x` is a time series\n        legend_title: a title for the legend\n        save: the name of a file to save to (HTML extension will be added)\n\n    Returns:\n        the `alt.Chart` object.\n    \"\"\"\n    type_x = \"T\" if time_series else \"Q\"\n    our_legend_title = str_f if legend_title is None else legend_title\n    ch = (\n        alt.Chart(df)\n        .mark_line()\n        .encode(\n            x=f\"{str_x}:{type_x}\",\n            y=f\"{str_y}:Q\",\n            color=alt.Color(f\"{str_f}:N\", title=our_legend_title),\n        )\n    )\n    _maybe_save(ch, save)\n    return cast(alt.Chart, ch)\n</code></pre>"},{"location":"bs_altair.html#bs_python_utils.bs_altair.alt_tick_plots","title":"<code>alt_tick_plots(df, list_vars, save=None)</code>","text":"<p>Creates a tick plot of the variables in <code>list_vars</code> of<code>df</code>, arranged vertically.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>a dataframe with the variables in <code>list_vars</code></p> required <code>list_vars</code> <code>str | list[str]</code> <p>the name of a column of <code>df</code>, or a list of names</p> required <code>save</code> <code>str | None</code> <p>the name of a file to save to (HTML extension will be added)</p> <code>None</code> <p>Returns:</p> Type Description <code>Chart</code> <p>the <code>alt.Chart</code> object.</p> Source code in <code>bs_python_utils/bs_altair.py</code> <pre><code>def alt_tick_plots(\n    df: pd.DataFrame, list_vars: str | list[str], save: str | None = None\n) -&gt; alt.Chart:\n    \"\"\"\n    Creates a tick plot of the variables in `list_vars` of`df`, arranged vertically.\n\n    Args:\n        df: a dataframe with the variables in `list_vars`\n        list_vars: the name of a column of `df`, or a list of names\n        save: the name of a file to save to (HTML extension will be added)\n\n    Returns:\n        the `alt.Chart` object.\n    \"\"\"\n    if isinstance(list_vars, str):\n        varname = list_vars\n        ch = alt.Chart(df).encode(x=varname).mark_tick()\n    else:\n        ch = (\n            alt.Chart(df)\n            .encode(alt.X(alt.repeat(\"row\"), type=\"quantitative\"))\n            .mark_tick()\n            .repeat(row=list_vars)\n            .resolve_scale(y=\"independent\")\n        )\n\n    _maybe_save(ch, save)\n\n    return cast(alt.Chart, ch)\n</code></pre>"},{"location":"bs_altair.html#bs_python_utils.bs_altair.plot_parameterized_estimates","title":"<code>plot_parameterized_estimates(parameter_name, parameter_values, coeff_names, true_values, estimate_names, estimates, colors, save=None)</code>","text":"<p>Plots estimates of coefficients, with the true values,  as a function of a parameter; one facet per coefficient</p> <p>Parameters:</p> Name Type Description Default <code>parameter_name</code> <code>str</code> <p>the name of the parameter</p> required <code>parameter_values</code> <code>ndarray</code> <p>a vector of <code>n_vals</code> values for the parameter</p> required <code>coeff_names</code> <code>str | list[str]</code> <p>the names of the <code>n_coeffs</code> coefficients</p> required <code>true_values</code> <code>ndarray</code> <p>their true values, depending on the parameter or not</p> required <code>estimate_names</code> <code>str | list[str]</code> <p>names of the estimates</p> required <code>estimates</code> <code>ndarray</code> <p>their values</p> required <code>colors</code> <code>list[str]</code> <p>colors for the various estimates</p> required <code>save</code> <code>str | None</code> <p>the name of a file to save to (HTML extension will be added)</p> <code>None</code> <p>Returns:</p> Type Description <code>Chart</code> <p>the <code>alt.Chart</code> object.</p> Source code in <code>bs_python_utils/bs_altair.py</code> <pre><code>def plot_parameterized_estimates(\n    parameter_name: str,\n    parameter_values: np.ndarray,\n    coeff_names: str | list[str],\n    true_values: np.ndarray,\n    estimate_names: str | list[str],\n    estimates: np.ndarray,\n    colors: list[str],\n    save: str | None = None,\n) -&gt; alt.Chart:\n    \"\"\"\n    Plots estimates of coefficients, with the true values,  as a function of a parameter; one facet per coefficient\n\n    Args:\n        parameter_name: the name of the parameter\n        parameter_values: a vector of `n_vals` values for the parameter\n        coeff_names: the names of the `n_coeffs` coefficients\n        true_values: their true values, depending on the parameter or not\n        estimate_names: names of the estimates\n        estimates: their values\n        colors: colors for the various estimates\n        save: the name of a file to save to (HTML extension will be added)\n\n    Returns:\n        the `alt.Chart` object.\n    \"\"\"\n    n_vals = check_vector(parameter_values)\n    n_coeffs = 1 if isinstance(coeff_names, str) else len(coeff_names)\n    if n_coeffs == 1:\n        n_true = check_vector(true_values, \"plot_parameterized_estimates\")\n        if n_true != n_vals:\n            bs_error_abort(\n                f\"plot_parameterized_estimates: we have {n_true} values and\"\n                f\" {n_vals} parameter values.\"\n            )\n        df = pd.DataFrame({parameter_name: parameter_values, \"True value\": true_values})\n        df1, ordered_estimates = _stack_estimates(estimate_names, estimates, df)\n        df1m = pd.melt(df1, parameter_name, var_name=\"Estimate\")\n        ch = (\n            alt.Chart(df1m)\n            .mark_line()\n            .encode(\n                x=f\"{parameter_name}:Q\",\n                y=\"value:Q\",\n                strokeDash=alt.StrokeDash(\"Estimate:N\", sort=ordered_estimates),\n                color=alt.Color(\n                    \"Estimate:N\",\n                    sort=estimate_names,\n                    scale=alt.Scale(domain=ordered_estimates, range=colors),\n                ),\n            )\n        )\n    else:\n        n_true, n_c = check_matrix(true_values, \"plot_parameterized_estimates\")\n        if n_true != n_vals:\n            bs_error_abort(\n                f\"plot_parameterized_estimates: we have {n_true} true values and\"\n                f\" {n_vals} parameter values.\"\n            )\n        if n_c != n_coeffs:\n            bs_error_abort(\n                f\"plot_parameterized_estimates: we have {n_c} columns of true values\"\n                f\" and {n_coeffs} coefficients.\"\n            )\n        df1 = [None] * n_coeffs\n        for i_coeff, coeff in enumerate(coeff_names):\n            df_i = pd.DataFrame(\n                {\n                    parameter_name: parameter_values,\n                    \"True value\": true_values[:, i_coeff],\n                }\n            )\n            df1[i_coeff], ordered_estimates = _stack_estimates(\n                estimate_names, estimates[..., i_coeff], df_i\n            )\n            df1[i_coeff][\"Coefficient\"] = coeff\n\n        df2 = pd.concat(df1[i_coeff] for i_coeff in range(n_coeffs))\n        ordered_colors = colors\n        df2m = pd.melt(df2, [parameter_name, \"Coefficient\"], var_name=\"Estimate\")\n        ch = (\n            alt.Chart(df2m)\n            .mark_line()\n            .encode(\n                x=f\"{parameter_name}:Q\",\n                y=\"value:Q\",\n                strokeDash=alt.StrokeDash(\"Estimate:N\", sort=ordered_estimates),\n                color=alt.Color(\n                    \"Estimate:N\",\n                    sort=ordered_estimates,\n                    scale=alt.Scale(domain=ordered_estimates, range=ordered_colors),\n                ),\n            )\n            .facet(alt.Facet(\"Coefficient:N\", sort=coeff_names))\n            .resolve_scale(y=\"independent\")\n        )\n\n    _maybe_save(ch, save)\n\n    return cast(alt.Chart, ch)\n</code></pre>"},{"location":"bs_altair.html#bs_python_utils.bs_altair.plot_true_sim2_facets","title":"<code>plot_true_sim2_facets(parameter_name, parameter_values, stat_names, stat_true, stat_sim1, stat_sim2, colors, stat_title='Statistic', subtitle='True vs estimated', ncols=3, save=None)</code>","text":"<p>Plots simulated values for two methods and true values of statistics as a function of a parameter; one facet per coefficient</p> <p>Parameters:</p> Name Type Description Default <code>parameter_name</code> <code>str</code> <p>the name of the parameter</p> required <code>parameter_values</code> <code>ndarray</code> <p>a vector of <code>n_vals</code> values for the parameter</p> required <code>stat_names</code> <code>list[str]</code> <p>the names of the <code>n</code> statistics</p> required <code>stat_true</code> <code>ndarray</code> <p>their true values, <code>(n_vals, n)</code></p> required <code>stat_sim1</code> <code>ndarray</code> <p>their simulated values, method 1</p> required <code>stat_sim2</code> <code>ndarray</code> <p>their simulated values, method 2</p> required <code>colors</code> <code>list[str]</code> <p>colors for the various estimates</p> required <code>stat_title</code> <code>str | None</code> <p>main title</p> <code>'Statistic'</code> <code>subtitle</code> <code>str | None</code> <p>subtitle</p> <code>'True vs estimated'</code> <code>ncols</code> <code>int | None</code> <p>wrap after <code>ncols</code> columns</p> <code>3</code> <code>save</code> <code>str | None</code> <p>the name of a file to save to (HTML extension will be added)</p> <code>None</code> <p>Returns:</p> Type Description <code>Chart</code> <p>the <code>alt.Chart</code> object.</p> Source code in <code>bs_python_utils/bs_altair.py</code> <pre><code>def plot_true_sim2_facets(\n    parameter_name: str,\n    parameter_values: np.ndarray,\n    stat_names: list[str],\n    stat_true: np.ndarray,\n    stat_sim1: np.ndarray,\n    stat_sim2: np.ndarray,\n    colors: list[str],\n    stat_title: str | None = \"Statistic\",\n    subtitle: str | None = \"True vs estimated\",\n    ncols: int | None = 3,\n    save: str | None = None,\n) -&gt; alt.Chart:\n    \"\"\"\n    Plots simulated values for two methods and true values of statistics as a function of a parameter;\n    one facet per coefficient\n\n    Args:\n        parameter_name: the name of the parameter\n        parameter_values: a vector of `n_vals` values for the parameter\n        stat_names: the names of the `n` statistics\n        stat_true: their true values, `(n_vals, n)`\n        stat_sim1: their simulated values, method 1\n        stat_sim2: their simulated values, method 2\n        colors: colors for the various estimates\n        stat_title: main title\n        subtitle: subtitle\n        ncols: wrap after `ncols` columns\n        save: the name of a file to save to (HTML extension will be added)\n\n    Returns:\n        the `alt.Chart` object.\n    \"\"\"\n    n_stats = len(stat_names)\n    nvals = check_vector(parameter_values, \"plot_true_sim2_facets\")\n    nv_true, n_stat_true = check_matrix(stat_true, \"plot_true_sim2_facets\")\n    if nv_true != nvals:\n        bs_error_abort(f\"we have {nvals} parameter values and {nv_true} for stat_true.\")\n    if n_stat_true != n_stats:\n        bs_error_abort(f\"we have {n_stats} names for {n_stat_true} true statistics.\")\n\n    nv_est1, n_stat_est1 = check_matrix(stat_sim1, \"plot_true_sim2_facets\")\n    if nv_est1 != nvals:\n        bs_error_abort(f\"we have {nvals} parameter values and {nv_est1} for stat_sim1.\")\n    if n_stat_est1 != n_stats:\n        bs_error_abort(\n            f\"we have {n_stats} names for {n_stat_est1} estimated statistics.\"\n        )\n    nv_est2, n_stat_est2 = check_matrix(stat_sim2, \"plot_true_sim2_facets\")\n    if nv_est2 != nvals:\n        bs_error_abort(f\"we have {nvals} parameter values and {nv_est2} for stat_sim2.\")\n    if n_stat_est2 != n_stats:\n        bs_error_abort(\n            f\"we have {n_stats} names for {n_stat_est2} estimated statistics.\"\n        )\n\n    df = pd.DataFrame(\n        {\n            parameter_name: parameter_values,\n            \"True value\": stat_true[:, 0],\n            \"Estimated1\": stat_sim1[:, 0],\n            \"Estimated2\": stat_sim2[:, 0],\n            stat_title: stat_names[0],\n        }\n    )\n    for i_stat in range(1, n_stats):\n        df_i = pd.DataFrame(\n            {\n                parameter_name: parameter_values,\n                \"True value\": stat_true[:, i_stat],\n                \"Estimated1\": stat_sim1[:, i_stat],\n                \"Estimated2\": stat_sim2[:, i_stat],\n                stat_title: stat_names[i_stat],\n            }\n        )\n        df = pd.concat((df, df_i))\n    sub_order = [\"True value\", \"Estimated1\", \"Estimated2\"]\n    dfm = pd.melt(df, [parameter_name, stat_title], var_name=subtitle)\n    ch = (\n        alt.Chart(dfm)\n        .mark_line()\n        .encode(\n            x=f\"{parameter_name}:Q\",\n            y=\"value:Q\",\n            strokeDash=alt.StrokeDash(f\"{subtitle}:N\", sort=sub_order),\n            color=alt.Color(\n                f\"{subtitle}:N\",\n                sort=sub_order,\n                scale=alt.Scale(domain=sub_order, range=colors),\n            ),\n            facet=(\n                alt.Facet(f\"{stat_title}:N\", sort=stat_names, columns=ncols)\n                if ncols is not None\n                else alt.Facet(f\"{stat_title}:N\", sort=stat_names)\n            ),\n        )\n        .resolve_scale(y=\"independent\")\n    )\n\n    _maybe_save(ch, save)\n\n    return cast(alt.Chart, ch)\n</code></pre>"},{"location":"bs_altair.html#bs_python_utils.bs_altair.plot_true_sim_facets","title":"<code>plot_true_sim_facets(parameter_name, parameter_values, stat_names, stat_true, stat_sim, colors, stat_title='Statistic', subtitle='True vs estimated', ncols=3, save=None)</code>","text":"<p>Plots simulated and true values of statistics as a function of a parameter; one facet per coefficient</p> <p>Parameters:</p> Name Type Description Default <code>parameter_name</code> <code>str</code> <p>the name of the parameter</p> required <code>parameter_values</code> <code>ndarray</code> <p>a vector of <code>n_vals</code> values for the parameter</p> required <code>stat_names</code> <code>list[str]</code> <p>the names of the <code>n</code> statistics</p> required <code>stat_true</code> <code>ndarray</code> <p>their true values, <code>(n_vals, n)</code></p> required <code>stat_sim</code> <code>ndarray</code> <p>their simulated values</p> required <code>colors</code> <code>list[str]</code> <p>colors for the various estimates</p> required <code>stat_title</code> <code>str | None</code> <p>main title</p> <code>'Statistic'</code> <code>subtitle</code> <code>str | None</code> <p>subtitle</p> <code>'True vs estimated'</code> <code>ncols</code> <code>int | None</code> <p>wrap after <code>ncols</code> columns</p> <code>3</code> <code>save</code> <code>str | None</code> <p>the name of a file to save to (HTML extension will be added)</p> <code>None</code> <p>Returns:</p> Type Description <code>Chart</code> <p>the <code>alt.Chart</code> object.</p> Source code in <code>bs_python_utils/bs_altair.py</code> <pre><code>def plot_true_sim_facets(\n    parameter_name: str,\n    parameter_values: np.ndarray,\n    stat_names: list[str],\n    stat_true: np.ndarray,\n    stat_sim: np.ndarray,\n    colors: list[str],\n    stat_title: str | None = \"Statistic\",\n    subtitle: str | None = \"True vs estimated\",\n    ncols: int | None = 3,\n    save: str | None = None,\n) -&gt; alt.Chart:\n    \"\"\"\n    Plots simulated and true values of statistics as a function of a parameter; one facet per coefficient\n\n    Args:\n        parameter_name: the name of the parameter\n        parameter_values: a vector of `n_vals` values for the parameter\n        stat_names: the names of the `n` statistics\n        stat_true: their true values, `(n_vals, n)`\n        stat_sim: their simulated values\n        colors: colors for the various estimates\n        stat_title: main title\n        subtitle: subtitle\n        ncols: wrap after `ncols` columns\n        save: the name of a file to save to (HTML extension will be added)\n\n    Returns:\n        the `alt.Chart` object.\n    \"\"\"\n    n_stats = len(stat_names)\n    nvals = check_vector(parameter_values, \"plot_true_sim_facets\")\n    nv_true, n_stat_true = check_matrix(stat_true, \"plot_true_sim_facets\")\n    if nv_true != nvals:\n        bs_error_abort(\n            f\"plot_true_sim_facets: we have {nvals} parameter values and {nv_true} for\"\n            \" stat_true.\"\n        )\n    nv_est, n_stat_est = check_matrix(stat_sim, \"plot_true_sim_facets\")\n    if nv_est != nvals:\n        bs_error_abort(\n            f\"plot_true_sim_facets: we have {nvals} parameter values and {nv_est} for\"\n            \" stat_sim.\"\n        )\n    if n_stat_true != n_stats:\n        bs_error_abort(\n            f\"plot_true_sim_facets: we have {n_stats} names for {n_stat_true} true\"\n            \" statistics.\"\n        )\n    if n_stat_est != n_stats:\n        bs_error_abort(\n            f\"plot_true_sim_facets: we have {n_stats} names for {n_stat_est} estimated\"\n            \" statistics.\"\n        )\n    df = pd.DataFrame(\n        {\n            parameter_name: parameter_values,\n            \"True value\": stat_true[:, 0],\n            \"Estimated\": stat_sim[:, 0],\n            stat_title: stat_names[0],\n        }\n    )\n    for i_stat in range(1, n_stats):\n        df_i = pd.DataFrame(\n            {\n                parameter_name: parameter_values,\n                \"True value\": stat_true[:, i_stat],\n                \"Estimated\": stat_sim[:, i_stat],\n                stat_title: stat_names[i_stat],\n            }\n        )\n        df = pd.concat((df, df_i))\n    sub_order = [\"True value\", \"Estimated\"]\n    dfm = pd.melt(df, [parameter_name, stat_title], var_name=subtitle)\n    ch = (\n        alt.Chart(dfm)\n        .mark_line()\n        .encode(\n            x=f\"{parameter_name}:Q\",\n            y=\"value:Q\",\n            strokeDash=alt.StrokeDash(f\"{subtitle}:N\", sort=sub_order),\n            color=alt.Color(\n                f\"{subtitle}:N\",\n                sort=sub_order,\n                scale=alt.Scale(domain=sub_order, range=colors),\n            ),\n            facet=(\n                alt.Facet(f\"{stat_title}:N\", sort=stat_names, columns=ncols)\n                if ncols is not None\n                else alt.Facet(f\"{stat_title}:N\", sort=stat_names)\n            ),\n        )\n        .resolve_scale(y=\"independent\")\n    )\n\n    _maybe_save(ch, save)\n\n    return cast(alt.Chart, ch)\n</code></pre>"},{"location":"bs_logging.html","title":"bs_logging module","text":"<p>Utilities for logging:</p> <ul> <li><code>init_logger</code> initializes and returns a customized logger</li> <li><code>log_execution</code> ia a decorator to log entry into and ext from a function.</li> </ul>"},{"location":"bs_logging.html#bs_python_utils.bs_logging.init_logger","title":"<code>init_logger(logger_name, log_level_for_console='info', log_level_for_file='debug', save_dir=None)</code>","text":"<p>Initialize a logger</p> <p>Parameters:</p> Name Type Description Default <code>logger_name</code> <code>str</code> <p>name for the logger</p> required <code>log_level_for_console</code> <code>str</code> <p>minimum level of messages logged to the console logging</p> <code>'info'</code> <code>log_level_for_file</code> <code>str</code> <code>'debug'</code> <code>save_dir</code> <code>str | None</code> <code>None</code> <p>Returns:</p> Type Description <code>Logger</code> <p>the logger</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; logger_dir = \"logs\"\n&gt;&gt;&gt; logger_name = \"check_log\"\n&gt;&gt;&gt; logger = init_logger(logger_name, save_dir=logger_dir)\n</code></pre> <p>This will create two logs:</p> <ul> <li>one  printed to console where we run the code (the <code>StreamHandler</code>),</li> <li>and one that will be saved to file <code>save_dir/logger_name.txt</code> (the <code>FileHandler</code>).</li> </ul> <p><code>'logger.propagate = False'</code>  makes sure that the logs sent to file will not be printed to console.</p> <p>We use the <code>Formatter</code> class to define the format of the logs. Here:</p> <ul> <li>The time of the log in a human-readable format, <code>asctime</code></li> <li><code>levelname</code> is the level of the log, one out of <code>INFO, DEBUG, WARNING, ERROR, CRITICAL</code>.</li> <li>The name of the file, <code>filename</code>, from which the log was generated, and the line number, <code>lineno</code>.</li> <li>Lastly,  the message itself \u2014 <code>message</code>.</li> </ul> <p>The default has only <code>INFO</code> logs and above (i.e., also <code>WARNING, ERROR</code> and <code>CRITICAL</code>) displayed in the console; the file will also include <code>DEBUG</code> logs.</p> Source code in <code>bs_python_utils/bs_logging.py</code> <pre><code>def init_logger(\n    logger_name: str,\n    log_level_for_console: str = \"info\",\n    log_level_for_file: str = \"debug\",\n    save_dir: str | None = None,\n) -&gt; logging.Logger:\n    \"\"\"\n    Initialize a logger\n\n    Args:\n        logger_name: name for the logger\n        log_level_for_console: minimum level of messages logged to the console logging\n        log_level_for_file:\n        save_dir:\n\n    Returns:\n        the logger\n\n    Examples:\n        &gt;&gt;&gt; logger_dir = \"logs\"\n        &gt;&gt;&gt; logger_name = \"check_log\"\n        &gt;&gt;&gt; logger = init_logger(logger_name, save_dir=logger_dir)\n\n        This will create two logs:\n\n        * one  printed to console where we run the code (the `StreamHandler`),\n        * and one that will be saved to file `save_dir/logger_name.txt` (the `FileHandler`).\n\n        `'logger.propagate = False'`  makes sure that the logs sent to file will not be printed to console.\n\n        We use the `Formatter` class to define the format of the logs.\n        Here:\n\n        * The time of the log in a human-readable format, `asctime`\n        * `levelname` is the level of the log, one out of `INFO, DEBUG, WARNING, ERROR, CRITICAL`.\n        * The name of the file, `filename`, from which the log was generated,\n        and the line number, `lineno`.\n        * Lastly,  the message itself \u2014 `message`.\n\n        The default has only `INFO` logs and above (i.e., also `WARNING, ERROR` and `CRITICAL`)\n        displayed in the console; the file will also include `DEBUG` logs.\n    \"\"\"\n    logger = logging.getLogger()\n    logger.setLevel(level=logging.DEBUG)\n    logger.propagate = False\n\n    formatter = logging.Formatter(\n        \"%(asctime)s [%(levelname)s] %(filename)s %(lineno)d - %(message)s\",\n        \"%Y-%m-%d %H:%M:%S\",\n    )\n\n    ch = logging.StreamHandler()\n    ch.setLevel(log_level_for_console.upper())\n    ch.setFormatter(formatter)\n    logger.addHandler(ch)\n\n    if save_dir is not None:\n        Path(save_dir).mkdir(exist_ok=True, parents=True)\n        fh = logging.FileHandler(save_dir + f\"/{logger_name}.txt\")\n        fh.setLevel(log_level_for_file.upper())\n        fh.setFormatter(formatter)\n        logger.addHandler(fh)\n\n    return logger\n</code></pre>"},{"location":"bs_logging.html#bs_python_utils.bs_logging.log_execution","title":"<code>log_execution(func)</code>","text":"<p>Decorator to log the execution of a function. Only records entry to and exit from the function, to the console.</p> Source code in <code>bs_python_utils/bs_logging.py</code> <pre><code>def log_execution(func: Callable) -&gt; Callable:\n    \"\"\"Decorator to log the execution of a function.\n    Only records entry to and exit from the function, to the console.\n    \"\"\"\n    loglevel = logging.info\n\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        loglevel(f\"Executing {func.__name__}\")\n        result = func(*args, **kwargs)\n        loglevel(f\"Finished executing {func.__name__}\")\n        return result\n\n    return wrapper\n</code></pre>"},{"location":"bs_mathstr.html","title":"bs_mathstr module","text":"<p>Some useful strings for math formulae.</p> Note <p>if the math looks strange in the documentation, just reload the page.</p> <p>Attributes:</p> Name Type Description <code>*</code> <code>str_beta0</code> <p>the LaTeX string \\(\\beta_0\\)</p> <code>*</code> <code>str_beta1</code> <p>the LaTeX string \\(\\beta_1\\)</p> <code>*</code> <code>str_pi</code> <p>the LaTeX string \\(\\pi\\)</p> <code>*</code> <code>str_sigma</code> <p>the LaTeX string \\(\\sigma\\)</p> <code>*</code> <code>str_sigma2</code> <p>the LaTeX string \\(\\sigma^2\\)</p> <code>*</code> <code>uni_beta0</code> <p>the Unicode string \\(\\beta_0\\)</p> <code>*</code> <code>uni_beta1</code> <p>the Unicode string \\(\\beta_1\\)</p> <code>*</code> <code>uni_pi</code> <p>the Unicode string \\(\\pi\\)</p> <code>*</code> <code>uni_sigma</code> <p>the Unicode string \\(\\sigma\\)</p> <code>*</code> <code>uni_sigma2</code> <p>the Unicode string \\(\\sigma^2\\)</p> <code>*</code> <code>uni_s2</code> <p>the Unicode string \\(s^2\\)</p> <code>*</code> <code>uni_R2</code> <p>the Unicode string \\(R^2\\)</p> <code>*</code> <code>sub_sub_scripts</code> <p>a dictionary of unicodes for subscripts and superscripts; e.g \\(a^b\\) would be <code>\"a\" + sub_sup_scripts['b'][0]</code></p>"},{"location":"bs_mem.html","title":"bs_mem module","text":"<p>Reports on memory usage:</p> <ul> <li><code>mem_usage</code>: prints the top <code>n</code> largest global items in memory</li> <li><code>memory_display_top</code>: prints the top <code>n</code> largest memory allocations since tracing started</li> <li><code>memory_display_top_diffs</code>: prints the top <code>n</code> largest memory allocations since the last snapshot.</li> </ul>"},{"location":"bs_mem.html#bs_python_utils.bs_mem.memory_display_top","title":"<code>memory_display_top(snapshot, key_type='lineno', limit=5)</code>","text":"<p>prints out the lines with the top <code>limit</code> allocations of memory since <code>tracemalloc.start()</code></p> <p>Parameters:</p> Name Type Description Default <code>snapshot</code> <code>Snapshot</code> <p>obtained from tracemalloc.take_snapshot()</p> required <code>key_type</code> <code>str</code> <p>'lineno' gives file and line number; 'traceback' gives all</p> <code>'lineno'</code> <code>limit</code> <code>int | None</code> <p>how many top allocations we want</p> <code>5</code> <p>Returns:</p> Type Description <code>None</code> <p>just prints.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; tracemalloc.start()\n&gt;&gt;&gt; .... execute ...\n&gt;&gt;&gt; snapshot = tracemalloc.take_snapshot()\n&gt;&gt;&gt; memory_display_top(snapshot)\n</code></pre> Source code in <code>bs_python_utils/bs_mem.py</code> <pre><code>def memory_display_top(\n    snapshot: tracemalloc.Snapshot, key_type: str = \"lineno\", limit: int | None = 5\n) -&gt; None:\n    \"\"\"\n    prints out the lines with the top `limit` allocations of memory since `tracemalloc.start()`\n\n    Args:\n        snapshot: obtained from tracemalloc.take_snapshot()\n        key_type: 'lineno' gives file and line number; 'traceback' gives all\n        limit: how many top allocations we want\n\n    Returns:\n        just prints.\n\n    Examples:\n       &gt;&gt;&gt; tracemalloc.start()\n       &gt;&gt;&gt; .... execute ...\n       &gt;&gt;&gt; snapshot = tracemalloc.take_snapshot()\n       &gt;&gt;&gt; memory_display_top(snapshot)\n    \"\"\"\n\n    top_stats = snapshot.statistics(key_type)\n\n    print_stars(f\"Top {limit} memory allocations\")\n    for index, stat in enumerate(top_stats[:limit], 1):\n        frame = stat.traceback[0]\n        print(\n            \"#%s: %s:%s: %.1f KiB\"\n            % (index, frame.filename, frame.lineno, stat.size / 1024)\n        )\n        line = linecache.getline(frame.filename, frame.lineno).strip()\n        if line:\n            print(\"    %s\" % line)\n\n    other = top_stats[limit:]\n    if other:\n        size = sum(stat.size for stat in other)\n        print(f\"{len(other)} other: {size / 1024:.1f} KiB\")\n    total = sum(stat.size for stat in top_stats)\n    print(\"Total allocated size: %.1f KiB\" % (total / 1024))\n</code></pre>"},{"location":"bs_mem.html#bs_python_utils.bs_mem.memory_display_top_diffs","title":"<code>memory_display_top_diffs(snapshot1, snapshot2, key_type='lineno', limit=5)</code>","text":"<p>prints out the lines with the top <code>limit</code> allocations between the two snapshots</p> <p>Parameters:</p> Name Type Description Default <code>snapshot1</code> <code>Snapshot</code> <p>previous snapshot</p> required <code>snapshot2</code> <code>Snapshot</code> <p>new snapshot</p> required <code>key_type</code> <code>str</code> <p>'lineno' gives file and line number; 'traceback' gives all</p> <code>'lineno'</code> <code>limit</code> <code>int</code> <p>how many top allocations we want</p> <code>5</code> <p>Returns:</p> Type Description <code>None</code> <p>just prints.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; tracemalloc.start()\n&gt;&gt;&gt; .... execute ...\n&gt;&gt;&gt; snapshot1 = tracemalloc.take_snapshot()\n&gt;&gt;&gt; .... execute ...\n&gt;&gt;&gt; snapshot2 = tracemalloc.take_snapshot()\n&gt;&gt;&gt;  memory_display_top_diffs(snapshot1, snapshot2)\n</code></pre> Source code in <code>bs_python_utils/bs_mem.py</code> <pre><code>def memory_display_top_diffs(\n    snapshot1: tracemalloc.Snapshot,\n    snapshot2: tracemalloc.Snapshot,\n    key_type: str = \"lineno\",\n    limit: int = 5,\n) -&gt; None:\n    \"\"\"\n    prints out the lines with the top `limit` allocations between the two snapshots\n\n    Args:\n        snapshot1: previous snapshot\n        snapshot2: new snapshot\n        key_type: 'lineno' gives file and line number; 'traceback' gives all\n        limit: how many top allocations we want\n\n    Returns:\n        just prints.\n\n    Examples:\n       &gt;&gt;&gt; tracemalloc.start()\n       &gt;&gt;&gt; .... execute ...\n       &gt;&gt;&gt; snapshot1 = tracemalloc.take_snapshot()\n       &gt;&gt;&gt; .... execute ...\n       &gt;&gt;&gt; snapshot2 = tracemalloc.take_snapshot()\n       &gt;&gt;&gt;  memory_display_top_diffs(snapshot1, snapshot2)\n\n    \"\"\"\n\n    top_stats = snapshot2.compare_to(snapshot1, key_type)\n\n    print_stars(f\"Top {limit} new memory allocations\")\n    for index, stat in enumerate(top_stats[:limit], 1):\n        frame = stat.traceback[0]\n        print(\n            \"#%s: %s:%s: %.1f KiB\"\n            % (index, frame.filename, frame.lineno, stat.size / 1024)\n        )\n        line = linecache.getline(frame.filename, frame.lineno).strip()\n        if line:\n            print(\"    %s\" % line)\n\n    other = top_stats[limit:]\n    if other:\n        size = sum(stat.size for stat in other)\n        print(f\"{len(other)} other: {size / 1024:.1f} KiB\")\n    total = sum(stat.size for stat in top_stats)\n    print(\"Total allocated size: %.1f KiB\" % (total / 1024))\n</code></pre>"},{"location":"bs_mem.html#bs_python_utils.bs_mem.memory_usage","title":"<code>memory_usage(n=10)</code>","text":"<p>prints the top <code>n</code> largest global items in memory</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int | None</code> <p>we report the size of the largest <code>n</code> global items</p> <code>10</code> <p>Returns:</p> Type Description <code>None</code> <p>nothing.</p> Source code in <code>bs_python_utils/bs_mem.py</code> <pre><code>def memory_usage(n: int | None = 10) -&gt; None:\n    \"\"\"\n    prints the top `n` largest global items in memory\n\n    Args:\n        n: we report the size of the largest `n` global items\n\n    Returns:\n        nothing.\n    \"\"\"\n    memory_usage_by_variable = pd.DataFrame(\n        {k: sys.getsizeof(v) for (k, v) in globals().items()}, index=[\"Size\"]\n    )\n    memory_usage_by_variable = memory_usage_by_variable.T\n    total_usage = _obj_size_fmt(memory_usage_by_variable[\"Size\"].sum())\n    memory_usage_by_variable = memory_usage_by_variable.sort_values(\n        by=\"Size\", ascending=False\n    ).head(n)\n    memory_usage_by_variable[\"Size\"] = memory_usage_by_variable[\"Size\"].apply(\n        lambda x: _obj_size_fmt(x)\n    )\n    print_stars(\n        f\"Currently used memory = {total_usage}\\n\\t\\t\\t\\t Top {n} global objects:\"\n    )\n    print(memory_usage_by_variable)\n\n    return\n</code></pre>"},{"location":"bs_opt.html","title":"bs_opt module","text":"<p>Interface to <code>scipy.optimize</code>:</p> <ul> <li><code>ScalarFunctionAndGradient</code>, <code>ProximalFunction</code> type aliases</li> <li>an <code>OptimizeParams</code> class</li> <li><code>check_gradient_scalar_function</code> checks whether an analytical gradient is correct</li> <li><code>acc_grad_descent</code>: accelerated gradient descent for convex, possibly non-smooth functions</li> <li><code>minimize_some_fixed</code>: minimizes a function with some parameter values possibly fixed and some possibly within bounds, using L-BFGS-B</li> <li><code>minimize_free</code>: minimizes a function with some parameter values possibly within bounds</li> <li><code>dfp_update, bfgs_update</code>: compute updates to the inverese Hessian</li> <li><code>armijo_alpha, barzilai_borwein_alpha</code>: two ways of computing the step length</li> <li><code>print_optimization_results</code>, <code>print_constrained_optimization_results</code> format the results.</li> </ul>"},{"location":"bs_opt.html#bs_python_utils.bs_opt.ProximalFunction","title":"<code>ProximalFunction = Callable[[np.ndarray, float, Iterable], np.ndarray]</code>  <code>module-attribute</code>","text":"<p>Type of <code>h(x, t, pars)</code> that returns a scalar value.</p>"},{"location":"bs_opt.html#bs_python_utils.bs_opt.ScalarFunctionAndGradient","title":"<code>ScalarFunctionAndGradient = Callable[[np.ndarray, Iterable, Optional[bool]], Union[float, tuple[float, np.ndarray]]]</code>  <code>module-attribute</code>","text":"<p>Type of <code>f(v, args, gr)</code> that returns a scalar value and also a gradient if <code>gr</code> is <code>True</code>.</p>"},{"location":"bs_opt.html#bs_python_utils.bs_opt.OptimizeParams","title":"<code>OptimizeParams</code>  <code>dataclass</code>","text":"<p>used for optimization; combines values, bounds and initial values for a parameter vector</p> Source code in <code>bs_python_utils/bs_opt.py</code> <pre><code>@dataclass\nclass OptimizeParams:\n    \"\"\"used for optimization; combines values, bounds and initial values for a parameter vector\n    \"\"\"\n\n    params_values: np.ndarray | None\n    params_bounds: list[tuple] | None\n    params_init: np.ndarray | None\n</code></pre>"},{"location":"bs_opt.html#bs_python_utils.bs_opt.acc_grad_descent","title":"<code>acc_grad_descent(grad_f, x_init, other_params, prox_h=None, print_result=False, verbose=False, tol=1e-09, alpha=1.01, beta=0.5, maxiter=10000)</code>","text":"<p>Minimizes <code>(f+h)</code> by Accelerated Gradient Descent where <code>f</code> is smooth and convex  and <code>h</code> is convex.</p> <p>By default <code>h</code> is zero. The convergence criterion is that the largest component of the absolute value of the gradient must be smaller than <code>tol</code>.</p> <p>Parameters:</p> Name Type Description Default <code>grad_f</code> <code>Callable</code> <p>grad_f of <code>f</code>; should return an <code>(n)</code> array from an <code>(n)</code> array and the <code>other_ params</code> object</p> required <code>x_init</code> <code>ndarray</code> <p>initial guess, shape <code>(n)</code></p> required <code>prox_h</code> <code>ProximalFunction | None</code> <p>proximal projector of <code>h</code>, if any</p> <code>None</code> <code>other_params</code> <code>Iterable</code> <p>an iterable with additional parameters</p> required <code>verbose</code> <code>bool</code> <p>if <code>True</code>, print remaining gradient error every 10 iterations</p> <code>False</code> <code>tol</code> <code>float</code> <p>convergence criterion on grad_f</p> <code>1e-09</code> <code>alpha</code> <code>float</code> <p>ceiling on step multiplier</p> <code>1.01</code> <code>beta</code> <code>float</code> <p>floor on step multiplier</p> <code>0.5</code> <code>maxiter</code> <code>int</code> <p>max number of iterations</p> <code>10000</code> <p>Returns:</p> Type Description <code>tuple[ndarray, int]</code> <p>the candidate solution, and a convergence code (0 if successful, 1 if not).</p> Source code in <code>bs_python_utils/bs_opt.py</code> <pre><code>@timeit\ndef acc_grad_descent(\n    grad_f: Callable,\n    x_init: np.ndarray,\n    other_params: Iterable,\n    prox_h: ProximalFunction | None = None,\n    print_result: bool = False,\n    verbose: bool = False,\n    tol: float = 1e-9,\n    alpha: float = 1.01,\n    beta: float = 0.5,\n    maxiter: int = 10000,\n) -&gt; tuple[np.ndarray, int]:\n    \"\"\"\n    Minimizes `(f+h)` by Accelerated Gradient Descent where `f` is smooth and convex  and `h` is convex.\n\n    By default `h` is zero.\n    The convergence criterion is that the largest component of the absolute value of the gradient must be smaller than `tol`.\n\n\n    Args:\n        grad_f: grad_f of `f`; should return an `(n)` array from an `(n)` array and the `other_ params` object\n        x_init: initial guess, shape `(n)`\n        prox_h: proximal projector of `h`, if any\n        other_params: an iterable with additional parameters\n        verbose: if `True`, print remaining gradient error every 10 iterations\n        tol: convergence criterion on grad_f\n        alpha: ceiling on step multiplier\n        beta: floor on step multiplier\n        maxiter: max number of iterations\n\n    Returns:\n        the candidate solution, and a convergence code (0 if successful, 1 if not).\n    \"\"\"\n\n    # no proximal projection if no h\n    local_prox_h: ProximalFunction = prox_h if prox_h else lambda x, t, p: x\n\n    x = x_init.copy()\n    y = x_init.copy()\n\n    #  for stepsize we use Barzilai-Borwein\n    t, g = barzilai_borwein_alpha(grad_f, y, other_params)\n\n    grad_err_init = npmaxabs(g)\n\n    if verbose:\n        print(f\"agd: grad_err_init={grad_err_init}\")\n\n    n_iter = 0\n    theta = 1.0\n\n    while n_iter &lt; maxiter:\n        grad_err = npmaxabs(g)\n        if grad_err &lt; tol:\n            break\n        xi = x\n        yi = y\n        x = y - t * g\n        x = local_prox_h(x, t, other_params)\n\n        theta = 2.0 / (1.0 + sqrt(1.0 + 4.0 / theta / theta))\n\n        if np.dot(y - x, x - xi) &gt; 0:  # wrong direction, we restart\n            x = xi\n            y = x\n            theta = 1.0\n        else:\n            y = x + (1.0 - theta) * (x - xi)\n\n        gi = g\n        g = grad_f(y, other_params)\n        ndy = spla.norm(y - yi)\n        t_hat = 0.5 * ndy * ndy / abs(np.dot(y - yi, gi - g))\n        t = min(alpha * t, max(beta * t, t_hat))\n\n        n_iter += 1\n\n        if verbose and n_iter % 10 == 0:\n            print(f\" AGD with grad_err = {grad_err} after {n_iter} iterations\")\n\n    x_conv = y\n\n    ret_code = 0 if grad_err &lt; tol else 1\n\n    if verbose or print_result:\n        if ret_code == 0:\n            print_stars(\n                f\" AGD converged with grad_err = {grad_err} after {n_iter} iterations\"\n            )\n        else:\n            print_stars(\n                f\" Problem in AGD: grad_err = {grad_err} after {n_iter} iterations\"\n            )\n\n    return x_conv, ret_code\n</code></pre>"},{"location":"bs_opt.html#bs_python_utils.bs_opt.armijo_alpha","title":"<code>armijo_alpha(f, x, d, args, alpha_init=1.0, beta=0.5, max_iter=100, tol=0.0)</code>","text":"<p>Given a function <code>f</code> we are minimizing, computes the step size <code>alpha</code> to take in the direction <code>d</code> using the Armijo rule.</p> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>Callable</code> <p>the function</p> required <code>x</code> <code>ndarray</code> <p>the current point</p> required <code>d</code> <code>ndarray</code> <p>the direction we are taking</p> required <code>args</code> <code>Iterable</code> <p>other arguments passed to <code>f</code></p> required <code>alpha_init</code> <code>float</code> <p>the initial step size</p> <code>1.0</code> <code>beta</code> <code>float</code> <p>the step size reduction factor</p> <code>0.5</code> <code>max_iter</code> <code>int</code> <p>the maximum number of iterations</p> <code>100</code> <code>tol</code> <code>float</code> <p>a tolerance</p> <code>0.0</code> <p>Returns:</p> Type Description <code>float</code> <p>the step size <code>alpha</code>.</p> Source code in <code>bs_python_utils/bs_opt.py</code> <pre><code>def armijo_alpha(\n    f: Callable,\n    x: np.ndarray,\n    d: np.ndarray,\n    args: Iterable,\n    alpha_init: float = 1.0,\n    beta: float = 0.5,\n    max_iter: int = 100,\n    tol: float = 0.0,\n) -&gt; float:\n    \"\"\"Given a function `f` we are minimizing, computes the step size `alpha`\n    to take in the direction `d` using the Armijo rule.\n\n    Args:\n        f: the function\n        x: the current point\n        d: the direction we are taking\n        args: other arguments passed to `f`\n        alpha_init: the initial step size\n        beta: the step size reduction factor\n        max_iter: the maximum number of iterations\n        tol: a tolerance\n\n    Returns:\n        the step size `alpha`.\n    \"\"\"\n    f0 = f(x, args)\n    alpha = alpha_init\n    for _ in range(max_iter):\n        x1 = x + alpha * d\n        f1 = f(x1, args)\n        if f1 &lt; f0 + tol:\n            return alpha\n        alpha *= beta\n    else:\n        bs_error_abort(\"Too many iterations\")\n    return alpha\n</code></pre>"},{"location":"bs_opt.html#bs_python_utils.bs_opt.barzilai_borwein_alpha","title":"<code>barzilai_borwein_alpha(grad_f, x, args)</code>","text":"<p>Given a function <code>f</code> we are minimizing, computes the step size <code>alpha</code> to take in the opposite direction of the gradient using the Barzilai-Borwein rule.</p> <p>Parameters:</p> Name Type Description Default <code>grad_f</code> <code>Callable</code> <p>the gradient of the function</p> required <code>x</code> <code>ndarray</code> <p>the current point</p> required <code>args</code> <code>Iterable</code> <p>other arguments passed to <code>f</code></p> required <p>Returns:</p> Type Description <code>tuple[float, ndarray]</code> <p>the step size <code>alpha</code> and the gradient <code>g</code> at the point <code>x</code>.</p> Source code in <code>bs_python_utils/bs_opt.py</code> <pre><code>def barzilai_borwein_alpha(\n    grad_f: Callable, x: np.ndarray, args: Iterable\n) -&gt; tuple[float, np.ndarray]:\n    \"\"\"Given a function `f` we are minimizing, computes the step size `alpha`\n    to take in the opposite direction of the gradient using the Barzilai-Borwein rule.\n\n    Args:\n        grad_f: the gradient of the function\n        x: the current point\n        args: other arguments passed to `f`\n\n    Returns:\n        the step size `alpha` and the gradient `g` at the point `x`.\n    \"\"\"\n    g = grad_f(x, args)\n    alpha = 1.0 / spla.norm(g)\n    x_hat = x - alpha * g\n    g_hat = grad_f(x_hat, args)\n    norm_dg = spla.norm(g - g_hat)\n    norm_dg2 = norm_dg * norm_dg\n    alpha = np.abs(np.dot(x - x_hat, g - g_hat)) / norm_dg2\n    return alpha, g\n</code></pre>"},{"location":"bs_opt.html#bs_python_utils.bs_opt.bfgs_update","title":"<code>bfgs_update(hess_inv, gradient_diff, x_diff)</code>","text":"<p>Runs a BFGS update for the inverse Hessian.</p> <p>Parameters:</p> Name Type Description Default <code>hess_inv</code> <code>ndarray</code> <p>the current inverse Hessian</p> required <code>gradient_diff</code> <code>ndarray</code> <p>the update in the gradient</p> required <code>x_diff</code> <code>ndarray</code> <p>the update in x</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>the updated inverse Hessian.</p> Source code in <code>bs_python_utils/bs_opt.py</code> <pre><code>def bfgs_update(\n    hess_inv: np.ndarray, gradient_diff: np.ndarray, x_diff: np.ndarray\n) -&gt; np.ndarray:\n    \"\"\"Runs a BFGS update for the inverse Hessian.\n\n    Args:\n        hess_inv: the current inverse Hessian\n        gradient_diff: the update in the gradient\n        x_diff: the update in x\n\n    Returns:\n        the updated inverse Hessian.\n    \"\"\"\n    xdt = x_diff.T\n    xpg = xdt @ gradient_diff\n    hdg = hess_inv @ gradient_diff\n    dgp_hdg = gradient_diff.T @ hdg\n    u = x_diff / xpg - hdg / dgp_hdg\n    hess_inv_new = dfp_update(hess_inv, gradient_diff, x_diff) + dgp_hdg * (u @ u.T)\n    return cast(np.ndarray, hess_inv_new)\n</code></pre>"},{"location":"bs_opt.html#bs_python_utils.bs_opt.check_gradient_scalar_function","title":"<code>check_gradient_scalar_function(fg, p, args, mode='central', EPS=1e-06)</code>","text":"<p>Checks the gradient of a scalar function.</p> <p>Parameters:</p> Name Type Description Default <code>fg</code> <code>ScalarFunctionAndGradient</code> <p>should return the scalar value, and the gradient if its <code>gr</code> argument is <code>True</code></p> required <code>p</code> <code>ndarray</code> <p>where we are checking the gradient</p> required <code>args</code> <code>Iterable</code> <p>other arguments passed to <code>fg</code></p> required <code>mode</code> <code>str</code> <p>\"central\" or \"forward\" derivatives</p> <code>'central'</code> <code>EPS</code> <code>float</code> <p>the step for forward or central derivatives</p> <code>1e-06</code> <p>Returns:</p> Type Description <code>TwoArrays</code> <p>the analytic and numeric gradients.</p> Source code in <code>bs_python_utils/bs_opt.py</code> <pre><code>def check_gradient_scalar_function(\n    fg: ScalarFunctionAndGradient,\n    p: np.ndarray,\n    args: Iterable,\n    mode: str = \"central\",\n    EPS: float = 1e-6,\n) -&gt; TwoArrays:\n    \"\"\"Checks the gradient of a scalar function.\n\n    Args:\n        fg: should return the scalar value, and the gradient if its `gr` argument is `True`\n        p: where we are checking the gradient\n        args: other arguments passed to `fg`\n        mode: \"central\" or \"forward\" derivatives\n        EPS: the step for forward or central derivatives\n\n    Returns:\n        the analytic and numeric gradients.\n    \"\"\"\n    f0, f_grad = fg(p, args, gr=True)  # type: ignore\n    f0 = cast(float, f0)\n\n    print_stars(\"checking the gradient: analytic, numeric\")\n\n    g = np.zeros_like(p)\n    if mode == \"central\":\n        for i, x in enumerate(p):\n            p1 = p.copy()\n            p1[i] = x + EPS\n            f_plus = cast(float, fg(p1, args, gr=False))  # type: ignore\n            p1[i] -= 2.0 * EPS\n            f_minus = cast(float, fg(p1, args, gr=False))  # type: ignore\n            g[i] = (f_plus - f_minus) / (2.0 * EPS)\n            print(f\"{i}: {f_grad[i]}, {g[i]}\")\n    elif mode == \"forward\":\n        for i, x in enumerate(p):\n            p1 = p.copy()\n            p1[i] = x + EPS\n            f_plus = cast(float, fg(p1, args, gr=False))  # type: ignore\n            g[i] = (f_plus - f0) / EPS\n            print(f\"{i}: {f_grad[i]}, {g[i]}\")\n    else:\n        bs_error_abort(\"mode must be 'central' or 'forward'\")\n\n    return f_grad, g\n</code></pre>"},{"location":"bs_opt.html#bs_python_utils.bs_opt.dfp_update","title":"<code>dfp_update(hess_inv, gradient_diff, x_diff)</code>","text":"<p>Runs a DFP update for the inverse Hessian.</p> <p>Parameters:</p> Name Type Description Default <code>hess_inv</code> <code>ndarray</code> <p>the current inverse Hessian</p> required <code>gradient_diff</code> <code>ndarray</code> <p>the update in the gradient</p> required <code>x_diff</code> <code>ndarray</code> <p>the update in x</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>the updated inverse Hessian.</p> Source code in <code>bs_python_utils/bs_opt.py</code> <pre><code>def dfp_update(\n    hess_inv: np.ndarray, gradient_diff: np.ndarray, x_diff: np.ndarray\n) -&gt; np.ndarray:\n    \"\"\"Runs a DFP update for the inverse Hessian.\n\n    Args:\n        hess_inv: the current inverse Hessian\n        gradient_diff: the update in the gradient\n        x_diff: the update in x\n\n    Returns:\n        the updated inverse Hessian.\n    \"\"\"\n    xdt = x_diff.T\n    xxp = x_diff @ xdt\n    xpg = xdt @ gradient_diff\n    hdg = hess_inv @ gradient_diff\n    dgp_hdg = gradient_diff.T @ hdg\n    hess_inv_new = hess_inv + xxp / xpg - (hdg @ hdg.T) / dgp_hdg\n    return cast(np.ndarray, hess_inv_new)\n</code></pre>"},{"location":"bs_opt.html#bs_python_utils.bs_opt.minimize_free","title":"<code>minimize_free(obj, grad_obj, x_init, args, options=None, bounds=None)</code>","text":"<p>Minimize a function on all of its variables, using BFGS or L-BFGS-B.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>Callable</code> <p>the original function</p> required <code>grad_obj</code> <code>Callable</code> <p>its gradient function</p> required <code>x_init</code> <code>ndarray</code> <p>the initial values of all variables</p> required <code>args</code> <code>Iterable</code> <p>other parameters</p> required <code>options</code> <code>dict | None</code> <p>any options passed on to <code>scipy.optimize.minimize</code></p> <code>None</code> <code>bounds</code> <code>list[tuple[float, float]] | None</code> <p>the bounds on all variables, if any</p> <code>None</code> <p>Returns:</p> Type Description <code>Any</code> <p>the result of optimization, on all variables.</p> Source code in <code>bs_python_utils/bs_opt.py</code> <pre><code>def minimize_free(\n    obj: Callable,\n    grad_obj: Callable,\n    x_init: np.ndarray,\n    args: Iterable,\n    options: dict | None = None,\n    bounds: list[tuple[float, float]] | None = None,\n) -&gt; Any:\n    \"\"\"\n    Minimize a function on all of its variables, using BFGS or L-BFGS-B.\n\n    Args:\n        obj: the original function\n        grad_obj: its gradient function\n        x_init: the initial values of all variables\n        args: other parameters\n        options: any options passed on to `scipy.optimize.minimize`\n        bounds: the bounds on all variables, if any\n\n    Returns:\n        the result of optimization, on all variables.\n    \"\"\"\n    if bounds is None:\n        resopt = spopt.minimize(\n            obj,\n            x_init,\n            method=\"BFGS\",\n            args=args,\n            options=options,\n            jac=grad_obj,\n        )\n    else:\n        resopt = spopt.minimize(\n            obj,\n            x_init,\n            method=\"L-BFGS-B\",\n            args=args,\n            options=options,\n            jac=grad_obj,\n            bounds=bounds,\n        )\n\n    return resopt\n</code></pre>"},{"location":"bs_opt.html#bs_python_utils.bs_opt.minimize_some_fixed","title":"<code>minimize_some_fixed(obj, grad_obj, x_init, args, fixed_vars, fixed_vals, options=None, bounds=None, time_execution=False)</code>","text":"<p>Minimize a function with some variables fixed, using L-BFGS-B.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>Callable</code> <p>the original function</p> required <code>grad_obj</code> <code>Callable</code> <p>its gradient function</p> required <code>fixed_vars</code> <code>list[int] | None</code> <p>a list if the indices of variables whose values are fixed</p> required <code>fixed_vals</code> <code>ndarray | None</code> <p>their fixed values</p> required <code>x_init</code> <code>ndarray</code> <p>the initial values of all variables (those on fixed variables are not used)</p> required <code>args</code> <code>Iterable</code> <p>other parameters</p> required <code>options</code> <code>dict | None</code> <p>any options passed on to <code>scipy.optimize.minimize</code></p> <code>None</code> <code>bounds</code> <code>list[tuple[float, float]] | None</code> <p>the bounds on all variables (those on fixed variables are not used)</p> <code>None</code> <code>time_execution</code> <code>bool</code> <p>if <code>True</code>, time the execution and print the result</p> <code>False</code> <p>Returns:</p> Type Description <code>Any</code> <p>the result of optimization, on all variables.</p> Source code in <code>bs_python_utils/bs_opt.py</code> <pre><code>def minimize_some_fixed(\n    obj: Callable,\n    grad_obj: Callable,\n    x_init: np.ndarray,\n    args: Iterable,\n    fixed_vars: list[int] | None,\n    fixed_vals: np.ndarray | None,\n    options: dict | None = None,\n    bounds: list[tuple[float, float]] | None = None,\n    time_execution: bool = False,\n) -&gt; Any:\n    \"\"\"\n    Minimize a function with some variables fixed, using L-BFGS-B.\n\n    Args:\n        obj: the original function\n        grad_obj: its gradient function\n        fixed_vars: a list if the indices of variables whose values are fixed\n        fixed_vals: their fixed values\n        x_init: the initial values of all variables (those on fixed variables are not used)\n        args: other parameters\n        options: any options passed on to `scipy.optimize.minimize`\n        bounds: the bounds on all variables (those on fixed variables are not used)\n        time_execution: if `True`, time the execution and print the result\n\n    Returns:\n        the result of optimization, on all variables.\n    \"\"\"\n    if time_execution:\n        time_start = perf_counter()\n    if fixed_vars is None:\n        resopt = spopt.minimize(\n            obj,\n            x_init,\n            method=\"L-BFGS-B\",\n            args=args,\n            options=options,\n            jac=grad_obj,\n            bounds=bounds,\n        )\n    else:\n        fixed_vars = cast(list, fixed_vars)\n        n_fixed = check_vector(fixed_vals)\n        fixed_vals = cast(np.ndarray, fixed_vals)\n        if len(fixed_vars) != n_fixed:\n            bs_error_abort(\n                f\"fixed_vars has {len(fixed_vars)} indices but fixed_vals has\"\n                f\" {fixed_vals.size} elements.\"\n            )\n        fixed_obj, fixed_grad_obj = _fix_some(obj, grad_obj, fixed_vars, fixed_vals)\n\n        # drop fixed variables and the corresponding bounds\n        n = len(x_init)\n        not_fixed = np.ones(n, dtype=bool)\n        not_fixed[fixed_vars] = False\n        t_init = x_init[not_fixed]\n        t_bounds = (\n            None if bounds is None else [bounds[i] for i in range(n) if not_fixed[i]]\n        )\n\n        resopt = spopt.minimize(\n            fixed_obj,\n            t_init,\n            method=\"L-BFGS-B\",\n            args=args,\n            options=options,\n            jac=fixed_grad_obj,\n            bounds=t_bounds,\n        )\n\n        # now re-fill the values of the variables\n        t = resopt.x\n        t_full = list(t)\n        for i, i_coef in enumerate(fixed_vars):\n            t_full.insert(i_coef, fixed_vals[i])\n        resopt.x = t_full\n\n        # and re-fill the values of the gradients\n        g = grad_obj(np.array(t_full), args)\n        resopt.jac = g\n\n        if time_execution:\n            time_end = perf_counter()\n            print(\n                \"\\nTime elapsed in minimization:\"\n                f\" {time_end - time_start: &gt;.3f} seconds.\\n\"\n            )\n\n    return resopt\n</code></pre>"},{"location":"bs_opt.html#bs_python_utils.bs_opt.print_constrained_optimization_results","title":"<code>print_constrained_optimization_results(resus, title='Minimizing', print_constr=False, print_multipliers=False)</code>","text":"<p>print results from constrained optimization.</p> <p>Parameters:</p> Name Type Description Default <code>resus</code> <code>OptimizeResult</code> <p>results from optimization</p> required <code>title</code> <code>str</code> <p>a title</p> <code>'Minimizing'</code> <code>print_constr</code> <code>bool</code> <p>if <code>True</code>, print the values of the constraints</p> <code>False</code> <code>print_multipliers</code> <code>bool</code> <p>if <code>True</code>, print the values of the multipliers</p> <code>False</code> <p>Returns:</p> Type Description <code>None</code> <p>just prints.</p> Source code in <code>bs_python_utils/bs_opt.py</code> <pre><code>def print_constrained_optimization_results(\n    resus: spopt.OptimizeResult,\n    title: str = \"Minimizing\",\n    print_constr: bool = False,\n    print_multipliers: bool = False,\n) -&gt; None:\n    \"\"\"print results from constrained optimization.\n\n    Args:\n        resus: results from optimization\n        title: a title\n        print_constr: if `True`, print the values of the constraints\n        print_multipliers: if `True`, print the values of the multipliers\n\n    Returns:\n        just prints.\n    \"\"\"\n    print_stars(title)\n    print(resus.message)\n    if resus.success:\n        print(f\"Successful! in {resus.nit} iterations\")\n        print(f\" evaluated {resus.nfev} functions and {resus.njev} gradients\")\n        print(f\"Minimized value is {resus.fun}\")\n        print(f\"The Lagrangian norm is {resus.optimality}\")\n        print(f\"The largest constraint violation is {resus.constr_violation}\")\n        if print_multipliers:\n            print(f\"The multipliers are {resus.v}\")\n        if print_constr:\n            print(f\"The values of the constraints are {resus.constr}\")\n    else:\n        print_stars(\"Constrained minimization failed!\")\n    return\n</code></pre>"},{"location":"bs_opt.html#bs_python_utils.bs_opt.print_optimization_results","title":"<code>print_optimization_results(resus, title='Minimizing')</code>","text":"<p>print results from unconstrained optimization.</p> <p>Parameters:</p> Name Type Description Default <code>resus</code> <code>OptimizeResult</code> <p>results from optimization</p> required <code>title</code> <code>str</code> <p>a title</p> <code>'Minimizing'</code> <p>Returns:</p> Type Description <code>None</code> <p>just prints.</p> Source code in <code>bs_python_utils/bs_opt.py</code> <pre><code>def print_optimization_results(\n    resus: spopt.OptimizeResult, title: str = \"Minimizing\"\n) -&gt; None:\n    \"\"\"print results from unconstrained optimization.\n\n    Args:\n        resus: results from optimization\n        title: a title\n\n    Returns:\n        just prints.\n    \"\"\"\n    print_stars(title)\n    print(resus.message)\n    if resus.success:\n        print(f\"Successful! in {resus.nit} iterations\")\n        print(f\" evaluated {resus.nfev} functions functions and {resus.njev} gradients\")\n        print(\"\\nMinimizer and grad_f:\")\n        print(np.column_stack((resus.x, resus.jac)))\n        print(f\"Minimized value is {resus.fun}\")\n    else:\n        print_stars(\"Minimization failed!\")\n    return\n</code></pre>"},{"location":"bs_plots.html","title":"bs_plots module","text":"<p>General plotting utilities.</p>"},{"location":"bs_plots.html#bs_python_utils.bs_plots.set_axis","title":"<code>set_axis(x, margin=0.05)</code>","text":"<p>sets the axis limits  with a margin</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ndarray</code> <p>the values of the variable</p> required <code>margin</code> <code>float</code> <p>the margin to add, a fraction of the range of the variable</p> <code>0.05</code> <p>Returns:</p> Type Description <code>tuple[float, float]</code> <p>the min and max for the axis.</p> Source code in <code>bs_python_utils/bs_plots.py</code> <pre><code>def set_axis(x: np.ndarray, margin: float = 0.05) -&gt; tuple[float, float]:\n    \"\"\"sets the axis limits  with a margin\n\n    Args:\n        x: the values of the variable\n        margin: the margin to add, a fraction of the range of the variable\n\n    Returns:\n        the min and max for the axis.\n    \"\"\"\n    x_min, x_max = x.min(), x.max()\n    scaled_diff = margin * (x_max - x_min)\n    x_min -= scaled_diff\n    x_max += scaled_diff\n    return x_min, x_max\n</code></pre>"},{"location":"bs_seaborn.html","title":"bs_seaborn module","text":"<p>Some Seaborn plotting utilities:</p> <ul> <li><code>bs_sns_get_legend</code>: get the <code>Legend</code> object of a Seaborn plot</li> <li><code>bs_sns_bar_x_byf</code>: make a bar plot of <code>x</code> by <code>f</code></li> <li><code>bs_sns_bar_x_byfg</code>: make a bar plot of <code>x</code> by <code>f</code> and <code>g</code></li> <li><code>bs_sns_plot_density</code>: basic density plot</li> <li><code>bs_sns_density_estimates</code>: plots the densities of estimates of several coefficients with several methods, superposed by methods and faceted by coefficients.</li> </ul>"},{"location":"bs_seaborn.html#bs_python_utils.bs_seaborn.bs_regplot","title":"<code>bs_regplot(data, x, y, title=None, line_color='red', save=None)</code>","text":"<p>Draw a seaborn regplot with title and legend.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>DataFrame</code> <p>dataframe, should contain columns <code>x</code> and <code>y</code></p> required <code>x</code> <code>str</code> <p>column name of x</p> required <code>y</code> <code>str</code> <p>column name of y</p> required <code>title</code> <code>str | None</code> <p>title of plot</p> <code>None</code> <code>line_color</code> <code>str</code> <p>color of the regression line. Red by default</p> <code>'red'</code> <code>save</code> <code>str | None</code> <p>where to save it, if requested</p> <code>None</code> <p>Returns:</p> Type Description <code>Axes</code> <p>the plot</p> Source code in <code>bs_python_utils/bs_seaborn.py</code> <pre><code>def bs_regplot(\n    data: pd.DataFrame,\n    x: str,\n    y: str,\n    title: str | None = None,\n    line_color: str = \"red\",\n    save: str | None = None,\n) -&gt; Axes:\n    \"\"\"Draw a seaborn regplot with title and legend.\n\n    Args:\n        data: dataframe, should contain columns `x` and `y`\n        x: column name of x\n        y: column name of y\n        title: title of plot\n        line_color: color of the regression line. Red by default\n        save: where to save it, if requested\n\n    Returns:\n        the plot\n    \"\"\"\n    sns.set_style(\"whitegrid\")\n    g = sns.regplot(\n        data=data,\n        x=x,\n        y=y,\n        label=\"Data\",\n        line_kws={\"label\": \"Linear Fit (95% CI)\", \"color\": line_color},\n    )\n    if title:\n        plt.title(title)\n    plt.legend(loc=\"best\")\n    if save:\n        plt.savefig(f\"{save}.png\", dpi=400)\n    return cast(Axes, g)\n</code></pre>"},{"location":"bs_seaborn.html#bs_python_utils.bs_seaborn.bs_sns_bar_x_byf","title":"<code>bs_sns_bar_x_byf(df, xstr, fstr, statistic=np.mean, label_x=None, label_f=None, title=None)</code>","text":"<p>Make a bar plot of <code>x</code> by <code>f</code>.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>dataframe, should contain columns <code>xstr</code> and <code>fstr</code></p> required <code>xstr</code> <code>str</code> <p>column name of x</p> required <code>fstr</code> <code>str</code> <p>column name of f</p> required <code>statistic</code> <code>Callable</code> <p>statistic to plot (by default, the mean)</p> <code>mean</code> <code>label_x</code> <code>str | None</code> <p>label of x</p> <code>None</code> <code>label_f</code> <code>str | None</code> <p>label of f</p> <code>None</code> <code>title</code> <code>str | None</code> <p>title of plot</p> <code>None</code> <p>Returns:</p> Type Description <code>Axes</code> <p>the plot.</p> Source code in <code>bs_python_utils/bs_seaborn.py</code> <pre><code>def bs_sns_bar_x_byf(\n    df: pd.DataFrame,\n    xstr: str,\n    fstr: str,\n    statistic: Callable = np.mean,\n    label_x: str | None = None,\n    label_f: str | None = None,\n    title: str | None = None,\n) -&gt; Axes:\n    \"\"\"Make a bar plot of `x` by `f`.\n\n    Args:\n        df: dataframe, should contain columns `xstr` and `fstr`\n        xstr: column name of x\n        fstr: column name of f\n        statistic: statistic to plot (by default, the mean)\n        label_x: label of x\n        label_f: label of f\n        title: title of plot\n\n    Returns:\n        the plot.\n    \"\"\"\n    fig, ax = plt.subplots()\n    gbar = sns.barplot(\n        x=fstr,\n        y=xstr,\n        data=df,\n        estimator=statistic,\n        errcolor=\"r\",\n        errwidth=0.75,\n        capsize=0.2,\n        ax=ax,\n    )\n    xlab = fstr if label_f is None else label_f\n    ylab = xstr if label_x is None else label_x\n    ax.set_xlabel(xlab)\n    ax.set_ylabel(ylab)\n    if title is not None:\n        ax.set_title(title)\n    return cast(Axes, gbar)\n</code></pre>"},{"location":"bs_seaborn.html#bs_python_utils.bs_seaborn.bs_sns_bar_x_byfg","title":"<code>bs_sns_bar_x_byfg(df, xstr, fstr, gstr, statistic=np.mean, label_x=None, label_f=None, label_g=None, title=None)</code>","text":"<p>Make a bar plot of x by f and g</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>dataframe, should contain columns  <code>xstr</code>, <code>fstr</code>,  and <code>gstr</code></p> required <code>xstr</code> <code>str</code> <p>column name of x</p> required <code>fstr</code> <code>str</code> <p>column name of f</p> required <code>gstr</code> <code>str</code> <p>column name of g</p> required <code>statistic</code> <code>Callable</code> <p>statistic to plot (by default, the mean)</p> <code>mean</code> <code>label_x</code> <code>str | None</code> <p>label of x</p> <code>None</code> <code>label_f</code> <code>str | None</code> <p>label of f</p> <code>None</code> <code>label_g</code> <code>str | None</code> <p>label of g in legend</p> <code>None</code> <code>title</code> <code>str | None</code> <p>title of plot</p> <code>None</code> <p>Returns:</p> Type Description <code>Axes</code> <p>the plot.</p> Source code in <code>bs_python_utils/bs_seaborn.py</code> <pre><code>def bs_sns_bar_x_byfg(\n    df: pd.DataFrame,\n    xstr: str,\n    fstr: str,\n    gstr: str,\n    statistic: Callable = np.mean,\n    label_x: str | None = None,\n    label_f: str | None = None,\n    label_g: str | None = None,\n    title: str | None = None,\n) -&gt; Axes:\n    \"\"\"Make a bar plot of x by f and g\n\n    Args:\n        df: dataframe, should contain columns  `xstr`, `fstr`,  and `gstr`\n        xstr: column name of x\n        fstr: column name of f\n        gstr: column name of g\n        statistic: statistic to plot (by default, the mean)\n        label_x: label of x\n        label_f: label of f\n        label_g: label of g in legend\n        title: title of plot\n\n    Returns:\n        the plot.\n    \"\"\"\n    _, ax = plt.subplots()\n    gbar = sns.barplot(\n        x=fstr,\n        y=xstr,\n        data=df,\n        hue=gstr,\n        estimator=statistic,\n        errcolor=\"r\",\n        errwidth=0.75,\n        capsize=0.2,\n        ax=ax,\n    )\n    xlab = fstr if label_f is None else label_f\n    ylab = xstr if label_x is None else label_x\n    ax.set_xlabel(xlab)\n    ax.set_ylabel(ylab)\n    if label_g is not None:\n        plt.gca().legend(title=label_g)\n    if title is not None:\n        ax.set_title(title)\n    return cast(Axes, gbar)\n</code></pre>"},{"location":"bs_seaborn.html#bs_python_utils.bs_seaborn.bs_sns_density_estimates","title":"<code>bs_sns_density_estimates(df, true_values, method_string='Estimator', coeff_string='Parameter', estimate_string='Estimate', max_cols=3)</code>","text":"<p>Plots the densities of estimates of several coefficients with several methods, superposed by methods and faceted by coefficients.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>contains columns <code>method_string</code>, <code>coeff_name</code>, <code>estimate_value</code></p> required <code>true_values</code> <code>ndarray</code> <p>the true values of the coefficients</p> required <code>method_string</code> <code>str | None</code> <p>the name of the column that indicates the method</p> <code>'Estimator'</code> <code>coeff_string</code> <code>str | None</code> <p>the name of the column that indicates the coefficient</p> <code>'Parameter'</code> <code>estimate_string</code> <code>str | None</code> <p>the name of the column that gives the value of the estimate</p> <code>'Estimate'</code> <code>max_cols</code> <code>int</code> <p>we wrap after that</p> <code>3</code> <p>Returns:</p> Type Description <code>FacetGrid</code> <p>the <code>FacetGrid</code> plot.</p> Source code in <code>bs_python_utils/bs_seaborn.py</code> <pre><code>def bs_sns_density_estimates(\n    df: pd.DataFrame,\n    true_values: np.ndarray,\n    method_string: str | None = \"Estimator\",\n    coeff_string: str | None = \"Parameter\",\n    estimate_string: str | None = \"Estimate\",\n    max_cols: int = 3,\n) -&gt; sns.FacetGrid:\n    \"\"\"\n    Plots the densities of estimates of several coefficients with several methods,\n    superposed by methods and faceted by coefficients.\n\n    Args:\n        df: contains columns `method_string`, `coeff_name`, `estimate_value`\n        true_values: the true values of the coefficients\n        method_string: the name of the column that indicates the method\n        coeff_string: the name of the column that indicates the coefficient\n        estimate_string: the name of the column that gives the value of the estimate\n        max_cols: we wrap after that\n\n    Returns:\n        the `FacetGrid` plot.\n\n    \"\"\"\n    g = sns.FacetGrid(\n        data=df,\n        sharex=False,\n        sharey=False,\n        hue=method_string,\n        col=coeff_string,\n        col_wrap=max_cols,\n    )\n    g.map(sns.kdeplot, estimate_string)\n    g.set_titles(\"{col_name}\")\n    for true_val, ax in zip(true_values, g.axes.ravel(), strict=True):\n        ax.vlines(true_val, *ax.get_ylim(), color=\"k\", linestyles=\"dashed\")\n    g.add_legend()\n\n    return g\n</code></pre>"},{"location":"bs_seaborn.html#bs_python_utils.bs_seaborn.bs_sns_plot_density","title":"<code>bs_sns_plot_density(df, var_name, save_to=None)</code>","text":"<p>plots the density of a variable</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>dataframe, should contain column <code>var_name</code></p> required <code>var_name</code> <code>str</code> <p>the name of a continuous variable</p> required <code>save_to</code> <code>str | None</code> <p>(maybe) where we save the plot, with <code>.png</code> extension.</p> <code>None</code> Source code in <code>bs_python_utils/bs_seaborn.py</code> <pre><code>def bs_sns_plot_density(\n    df: pd.DataFrame, var_name: str, save_to: str | None = None\n) -&gt; None:\n    \"\"\"plots the density of a variable\n\n    Args:\n        df: dataframe, should contain column `var_name`\n        var_name:  the name of a continuous variable\n        save_to: (maybe) where we save the plot, with `.png` extension.\n    \"\"\"\n    var_y = df[var_name].values\n    var_fig = sns.kdeplot(var_y)\n    var_fig.axvline(x=0, c=\"k\", ls=\"dashed\")\n    var_fig.set_title(f\"Density of the {var_name}\")\n    var_fig.set_xlabel(f\"Value of {var_name}\")\n    var_fig.set_ylabel(\"Value of the density\")\n    if save_to:\n        plt.savefig(f\"{save_to}.png\")\n</code></pre>"},{"location":"bs_sparse_gaussian.html","title":"bs_sparse_gaussian module","text":"<p>Sets up sparse integration over a Gaussian, given text files that contain rescaled Gauss-Hermite nodes and weights.</p> <p>These files must be named <code>GHsparseGrid{ndims}prec{iprec}.txt</code>, where <code>ndims</code> is the number of dimensions of integration  and <code>iprec</code> is a precision level that must be 9, 13, or (most precise) 17. The file must have <code>(ndims+1)</code> columns,  with the weights in the first column.</p> <p>The nodes and weights are rescaled so that <code>f(nodes) @ weights</code> approximates <code>Ef(X)</code> for <code>X</code> an <code>N(0,I)</code> variable.</p>"},{"location":"bs_sparse_gaussian.html#bs_python_utils.bs_sparse_gaussian.setup_sparse_gaussian","title":"<code>setup_sparse_gaussian(ndims, iprec, GHsparsedir=None)</code>","text":"<p>Get nodes and weights for sparse integration Ef(X) with X = N(0,1) in <code>ndims</code> dimensions.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; nodes, weights = setup_sparse_gaussian(mdims, iprec)\n&gt;&gt;&gt; integral_f = f(nodes) @ weights\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>ndims</code> <code>int</code> <p>number of dimensions (1 to 5)</p> required <code>iprec</code> <code>int</code> <p>precision (must be 9, 13, or 17)</p> required <code>GHsparsedir</code> <code>str | None</code> <p>the name of a directory that contains nodes and weights</p> <code>None</code> <p>Returns:</p> Type Description <code>TwoArrays</code> <p>a pair of  arrays <code>nodes</code> and <code>weights</code>;</p> <code>TwoArrays</code> <p><code>nodes</code> has <code>ndims-1</code> columns and <code>weights</code> is a vector with the same number of rows.</p> Source code in <code>bs_python_utils/bs_sparse_gaussian.py</code> <pre><code>def setup_sparse_gaussian(\n    ndims: int, iprec: int, GHsparsedir: str | None = None\n) -&gt; TwoArrays:\n    \"\"\"\n    Get nodes and weights for sparse integration Ef(X) with X = N(0,1) in `ndims` dimensions.\n\n    Examples:\n        &gt;&gt;&gt; nodes, weights = setup_sparse_gaussian(mdims, iprec)\n        &gt;&gt;&gt; integral_f = f(nodes) @ weights\n\n    Args:\n        ndims: number of dimensions (1 to 5)\n        iprec: precision (must be 9, 13, or 17)\n        GHsparsedir: the name of a directory that contains nodes and weights\n\n    Returns:\n        a pair of  arrays `nodes` and `weights`;\n        `nodes` has `ndims-1` columns and `weights` is a vector with the same number of rows.\n    \"\"\"\n    GHdir = (\n        Path.home() / \"Dropbox\" / \"GHsparseGrids\"\n        if GHsparsedir is None\n        else Path(GHsparsedir)\n    )\n    if iprec not in [9, 13, 17]:\n        bs_error_abort(\n            f\"We only do sparse integration with precision 9, 13, or 17, not {iprec}\"\n        )\n\n    if ndims in [1, 2, 3, 4, 5]:\n        if not GHdir.exists():\n            bs_error_abort(\"I did not find the directory with the nodes/weights files.\")\n        grid = np.loadtxt(GHdir / f\"GHsparseGrid{ndims}prec{iprec}.txt\")\n\n        print(f\"{grid.shape=}\")\n        if ndims == 1:\n            weights = grid[:, 0]\n            nodes = grid[:, 1]\n        else:\n            weights = grid[:, 0]\n            nodes = grid[:, 1:]\n        return nodes, weights\n    else:\n        bs_error_abort(\n            f\"We only do sparse integration in one to five dimensions, not {ndims}\"\n        )\n        return np.zeros(1), np.zeros(1)  # for mypy\n</code></pre>"},{"location":"bsmplutils.html","title":"bsmplutils module","text":"<p>A Matplotlib utility program:</p> <ul> <li><code>ax_text</code>: annotate an <code>ax</code> with text.</li> <li><code>bs_mpl_plot_dcm_fit</code>: generates a boxplot of the predicted probas for a discrete choice model</li> </ul>"},{"location":"bsmplutils.html#bs_python_utils.bsmplutils.ax_text","title":"<code>ax_text(ax, str_txt, x, y)</code>","text":"<p>Annotate an <code>ax</code> with text in Matplotlib.</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>Axes</code> <p>the axis we want to annotate</p> required <code>str_txt</code> <code>str</code> <p>a string of text</p> required <code>x</code> <code>float</code> <p>position in fraction of horizontal axis</p> required <code>y</code> <code>float</code> <p>position in fraction of vertical axis</p> required <p>Returns:</p> Type Description <code>Axes</code> <p>the nnotated <code>ax</code>.</p> Source code in <code>bs_python_utils/bsmplutils.py</code> <pre><code>def ax_text(ax: axes.Axes, str_txt: str, x: float, y: float) -&gt; axes.Axes:\n    \"\"\"\n    Annotate an `ax` with text in Matplotlib.\n\n    Args:\n        ax: the axis we want to annotate\n        str_txt: a string of text\n        x: position in fraction of horizontal axis\n        y: position in fraction of vertical axis\n\n    Returns:\n        the nnotated `ax`.\n    \"\"\"\n    if not (isinstance(x, float) and 0 &lt;= x &lt;= 1):\n        bs_error_abort(\"x should be a number between 0.0 and 1.0\")\n    if not (isinstance(y, float) and 0 &lt;= y &lt;= 1):\n        bs_error_abort(\"y should be a number between 0.0 and 1.0\")\n    ax.text(\n        x,\n        y,\n        str_txt,\n        horizontalalignment=\"center\",\n        verticalalignment=\"center\",\n        transform=ax.transAxes,\n    )\n    return ax\n</code></pre>"},{"location":"bsmplutils.html#bs_python_utils.bsmplutils.bs_mpl_plot_dcm_fit","title":"<code>bs_mpl_plot_dcm_fit(y_true, probhat, max_cols=4, save_to=None)</code>","text":"<p>generates a boxplot of the predicted probas for a discrete choice model    by the actual value of the variable \\(y\\).</p> <p>Parameters:</p> Name Type Description Default <code>y_true</code> <code>ndarray</code> <p>an <code>(nobs)</code> vector with the true value of \\(y\\)</p> required <code>probhat</code> <code>ndarray</code> <p>the predicted probas for the values of \\(y\\)</p> required <code>max_cols</code> <code>int</code> <p>the maximum number of columns in the plot. Defaults to 4.</p> <code>4</code> <code>save_to</code> <code>str | None</code> <p>(maybe) where we save the plot, with <code>.png</code> extension.</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>nothing.</p> Source code in <code>bs_python_utils/bsmplutils.py</code> <pre><code>def bs_mpl_plot_dcm_fit(\n    y_true: np.ndarray,\n    probhat: np.ndarray,\n    max_cols: int = 4,\n    save_to: str | None = None,\n) -&gt; None:\n    \"\"\"generates a boxplot of the predicted probas for a discrete choice model\n       by the actual value of the variable $y$.\n\n    Args:\n        y_true: an `(nobs)` vector with the true value of $y$\n        probhat: the predicted probas for the values of $y$\n        max_cols: the maximum number of columns in the plot. Defaults to 4.\n        save_to: (maybe) where we save the plot, with `.png` extension.\n\n    Returns:\n        nothing.\n    \"\"\"\n    n_vals_y = np.unique(y_true).size\n    y_means = np.zeros(n_vals_y)\n    for k in range(n_vals_y):\n        y_means[k] = np.mean(probhat[:, k])\n\n    if n_vals_y &gt; max_cols:\n        n_rows = (n_vals_y - 1) // max_cols + 1\n        n_cols = max_cols\n    else:\n        n_rows = 1\n        n_cols = n_vals_y\n\n    fig, ax = plt.subplots(n_rows, n_cols, sharey=True)\n    k = 0\n    for row in range(n_rows):\n        for col in range(n_cols):\n            ax_k = ax[row, col] if n_rows &gt; 1 else ax[col]\n            ax_k.boxplot(probhat[y_true == k, k])\n            ax_k.hlines(y_means[k], *ax_k.get_xlim(), linestyle=\"dashed\", linewidth=1)\n            ax_k.set_xticks([])\n            # if col &gt; 0:\n            #     # suppress ticks on the vertical axis\n            #     ax_k.set_yticks([])\n            # ax_k.xaxis.set_major_locator(ticker.FixedLocator(positions))\n            # ax_k.xaxis.set_major_formatter(\n            #     ticker.FixedFormatter([f\"y = {k+1}\" for k in range(n_vals_y)])\n            # )\n            ax_k.set_xlabel(f\"y = {k+1}\")\n            ax_k.grid(axis=\"y\", alpha=0.5)\n            k += 1\n            if k == n_vals_y:\n                break\n    if save_to:\n        fig.savefig(f\"{save_to}.png\")\n</code></pre>"},{"location":"bsnputils.html","title":"bsnputils module","text":"<p>Contains various <code>numpy</code> utility programs.</p> Note <p>if the math looks strange in the documentation, just reload the page.</p> <ul> <li><code>BivariatePolynomial</code>: a minimal class for bivariate polynomials</li> <li><code>outer_bivar</code>: make a <code>BivariatePolynomial</code> from two <code>Polynomial</code> objects</li> <li><code>check_vector</code>, <code>check_matrix</code>, <code>check_vector_or_matrix</code>, <code>check_square</code>, <code>check_tensor</code>: check an array and return its shape</li> <li><code>grid_function</code>: apply a function on a lattice grid</li> <li><code>generate_RNG_streams</code>: generate a number of random number streams (for parallelizations)</li> <li><code>ecdf, inv_ecdf</code>: the empirical cdf of a sample and its inverse</li> <li><code>nprepeat_col, nprepeat_row</code>: repeat a column or a row</li> <li><code>npmaxabs</code>: maximum absolute value of the elements of an array</li> <li><code>rice_stderr</code>: the Rice local standard errors of a random variable</li> <li><code>bs_sqrt_pdmatrix</code>: square root of a posuitve definite matrix</li> <li><code>nplog</code>, <code>npexp, npxlogx</code>: \\(C^2\\) extensions of <code>np.log</code>, <code>np.exp</code>, and \\(x\\log x\\), with first two derivatives</li> <li><code>nppow</code>: \\(a^b\\) for arrays, with first two derivatives</li> <li><code>nppad_beg_zeros</code>, <code>nppad_end_zeros</code>, <code>nppad2_end_zeros</code>: pad the beginning or the end of an array with 0</li> <li><code>bsgrid, make_lexico_grid</code>:  construct grid arrays</li> <li><code>gauleg, gauher</code>: nodes and weights of Gauss-Legendre and Gauss-Hermite polynomials</li> <li><code>gaussian_expectation</code>: uses Gauss-Hermite to compute \\(Ef(X)\\) for \\(X=N(0,1)\\)</li> <li><code>legendre_polynomials</code>: evaluates the Legendre polynomials</li> <li><code>quantile_transform</code>: returns the quantiles of values in an array</li> <li><code>print_quantiles</code>: prints requested quantiles of an array</li> <li><code>set_elements_abovebelow_diagonal</code>: sets all elements of the given matrix above or below the diagonal to a specified scalar value.</li> </ul>"},{"location":"bsnputils.html#bs_python_utils.bsnputils.BivariatePolynomial","title":"<code>BivariatePolynomial</code>","text":"<p>A class for bivariate polynomials as a list of <code>Polynomial</code> objects, with a minimal interface:</p> <ul> <li>construct from a matrix of coefficients</li> <li>add, subtract, multiply (with a constant and with a <code>BivariatePolynomial</code>)</li> <li>evaluate \\(p(x, y)\\) when x, y are at most vectors (and have the same shape if both vectors)</li> </ul> Source code in <code>bs_python_utils/bsnputils.py</code> <pre><code>class BivariatePolynomial:\n    \"\"\"\n    A class for bivariate polynomials as a list of `Polynomial` objects, with a minimal interface:\n\n    * construct from a matrix of coefficients\n    * add, subtract, multiply (with a constant and with a `BivariatePolynomial`)\n    * evaluate $p(x, y)$ when x, y are at most vectors (and have the same shape if both vectors)\n    \"\"\"\n\n    def __init__(self, coeffs: np.ndarray):\n        \"\"\"\n        coeffs: a `(deg1+1, deg2+2)` matrix\n        \"\"\"\n        self.deg1, self.deg2 = coeffs.shape[0] - 1, coeffs.shape[1] - 1\n        self.coef = coeffs\n        self.listpol2 = []\n        for k in range(self.deg1 + 1):\n            self.listpol2.append(Polynomial(coeffs[k, :]))\n\n    def __add__(self, bivpol):\n        if isinstance(bivpol, (int, float)):\n            coeffs = self.coef.copy()\n            coeffs[0, 0] += bivpol\n            return BivariatePolynomial(coeffs)\n        degbp1, degbp2 = bivpol.deg1, bivpol.deg2\n        max_deg1 = max(degbp1, self.deg1)\n        max_deg2 = max(degbp2, self.deg2)\n        coeffs_new = nppad2_end_zeros(self.coef, max_deg1 + 1, max_deg2 + 1)\n        coeffsbp_new = nppad2_end_zeros(bivpol.coef, max_deg1 + 1, max_deg2 + 1)\n        return BivariatePolynomial(coeffs_new + coeffsbp_new)\n\n    def __repr__(self):\n        return f\"BivariatePolynomial({self.deg1!r}, {self.deg2!r})\"\n\n    def __iadd__(self, bivpol):\n        return self.__add__(bivpol)\n\n    def __radd__(self, bivpol):\n        return self.__add__(bivpol)\n\n    def __sub__(self, bivpol):\n        if isinstance(bivpol, (int, float)):\n            coeffs = self.coef.copy()\n            coeffs[0, 0] -= bivpol\n            return BivariatePolynomial(coeffs)\n        degbp1, degbp2 = bivpol.deg1, bivpol.deg2\n        max_deg1 = max(degbp1, self.deg1)\n        max_deg2 = max(degbp2, self.deg2)\n        coeffs_new = nppad2_end_zeros(self.coef, max_deg1 + 1, max_deg2 + 1)\n        coeffsbp_new = nppad2_end_zeros(bivpol.coef, max_deg1 + 1, max_deg2 + 1)\n        return BivariatePolynomial(coeffs_new - coeffsbp_new)\n\n    def __mul__(self, bivpol):\n        if isinstance(bivpol, (int, float)):\n            return BivariatePolynomial(bivpol * self.coef)\n        deg1, degbp1 = self.deg1, bivpol.deg1\n        deg2, degbp2 = self.deg2, bivpol.deg2\n        degmul1 = deg1 + degbp1\n        degmul2 = deg2 + degbp2\n        lp2, blp2 = self.listpol2, bivpol.listpol2\n\n        coeffs_mul = np.zeros((degmul1 + 1, degmul2 + 1))\n        for m in range(degmul1 + 1):\n            minm = max(0, m - degbp1)\n            maxm = min(m, self.deg1)\n            pm = Polynomial(0)\n            for i in range(minm, maxm + 1):\n                pm += lp2[i] * blp2[m - i]\n            coeffs_mul[m, :] += pm.coef\n\n        bp_mul = BivariatePolynomial(coeffs_mul)\n        return bp_mul\n\n    def __rmul__(self, bivpol):\n        return self.__mul__(bivpol)\n\n    def __call__(self, x1, x2):\n        x1fac = 1.0\n        val = 0.0\n        for p in self.listpol2:\n            val += p(x2) * x1fac\n            x1fac *= x1\n        return val\n</code></pre>"},{"location":"bsnputils.html#bs_python_utils.bsnputils.BivariatePolynomial.__init__","title":"<code>__init__(coeffs)</code>","text":"<p>coeffs: a <code>(deg1+1, deg2+2)</code> matrix</p> Source code in <code>bs_python_utils/bsnputils.py</code> <pre><code>def __init__(self, coeffs: np.ndarray):\n    \"\"\"\n    coeffs: a `(deg1+1, deg2+2)` matrix\n    \"\"\"\n    self.deg1, self.deg2 = coeffs.shape[0] - 1, coeffs.shape[1] - 1\n    self.coef = coeffs\n    self.listpol2 = []\n    for k in range(self.deg1 + 1):\n        self.listpol2.append(Polynomial(coeffs[k, :]))\n</code></pre>"},{"location":"bsnputils.html#bs_python_utils.bsnputils.bs_sqrt_pdmatrix","title":"<code>bs_sqrt_pdmatrix(m)</code>","text":"<p>square root of a positive definite matrix</p> <p>Parameters:</p> Name Type Description Default <code>m</code> <code>ndarray</code> <p>a positive definite matrix</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>the square root of the matrix.</p> Source code in <code>bs_python_utils/bsnputils.py</code> <pre><code>def bs_sqrt_pdmatrix(m: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    square root of a positive definite matrix\n\n    Args:\n        m: a positive definite matrix\n\n    Returns:\n        the square root of the matrix.\n    \"\"\"\n    _ = check_square(m, \"bs_sqrt_pdmatrix\")\n    eigval, eigvec = np.linalg.eigh(m)\n    eigval = np.maximum(eigval, 0.0)\n    eigval_sqrt = np.sqrt(eigval)\n    eigval_sqrt_diag = np.diag(eigval_sqrt)\n    res = eigvec @ eigval_sqrt_diag @ eigvec.T\n    return cast(np.ndarray, res)\n</code></pre>"},{"location":"bsnputils.html#bs_python_utils.bsnputils.bsgrid","title":"<code>bsgrid(v, w)</code>","text":"<p>make a two-dimensional matrix of all pairs of elements of the vectors <code>v</code> and <code>w</code></p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>ndarray</code> <p>basis vector, size m</p> required <code>w</code> <code>ndarray</code> <p>basis vector, size n</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>an array of shape <code>(m n,2)</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; v = np.array([1,2,3])\n&gt;&gt;&gt; w = np.array([4,5])\n&gt;&gt;&gt; bsgrid(v, w)\narray([[1, 4],\n[1, 5],\n[2, 4],\n[2, 5],\n[3, 4],\n[3, 5]])\n</code></pre> Source code in <code>bs_python_utils/bsnputils.py</code> <pre><code>def bsgrid(v: np.ndarray, w: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    make a two-dimensional matrix of all pairs of elements of the vectors `v` and `w`\n\n    Args:\n        v: basis vector, size m\n        w: basis vector, size n\n\n    Returns:\n        an array of shape `(m n,2)`.\n\n    Examples:\n        &gt;&gt;&gt; v = np.array([1,2,3])\n        &gt;&gt;&gt; w = np.array([4,5])\n        &gt;&gt;&gt; bsgrid(v, w)\n        array([[1, 4],\n        [1, 5],\n        [2, 4],\n        [2, 5],\n        [3, 4],\n        [3, 5]])\n    \"\"\"\n    m = check_vector(v)\n    n = check_vector(w)\n    m, n = v.size, w.size\n    v1 = np.repeat(v, n)\n    v2 = np.tile(w, m)\n    return np.column_stack((v1, v2))\n</code></pre>"},{"location":"bsnputils.html#bs_python_utils.bsnputils.check_matrix","title":"<code>check_matrix(x, fun_name=None)</code>","text":"<p>test that <code>x</code> is a matrix; aborts otherwise</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Any</code> <p>a matrix, we hope</p> required <code>fun_name</code> <code>str | None</code> <p>name of the calling function</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[int, int]</code> <p>the shape if successful</p> Source code in <code>bs_python_utils/bsnputils.py</code> <pre><code>def check_matrix(x: Any, fun_name: str | None = None) -&gt; tuple[int, int]:\n    \"\"\"\n    test that `x` is a matrix; aborts otherwise\n\n    Args:\n        x: a matrix, we hope\n        fun_name: name of the calling function\n\n    Returns:\n        the shape if successful\n    \"\"\"\n    fun_str = [\"\" if fun_name is None else fun_name + \":\"]\n    if not isinstance(x, np.ndarray):\n        bs_error_abort(f\"{fun_str} Xx should be a Numpy array\")\n    x = cast(np.ndarray, x)\n    ndims_x = x.ndim\n    if ndims_x != 2:\n        bs_error_abort(f\"{fun_str} x should have two dimensions, not {ndims_x}\")\n    return cast(tuple[int, int], x.shape)\n</code></pre>"},{"location":"bsnputils.html#bs_python_utils.bsnputils.check_square","title":"<code>check_square(A, fun_name=None)</code>","text":"<p>test that an object used in <code>fun_name</code> is a square matrix</p> <p>Parameters:</p> Name Type Description Default <code>A</code> <code>Any</code> <p>square matrix, we hope</p> required <code>fun_name</code> <code>str | None</code> <p>the name of the calling function</p> <code>None</code> <p>Returns:</p> Type Description <code>int</code> <p>the number of rows and columns of <code>A</code></p> Source code in <code>bs_python_utils/bsnputils.py</code> <pre><code>def check_square(A: Any, fun_name: str | None = None) -&gt; int:\n    \"\"\"\n    test that an object used in `fun_name` is a square matrix\n\n    Args:\n        A: square matrix, we hope\n        fun_name: the name of the calling function\n\n    Returns:\n        the number of rows and columns of `A`\n    \"\"\"\n    fun_str = [\"\" if fun_name is None else fun_name + \":\"]\n    if not isinstance(A, np.ndarray):\n        bs_error_abort(f\"{fun_str} A should be a Numpy array\")\n    A = cast(np.ndarray, A)\n    if A.ndim == 2:\n        n, nv = A.shape\n        if nv != n:\n            bs_error_abort(f\"{fun_str} The matrix A should be square, not {A.shape}\")\n    else:\n        bs_error_abort(f\"{fun_name} A should have  two dimensions, not {A.ndim}\")\n    return cast(int, n)\n</code></pre>"},{"location":"bsnputils.html#bs_python_utils.bsnputils.check_tensor","title":"<code>check_tensor(x, n_dims, fun_name=None)</code>","text":"<p>test that <code>x</code> is an <code>n_dims</code> dimensional array; aborts otherwise</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Any</code> <p>an <code>n_dims</code> dimensional array, we hope</p> required <code>fun_name</code> <code>str | None</code> <p>name of the calling function</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[int, ...]</code> <p>the shape if successful</p> Source code in <code>bs_python_utils/bsnputils.py</code> <pre><code>def check_tensor(x: Any, n_dims: int, fun_name: str | None = None) -&gt; tuple[int, ...]:\n    \"\"\"\n    test that `x` is an `n_dims` dimensional array; aborts otherwise\n\n    Args:\n        x: an `n_dims` dimensional array, we hope\n        fun_name: name of the calling function\n\n    Returns:\n        the shape if successful\n    \"\"\"\n    fun_str = [\"\" if fun_name is None else fun_name + \":\"]\n    if not isinstance(x, np.ndarray):\n        bs_error_abort(f\"{fun_str} x should be a Numpy array\")\n    x = cast(np.ndarray, x)\n    ndims_x = x.ndim\n    if ndims_x != n_dims:\n        bs_error_abort(f\"{fun_str} x should have {n_dims} dimensions, not {ndims_x}\")\n        return (0,)  # for mypy\n    return cast(tuple[int, ...], x.shape)\n</code></pre>"},{"location":"bsnputils.html#bs_python_utils.bsnputils.check_vector","title":"<code>check_vector(v, fun_name=None)</code>","text":"<p>test that <code>v</code> is a vector; aborts otherwise</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>Any</code> <p>a vector, we hope</p> required <code>fun_name</code> <code>str | None</code> <p>name of the calling function</p> <code>None</code> <p>Returns:</p> Type Description <code>int</code> <p>the size if successful.</p> Source code in <code>bs_python_utils/bsnputils.py</code> <pre><code>def check_vector(v: Any, fun_name: str | None = None) -&gt; int:\n    \"\"\"\n    test that `v` is a vector; aborts otherwise\n\n    Args:\n        v: a vector, we hope\n        fun_name: name of the calling function\n\n    Returns:\n        the size if successful.\n    \"\"\"\n    fun_str = [\"\" if fun_name is None else fun_name + \":\"]\n    if not isinstance(v, np.ndarray):\n        bs_error_abort(f\"{fun_str} v should be a Numpy array\")\n    v = cast(np.ndarray, v)\n    ndims_v = v.ndim\n    if ndims_v != 1:\n        bs_error_abort(f\"{fun_str} v should have one dimension, not {ndims_v}\")\n    return cast(int, v.size)\n</code></pre>"},{"location":"bsnputils.html#bs_python_utils.bsnputils.check_vector_or_matrix","title":"<code>check_vector_or_matrix(x, fun_name=None)</code>","text":"<p>test that <code>x</code> is a vector or a matrix; aborts otherwise</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Any</code> <p>a vector or matrix, we hope</p> required <code>fun_name</code> <code>str | None</code> <p>name of the calling function</p> <code>None</code> <p>Returns:</p> Type Description <code>int</code> <p>the number of dimensions of <code>x</code> (1 or 2)</p> Source code in <code>bs_python_utils/bsnputils.py</code> <pre><code>def check_vector_or_matrix(x: Any, fun_name: str | None = None) -&gt; int:\n    \"\"\"\n    test that `x` is a vector or a matrix; aborts otherwise\n\n    Args:\n        x: a vector or matrix, we hope\n        fun_name: name of the calling function\n\n    Returns:\n        the number of dimensions of `x` (1 or 2)\n    \"\"\"\n    fun_str = [\"\" if fun_name is None else fun_name + \":\"]\n    if not isinstance(x, np.ndarray):\n        bs_error_abort(f\"{fun_str} X should be a Numpy array\")\n    x = cast(np.ndarray, x)\n    ndims_x = x.ndim\n    if ndims_x != 1 and ndims_x != 2:\n        bs_error_abort(f\"{fun_str} x should have at most two dimensions, not {ndims_x}\")\n    return cast(int, ndims_x)\n</code></pre>"},{"location":"bsnputils.html#bs_python_utils.bsnputils.ecdf","title":"<code>ecdf(x)</code>","text":"<p>Evaluate the empirical cdf at each point in sample</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ndarray</code> <p>1-dim array <code>(nobs)</code></p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>A 1-dim array <code>(nobs)</code>  with the values of the empirical cdf at <code>x</code>, from 1/<code>nobs</code> to 1</p> Source code in <code>bs_python_utils/bsnputils.py</code> <pre><code>def ecdf(x: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Evaluate the empirical cdf at each point in sample\n\n    Args:\n        x: 1-dim array `(nobs)`\n\n    Returns:\n        A 1-dim array `(nobs)`  with the values of the empirical cdf at `x`, from 1/`nobs` to 1\n\n    \"\"\"\n    if x.ndim != 1:\n        print_stars(f\"ecdf: x should have 1 dimension, not {x.ndim}\")\n        sys.exit()\n    nx = x.size\n    order_x = np.argsort(x)\n    ecdf_val = np.zeros(nx)\n    for i_order, n_order in enumerate(order_x):\n        ecdf_val[n_order] = (i_order + 1.0) / nx\n    return ecdf_val\n</code></pre>"},{"location":"bsnputils.html#bs_python_utils.bsnputils.gauher","title":"<code>gauher(n)</code>","text":"<p>nodes and weights for Gauss-Hermite integration</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>number of nodes</p> required <p>Returns:</p> Type Description <code>TwoArrays</code> <p>array of <code>n</code> nodes, array of <code>n</code> weights</p> Source code in <code>bs_python_utils/bsnputils.py</code> <pre><code>def gauher(n: int) -&gt; TwoArrays:\n    \"\"\"\n    nodes and weights for Gauss-Hermite integration\n\n    Args:\n        n: number of nodes\n\n    Returns:\n        array of `n` nodes, array of `n` weights\n    \"\"\"\n    EPS = 1.0e-14\n    PIM4 = 0.7511255444649425\n    MAXIT = 10\n\n    x = np.zeros(n)\n    w = np.zeros(n)\n\n    m = (n + 1) // 2\n\n    for i in range(m):\n        if i == 0:\n            n2 = 2.0 * n + 1.0\n            z = sqrt(n2) - 1.85575 * (n2**-0.16667)\n        elif i == 1:\n            z -= 1.14 * (n**0.426) / z\n        elif i == 2:\n            z = 1.86 * z - 0.86 * x[0]\n        elif i == 3:\n            z = 1.91 * z - 0.91 * x[1]\n        else:\n            z = 2.0 * z - x[i - 2]\n        for _n_iter in range(MAXIT):\n            p1 = PIM4\n            p2 = 0.0\n            for j in range(n):\n                p3 = p2\n                p2 = p1\n                p1 = z * sqrt(2.0 / (j + 1)) * p2 - sqrt(j / (j + 1)) * p3\n            pp = sqrt(2 * n) * p2\n            z1 = z\n            z = z1 - p1 / pp\n            if abs(z - z1) &lt;= EPS:\n                break\n        if _n_iter &gt;= MAXIT:\n            bs_error_abort(f\"too many iterations: {_n_iter}\")\n        x[i] = z\n        x[n - 1 - i] = -z\n        w[i] = 2.0 / (pp * pp)\n        w[n - 1 - i] = w[i]\n\n    # need to reverse order for x (w is symmetric)\n    return cast(TwoArrays, (x[::-1], w))\n</code></pre>"},{"location":"bsnputils.html#bs_python_utils.bsnputils.gauleg","title":"<code>gauleg(n)</code>","text":"<p>nodes and weights for Gauss-Legendre integration <code>\\int_{-1}^1 f(x)dx</code></p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>number of nodes</p> required <p>Returns:</p> Type Description <code>TwoArrays</code> <p>array of <code>n</code> nodes, array of <code>n</code> weights</p> Source code in <code>bs_python_utils/bsnputils.py</code> <pre><code>def gauleg(n: int) -&gt; TwoArrays:\n    \"\"\"\n    nodes and weights for Gauss-Legendre integration `\\\\int_{-1}^1 f(x)dx`\n\n    Args:\n        n: number of nodes\n\n    Returns:\n        array of `n` nodes, array of `n` weights\n    \"\"\"\n    x = np.zeros(n)\n    w = np.zeros(n)\n    EPS = 3e-11\n    m = (n + 1) // 2\n    for i in range(1, m + 1):\n        z = cos(pi * (i - 0.25) / (n + 0.5))\n        z1 = np.inf\n        while abs(z - z1) &gt; EPS:\n            p1 = 1.0\n            p2 = 0.0\n            for j in range(1, n + 1):\n                p3 = p2\n                p2 = p1\n                p1 = ((2.0 * j - 1.0) * z * p2 - (j - 1.0) * p3) / j\n            pp = n * (z * p1 - p2) / (z * z - 1.0)\n            z1 = z\n            z = z1 - p1 / pp\n        x[i - 1] = -z\n        x[n - i] = z\n        w[i - 1] = 2.0 / ((1.0 - z * z) * pp * pp)\n        w[n - i] = w[i - 1]\n\n    return cast(TwoArrays, (x, w))\n</code></pre>"},{"location":"bsnputils.html#bs_python_utils.bsnputils.gaussian_expectation","title":"<code>gaussian_expectation(f, x, w, n=16, vectorized=False, pars=None)</code>","text":"<p>computes the expectation of a function of an <code>N(0,1)</code> random variable using Gauss-Hermite with n nodes the nodes and weights can be provided, if available</p> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>Callable</code> <p>a scalar or array function of a scalar or array variable and possibly other parameters</p> required <code>vectorized</code> <code>bool</code> <p>if True, the function accepts an array as argument</p> <code>False</code> <code>pars</code> <code>Iterable | None</code> <p>parameters for <code>f</code>, if any</p> <code>None</code> <code>n</code> <code>int</code> <p>number of nodes</p> <code>16</code> <code>x</code> <code>ndarray | None</code> <p>locations of the nodes</p> required <code>w</code> <code>ndarray | None</code> <p>their weights</p> required <p>Returns:</p> Type Description <code>ndarray | float</code> <p>the expectation of <code>f(N(0,1))</code></p> Source code in <code>bs_python_utils/bsnputils.py</code> <pre><code>def gaussian_expectation(\n    f: Callable,\n    x: np.ndarray | None,\n    w: np.ndarray | None,\n    n: int = 16,\n    vectorized: bool = False,\n    pars: Iterable | None = None,\n) -&gt; np.ndarray | float:\n    \"\"\"\n    computes the expectation of a function of an `N(0,1)` random variable\n    using Gauss-Hermite with n nodes\n    the nodes and weights can be provided, if available\n\n    Args:\n        f: a scalar or array function of a scalar or array variable and possibly other parameters\n        vectorized: if True, the function accepts an array as argument\n        pars: parameters for `f`, if any\n        n: number of nodes\n        x: locations of the nodes\n        w: their weights\n\n    Returns:\n        the expectation of `f(N(0,1))`\n    \"\"\"\n    if x is None:\n        nodes, weights = gauher(n)\n        nodes *= sqrt(2.0)\n        weights /= sqrt(pi)\n        n_nodes = n\n    elif w is None:\n        bs_error_abort(\"x is None but w is not\")\n    elif w.size != x.size:\n        bs_error_abort(\"x has {x.size} elements and w has {w.size}\")\n    else:\n        nodes = x * sqrt(2.0)\n        weights = w / sqrt(pi)\n        n_nodes = nodes.size\n    if pars is None:\n        if vectorized:\n            integral_vec = f(nodes) @ weights\n        else:\n            # to ensure integral_val has the same shape as f\n            integral_val = weights[0] * f(nodes[0])\n            for i in range(1, n_nodes):\n                integral_val += weights[i] * f(nodes[i])\n    else:\n        if vectorized:\n            integral_vec = f(nodes, pars) @ weights\n        else:\n            # to ensure integral_val has the same shape as f\n            integral_val = weights[0] * f(nodes[0], pars)\n            for i in range(1, n_nodes):\n                integral_val += weights[i] * f(nodes[i], pars)\n\n    return cast(np.ndarray, integral_vec) if vectorized else cast(float, integral_val)\n</code></pre>"},{"location":"bsnputils.html#bs_python_utils.bsnputils.generate_RNG_streams","title":"<code>generate_RNG_streams(nsim, initial_seed=13091962)</code>","text":"<p>return <code>nsim</code> random number generators</p> <p>Parameters:</p> Name Type Description Default <code>nsim</code> <code>int</code> <p>number of RNGs we want</p> required <code>initial_seed</code> <code>int</code> <p>any large integer</p> <code>13091962</code> <p>Returns:</p> Type Description <code>list[Generator]</code> <p><code>nsim</code> streams</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; streams = generate_RNG_streams(10, 575856896)\n&gt;&gt;&gt; x = streams[i].normal(scale=s, size=(nmarkets, nproducts))\n</code></pre> Source code in <code>bs_python_utils/bsnputils.py</code> <pre><code>def generate_RNG_streams(\n    nsim: int, initial_seed: int = 13091962\n) -&gt; list[np.random.Generator]:\n    \"\"\"\n    return `nsim` random number generators\n\n    Args:\n        nsim:  number of RNGs we want\n        initial_seed: any large integer\n\n    Returns:\n        `nsim` streams\n\n    Examples:\n        &gt;&gt;&gt; streams = generate_RNG_streams(10, 575856896)\n        &gt;&gt;&gt; x = streams[i].normal(scale=s, size=(nmarkets, nproducts))\n    \"\"\"\n    ss = np.random.SeedSequence(initial_seed)\n    # Spawn off child SeedSequences to pass to child processes.\n    child_seeds = ss.spawn(nsim)\n    streams = [np.random.default_rng(s) for s in child_seeds]\n    return streams\n</code></pre>"},{"location":"bsnputils.html#bs_python_utils.bsnputils.grid_function","title":"<code>grid_function(fun, x_points, y_points)</code>","text":"<p>apply a function <code>f(x, y)</code> on a lattice grid</p> <p>Parameters:</p> Name Type Description Default <code>fun</code> <code>Callable[[ndarray, ndarray], ndarray]</code> <p>should return a matrix <code>(m, n)</code>  when called with two matrices <code>(m, n)</code></p> required <code>x_points</code> <code>ndarray</code> <p>an <code>m</code>-vector</p> required <code>y_points</code> <code>ndarray</code> <p>an <code>n</code>-vector</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>the <code>(m, n)</code> matrix of values of <code>fun</code> on the grid</p> Source code in <code>bs_python_utils/bsnputils.py</code> <pre><code>def grid_function(\n    fun: Callable[[np.ndarray, np.ndarray], np.ndarray],\n    x_points: np.ndarray,\n    y_points: np.ndarray,\n) -&gt; np.ndarray:\n    \"\"\"apply a function `f(x, y)` on a lattice grid\n\n    Args:\n        fun: should return a matrix `(m, n)`  when called with two matrices `(m, n)`\n        x_points: an `m`-vector\n        y_points: an `n`-vector\n\n    Returns:\n        the `(m, n)` matrix of values of `fun` on the grid\n    \"\"\"\n    _ = check_vector(x_points)\n    _ = check_vector(y_points)\n    X1, Y1 = np.meshgrid(x_points, y_points)\n    z_grid = fun(X1, Y1).T\n    return z_grid\n</code></pre>"},{"location":"bsnputils.html#bs_python_utils.bsnputils.inv_ecdf","title":"<code>inv_ecdf(v, q)</code>","text":"<p>Evaluate the empirical <code>q</code>-quantiles of the sample <code>v</code> in a way that is consistent with <code>ecdf</code>.</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>ndarray</code> <p>1-dim array <code>(nobs)</code> of the data points</p> required <code>q</code> <code>ndarray | float</code> <p>1-dim array <code>(nobs)</code> of quantiles or float</p> required <p>Returns:</p> Type Description <code>ndarray | float</code> <p>A 1-dim array <code>(nobs)</code>  with the values of the <code>q</code>-quantiles of <code>v</code>, or just the one quantile</p> Source code in <code>bs_python_utils/bsnputils.py</code> <pre><code>def inv_ecdf(v: np.ndarray, q: np.ndarray | float) -&gt; np.ndarray | float:\n    \"\"\"Evaluate the empirical `q`-quantiles of the sample `v`\n    in a way that is consistent with `ecdf`.\n\n    Args:\n        v: 1-dim array `(nobs)` of the data points\n        q: 1-dim array `(nobs)` of quantiles or float\n\n    Returns:\n        A 1-dim array `(nobs)`  with the values of the `q`-quantiles of `v`, or just the one quantile\n\n    \"\"\"\n    if v.ndim != 1:\n        bs_error_abort(f\"v should have 1 dimension, not {v.ndim}\")\n    nv = v.size\n    sorted_v = np.zeros(nv + 2)\n    sorted_v[1 : (nv + 1)] = np.sort(v)\n    sorted_v[0] = 2.0 * sorted_v[1] - sorted_v[2]  # added to extend for q &lt; 1/nv\n    sorted_v[nv + 1] = sorted_v[nv]  # added to extend for q = 1\n    if isinstance(q, float):\n        q_floor = np.array([floor(nv * q)])\n        val_q = sorted_v[q_floor] + (nv * q - q_floor) * (\n            sorted_v[q_floor + 1] - sorted_v[q_floor]\n        )\n        return cast(float, val_q)\n    elif isinstance(q, np.ndarray):\n        q_floor = np.floor(nv * q).astype(int)\n        vals_q = sorted_v[q_floor] + (nv * q - q_floor) * (\n            sorted_v[q_floor + 1] - sorted_v[q_floor]\n        )\n        return cast(np.ndarray, vals_q)\n</code></pre>"},{"location":"bsnputils.html#bs_python_utils.bsnputils.legendre_polynomials","title":"<code>legendre_polynomials(x, max_deg, a=-1.0, b=1.0, no_constant=False)</code>","text":"<p>evaluates the Legendre polynomials over <code>x</code> in the interval \\([a, b]\\)</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ndarray</code> <p>the points where the polynomials are to be evaluated</p> required <code>max_deg</code> <code>int</code> <p>the maximum degree</p> required <code>a</code> <code>float</code> <p>the start of the interval, classically -1</p> <code>-1.0</code> <code>b</code> <code>float</code> <p>the end of the interval, classically 1</p> <code>1.0</code> <code>no_constant</code> <code>bool</code> <p>if True, delete the constant polynomial</p> <code>False</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>an array of <code>(max_deg+1)</code> arrays of the shape of <code>x</code>.</p> Source code in <code>bs_python_utils/bsnputils.py</code> <pre><code>def legendre_polynomials(\n    x: np.ndarray,\n    max_deg: int,\n    a: float = -1.0,\n    b: float = 1.0,\n    no_constant: bool = False,\n) -&gt; np.ndarray:\n    \"\"\"evaluates the Legendre polynomials over `x` in the interval $[a, b]$\n\n    Args:\n        x: the points where the polynomials are to be evaluated\n        max_deg: the maximum degree\n        a: the start of the interval, classically -1\n        b: the end of the interval, classically 1\n        no_constant: if True, delete the constant polynomial\n\n    Returns:\n        an array of `(max_deg+1)` arrays of the shape of `x`.\n    \"\"\"\n    sx = check_vector(x)\n    if a &gt; np.min(x):\n        sys.exit(\"legendre_polynomials: points below start of interval\")\n    if b &lt; np.max(x):\n        sys.exit(\"legendre_polynomials: points above end of interval\")\n    p = np.zeros((sx, max_deg + 1))\n    x_transf = 2.0 * (x - a) / (b - a) - 1.0\n    p[:, 0] = np.ones_like(x)\n    p[:, 1] = x_transf\n    for deg in range(2, max_deg + 1):\n        p2 = (2 * deg - 1) * (p[:, deg - 1] * x_transf) - (deg - 1) * p[:, deg - 2]\n        p[:, deg] = p2 / deg\n    polys_p = p[:, 1:] if no_constant else p\n    return polys_p\n</code></pre>"},{"location":"bsnputils.html#bs_python_utils.bsnputils.make_lexico_grid","title":"<code>make_lexico_grid(arr)</code>","text":"<pre><code>make a lexicographic grid; it is a generalization of `bsgrid` for $n_c\n</code></pre> <p>eq 2$.</p> <pre><code>Args:\n    arr: an $n_r$-vector or an $(n_r,n_c)$ matrix; $n_c$` must be 1, 2 or 3\n\nReturns:\n    `arr` if it is a vector; otherwise a matrix $(n_r^{n_c}, n_c)$.\n</code></pre> Source code in <code>bs_python_utils/bsnputils.py</code> <pre><code>def make_lexico_grid(arr: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    make a lexicographic grid; it is a generalization of `bsgrid` for $n_c\\neq 2$.\n\n    Args:\n        arr: an $n_r$-vector or an $(n_r,n_c)$ matrix; $n_c$` must be 1, 2 or 3\n\n    Returns:\n        `arr` if it is a vector; otherwise a matrix $(n_r^{n_c}, n_c)$.\n    \"\"\"\n    ndims_arr = check_vector_or_matrix(arr, \"make_lexico_grid`\")\n    if ndims_arr == 1:\n        return arr\n    else:\n        nr, nc = arr.shape\n        if nc == 2:\n            n0 = np.repeat(arr[:, 0], nr)\n            n1 = np.tile(arr[:, 1], nr)\n            return np.column_stack((n0, n1))\n        elif nc == 3:\n            nr2 = nr * nr\n            n0 = np.repeat(arr[:, 0], nr2)\n            n1 = np.repeat(np.tile(arr[:, 1], nr), nr)\n            n2 = np.tile(arr[:, 2], nr2)\n            return np.column_stack((n0, n1, n2))\n        else:\n            bs_error_abort(\n                f\"at this stage, the number of columns must be 3 or less, not {nc}...\"\n            )\n            return arr  # for mypy\n</code></pre>"},{"location":"bsnputils.html#bs_python_utils.bsnputils.npexp","title":"<code>npexp(arr, bigx=50.0, lowx=-50.0, deriv=0, verbose=False)</code>","text":"<p>\\(C^2\\) extension of  \\(\\exp(a)\\) above <code>bigx</code> and below <code>lowx</code>, perhaps with derivatives</p> <p>Parameters:</p> Name Type Description Default <code>arr</code> <code>ndarray</code> <p>any Numpy array</p> required <code>bigx</code> <code>float</code> <p>upper bound</p> <code>50.0</code> <code>lowx</code> <code>float</code> <p>lower bound</p> <code>-50.0</code> <code>deriv</code> <code>int</code> <p>if 1, compute derivative, if 2, second derivative</p> <code>0</code> <code>verbose</code> <code>bool</code> <p>prints debugging info</p> <code>False</code> <p>Returns:</p> Type Description <code>ndarray | TwoArrays | ThreeArrays</code> <p>\\(\\exp(a)\\) \\(C^2\\)-extended above <code>bigx</code> and below <code>lowx</code>,</p> <code>ndarray | TwoArrays | ThreeArrays</code> <p>perhaps with derivatives</p> Source code in <code>bs_python_utils/bsnputils.py</code> <pre><code>def npexp(\n    arr: np.ndarray,\n    bigx: float = 50.0,\n    lowx: float = -50.0,\n    deriv: int = 0,\n    verbose: bool = False,\n) -&gt; np.ndarray | TwoArrays | ThreeArrays:\n    \"\"\"\n    $C^2$ extension of  $\\\\exp(a)$ above `bigx` and below `lowx`,\n    perhaps with derivatives\n\n    Args:\n        arr: any Numpy array\n        bigx: upper bound\n        lowx: lower bound\n        deriv: if 1, compute derivative, if 2, second derivative\n        verbose: prints debugging info\n\n\n    Returns:\n        $\\\\exp(a)$  $C^2$-extended above `bigx` and below `lowx`,\n        perhaps with derivatives\n    \"\"\"\n    if deriv not in [0, 1, 2]:\n        bs_error_abort(f\"deriv can only be 0, 1, or 2; not {deriv}\")\n    min_arr, max_arr = np.min(arr), np.max(arr)\n    if max_arr &lt;= bigx and min_arr &gt;= lowx:\n        exparr = np.exp(arr)\n        if deriv == 0:\n            return cast(np.ndarray, exparr)\n        elif deriv == 1:\n            return cast(TwoArrays, (exparr, exparr))\n        # deriv == 2\n        return cast(ThreeArrays, (exparr, exparr, exparr))\n    else:  # some large and/or small arguments\n        exparr = np.exp(np.maximum(np.minimum(arr, bigx), lowx))\n        print(f\"{exparr=}\")\n        ebigx = exp(bigx)\n        elowx = exp(lowx)\n        darrb = arr - bigx\n        darrl = lowx - arr\n        exparr_larger = ebigx * (1.0 + darrb * (1.0 + 0.5 * darrb))\n        exparr_smaller = elowx * (1.0 - darrl * (1.0 - 0.5 * darrl))\n        if verbose:\n            n_large_args = np.sum(arr &gt; bigx)\n            finals = \"s\" if n_large_args &gt; 1 else \"\"\n            print(\n                f\"npexp: {n_large_args} argument{finals} larger than {bigx}:\\n\"\n                f\"maxi = {np.max(arr)}\"\n            )\n            n_small_args = np.sum(arr &lt; lowx)\n            finals = \"s\" if n_small_args &gt; 1 else \"\"\n            print(\n                f\"npexp: {n_small_args} argument{finals} smaller than {lowx}:\\n\"\n                f\"mini = {np.min(arr)}\"\n            )\n        expval = exparr\n        print(expval)\n        expval = np.where(arr &gt; bigx, exparr_larger, expval)\n        expval = np.where(arr &lt; lowx, exparr_smaller, expval)\n        if deriv == 0:\n            return cast(np.ndarray, expval)\n        dexpval = exparr\n        dexparr_larger = ebigx * (1.0 + darrb)\n        dexparr_smaller = elowx * (1.0 - darrl)\n        dexpval = np.where(arr &gt; bigx, dexparr_larger, dexpval)\n        dexpval = np.where(arr &lt; lowx, dexparr_smaller, dexpval)\n        if deriv == 1:\n            return cast(TwoArrays, (expval, dexpval))\n        # deriv == 2\n        d2expval = exparr\n        return cast(ThreeArrays, (expval, dexpval, d2expval))\n</code></pre>"},{"location":"bsnputils.html#bs_python_utils.bsnputils.nplog","title":"<code>nplog(arr, eps=1e-30, deriv=0, verbose=False)</code>","text":"<p>\\(C^2\\) extension of  \\(\\ln(a)\\) below <code>eps</code>, perhaps with derivatives</p> <p>Parameters:</p> Name Type Description Default <code>arr</code> <code>ndarray</code> <p>any Numpy array</p> required <code>eps</code> <code>float</code> <p>lower bound</p> <code>1e-30</code> <code>deriv</code> <code>int</code> <p>if 1, compute derivative, if 2, second derivative</p> <code>0</code> <code>verbose</code> <code>bool</code> <p>prints debugging info</p> <code>False</code> <p>Returns:</p> Type Description <code>ndarray | TwoArrays | ThreeArrays</code> <p>\\(\\ln(a)\\) \\(C^2\\)-extended below <code>eps</code>, perhaps with derivatives</p> Source code in <code>bs_python_utils/bsnputils.py</code> <pre><code>def nplog(\n    arr: np.ndarray,\n    eps: float = 1e-30,\n    deriv: int = 0,\n    verbose: bool = False,\n) -&gt; np.ndarray | TwoArrays | ThreeArrays:\n    \"\"\"\n    $C^2$ extension of  $\\\\ln(a)$ below `eps`, perhaps with derivatives\n\n    Args:\n        arr: any Numpy array\n        eps: lower bound\n        deriv: if 1, compute derivative, if 2, second derivative\n        verbose: prints debugging info\n\n    Returns:\n        $\\\\ln(a)$  $C^2$-extended below `eps`, perhaps with derivatives\n    \"\"\"\n    if deriv not in [0, 1, 2]:\n        bs_error_abort(f\"deriv can only be 0, 1, or 2; not {deriv}\")\n    if np.min(arr) &gt; eps:\n        if deriv == 0:\n            return cast(np.ndarray, np.log(arr))\n        elif deriv == 1:\n            return cast(TwoArrays, (np.log(arr), 1.0 / arr))\n        # deriv == 2\n        return cast(ThreeArrays, (np.log(arr), 1.0 / arr, -1.0 / (arr * arr)))\n    else:\n        logarreps = np.log(np.maximum(arr, eps))\n        darr = 1.0 - arr / eps\n        logarr_smaller = log(eps) - darr * (1.0 + darr / 2.0)\n        if verbose:\n            n_small_args = np.sum(arr &lt; eps)\n            if n_small_args &gt; 0:\n                finals = \"s\" if n_small_args &gt; 1 else \"\"\n                print(\n                    f\"nplog: {n_small_args} argument{finals} smaller than {eps}: mini =\"\n                    f\" {np.min(arr)}\"\n                )\n        logeps = np.where(arr &gt; eps, logarreps, logarr_smaller)\n        if deriv == 0:\n            return logeps\n        arreps = np.maximum(arr, eps)\n        der_logarreps = 1.0 / arreps\n        der_logarr_smaller = (1.0 + darr) / eps\n        dlogeps = np.where(arr &gt; eps, der_logarreps, der_logarr_smaller)\n        if deriv == 1:\n            return cast(TwoArrays, (logeps, dlogeps))\n        # deriv == 2\n        der2_logarreps = -1.0 / (arreps * arreps)\n        der2_logarr_smaller = np.full(arr.shape, -1.0 / (eps * eps))\n        d2logeps = np.where(arr &gt; eps, der2_logarreps, der2_logarr_smaller)\n        return cast(ThreeArrays, (logeps, dlogeps, d2logeps))\n</code></pre>"},{"location":"bsnputils.html#bs_python_utils.bsnputils.npmaxabs","title":"<code>npmaxabs(arr)</code>","text":"<p>maximum absolute value in an array</p> <p>Parameters:</p> Name Type Description Default <code>arr</code> <code>ndarray</code> <p>any Numpy array</p> required <p>Returns:</p> Type Description <code>float</code> <p>the largest element in absolute value</p> Source code in <code>bs_python_utils/bsnputils.py</code> <pre><code>def npmaxabs(arr: np.ndarray) -&gt; float:\n    \"\"\"\n    maximum absolute value in an array\n\n    Args:\n        arr: any Numpy array\n\n    Returns:\n        the largest element in absolute value\n    \"\"\"\n    return cast(float, np.max(np.abs(arr)))\n</code></pre>"},{"location":"bsnputils.html#bs_python_utils.bsnputils.nppad2_end_zeros","title":"<code>nppad2_end_zeros(mat, m, n)</code>","text":"<p>pad the ends of a 2-dim array with zeros to increase its size to <code>(m,n)</code>, if needed</p> <p>Parameters:</p> Name Type Description Default <code>mat</code> <code>ndarray</code> <p>2-dim array</p> required <code>m</code> <code>int</code> <p>number of rows requested</p> required <code>n</code> <code>int</code> <p>number of columns requested</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>padded array, where needed</p> Source code in <code>bs_python_utils/bsnputils.py</code> <pre><code>def nppad2_end_zeros(mat: np.ndarray, m: int, n: int) -&gt; np.ndarray:\n    \"\"\"\n    pad the ends of a 2-dim array with zeros to increase its size to `(m,n)`, if needed\n\n    Args:\n        mat: 2-dim array\n        m: number of rows requested\n        n: number of columns requested\n\n    Returns:\n        padded array, where needed\n    \"\"\"\n    nrows, ncols = check_matrix(mat)\n    max_rows = max(m, nrows)\n    max_cols = max(n, ncols)\n    if nrows &lt; max_rows and ncols &lt; max_cols:  # pad both dimensions\n        pmat = np.zeros((m, n))\n        pmat[:nrows, :ncols] = mat\n        return pmat\n    elif nrows &lt; max_rows:  # pad rows\n        pmat = np.zeros((m, ncols))\n        pmat[:nrows, :] = mat\n        return pmat\n    elif ncols &lt; max_cols:  # pad columns\n        pmat = np.zeros((nrows, n))\n        pmat[:, :ncols] = mat\n        return pmat\n    else:  # no need for padding\n        return mat\n</code></pre>"},{"location":"bsnputils.html#bs_python_utils.bsnputils.nppad_beg_zeros","title":"<code>nppad_beg_zeros(v, n)</code>","text":"<p>pad the beginning of a 1-dim array with zeros to increase its size to <code>n</code>, if needed</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>ndarray</code> <p>1-dim array of size <code>(nv)</code></p> required <code>n</code> <code>int</code> <p>size requested</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>padded array if <code>nv</code> &lt; <code>n</code>, otherwise <code>v</code></p> Source code in <code>bs_python_utils/bsnputils.py</code> <pre><code>def nppad_beg_zeros(v: np.ndarray, n: int) -&gt; np.ndarray:\n    \"\"\"\n    pad the beginning of a 1-dim array with zeros to increase its size to `n`, if needed\n\n    Args:\n        v: 1-dim array of size `(nv)`\n        n: size requested\n\n    Returns:\n        padded array if `nv` &lt; `n`, otherwise `v`\n    \"\"\"\n    nv = check_vector(v)\n    if nv &lt; n:\n        return np.pad(v, (n - nv, 0))\n    else:\n        return v\n</code></pre>"},{"location":"bsnputils.html#bs_python_utils.bsnputils.nppad_end_zeros","title":"<code>nppad_end_zeros(v, n)</code>","text":"<p>pad the end of a 1-dim array with zeros to increase its size to <code>n</code>, if needed</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>ndarray</code> <p>1-dim array of size <code>(nv)</code></p> required <code>n</code> <code>int</code> <p>size requested</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>padded array if <code>nv</code> &lt; <code>n</code>, else <code>v</code></p> Source code in <code>bs_python_utils/bsnputils.py</code> <pre><code>def nppad_end_zeros(v: np.ndarray, n: int) -&gt; np.ndarray:\n    \"\"\"\n    pad the end of a 1-dim array with zeros to increase its size to `n`, if needed\n\n    Args:\n        v: 1-dim array of size `(nv)`\n        n: size requested\n\n    Returns:\n        padded array if `nv` &lt; `n`, else `v`\n    \"\"\"\n    nv = check_vector(v)\n    if nv &lt; n:\n        return np.pad(v, (0, n - nv))\n    else:\n        return v\n</code></pre>"},{"location":"bsnputils.html#bs_python_utils.bsnputils.nppow","title":"<code>nppow(a, b, deriv=0)</code>","text":"<p>evaluates a**b element-by-element, perhaps with derivatives</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>ndarray</code> <p>an array</p> required <code>b</code> <code>int | float | ndarray</code> <p>if an array, should have the same shape as <code>a</code></p> required <code>deriv</code> <code>int</code> <p>if 1, compute derivative, if 2, second derivative</p> <code>0</code> <p>Returns:</p> Type Description <code>ndarray | ThreeArrays | SixArrays</code> <p>an array of the same shape as <code>a</code></p> Source code in <code>bs_python_utils/bsnputils.py</code> <pre><code>def nppow(\n    a: np.ndarray, b: int | float | np.ndarray, deriv: int = 0\n) -&gt; np.ndarray | ThreeArrays | SixArrays:\n    \"\"\"\n    evaluates a**b element-by-element, perhaps with derivatives\n\n    Args:\n        a: an array\n        b: if an array, should have the same shape as `a`\n        deriv: if 1, compute derivative, if 2, second derivative\n\n    Returns:\n        an array of the same shape as `a`\n    \"\"\"\n    if isinstance(b, float):\n        mina = np.min(a)\n        if mina &lt; 0.0:\n            bs_error_abort(\"All elements of a must be positive!\")\n\n    if isinstance(b, (int, float)):\n        a_pow_b = a**b\n        if deriv == 0:\n            return a_pow_b\n        log_a = np.log(a)\n        derivs1 = (b * a_pow_b / a, a_pow_b * log_a)\n        if deriv == 1:\n            return cast(ThreeArrays, (a_pow_b, *derivs1))\n        b1 = b - 1.0\n        a_pow_b1 = a_pow_b / a\n        # deriv == 2\n        derivs2 = (\n            b * b1 * a_pow_b1 / a,\n            a_pow_b1 * (1.0 + b * log_a),\n            a_pow_b * log_a * log_a,\n        )\n        return cast(SixArrays, (a_pow_b, *derivs1, *derivs2))\n    else:\n        if a.shape != b.shape:\n            bs_error_abort(\"b is not a number or an array of the same shape as a!\")\n        return _nppow_arrays(a, b, deriv)\n</code></pre>"},{"location":"bsnputils.html#bs_python_utils.bsnputils.nprepeat_col","title":"<code>nprepeat_col(v, n)</code>","text":"<p>create a matrix with <code>n</code> columns equal to <code>v</code></p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>ndarray</code> <p>a 1-dim array of size <code>m</code></p> required <code>n</code> <code>int</code> <p>the number of columns requested</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>a 2-dim array of shape <code>(m, n)</code></p> Source code in <code>bs_python_utils/bsnputils.py</code> <pre><code>def nprepeat_col(v: np.ndarray, n: int) -&gt; np.ndarray:\n    \"\"\"\n    create a matrix with `n` columns equal to `v`\n\n    Args:\n        v: a 1-dim array of size `m`\n        n: the number of columns requested\n\n    Returns:\n        a 2-dim array of shape `(m, n)`\n    \"\"\"\n    return np.repeat(v[:, np.newaxis], n, axis=1)\n</code></pre>"},{"location":"bsnputils.html#bs_python_utils.bsnputils.nprepeat_row","title":"<code>nprepeat_row(v, m)</code>","text":"<p>create a matrix with <code>m</code> rows equal to <code>v</code></p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>ndarray</code> <p>a 1-dim array of size <code>n</code></p> required <code>m</code> <code>int</code> <p>the number of rows requested</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>a 2-dim array of shape <code>(m, n)</code></p> Source code in <code>bs_python_utils/bsnputils.py</code> <pre><code>def nprepeat_row(v: np.ndarray, m: int) -&gt; np.ndarray:\n    \"\"\"\n    create a matrix with `m` rows equal to `v`\n\n    Args:\n        v: a 1-dim array of size `n`\n        m: the number of rows requested\n\n    Returns:\n        a 2-dim array of shape `(m, n)`\n    \"\"\"\n    return np.repeat(v[np.newaxis, :], m, axis=0)\n</code></pre>"},{"location":"bsnputils.html#bs_python_utils.bsnputils.npxlogx","title":"<code>npxlogx(arr, eps=1e-30, deriv=0, verbose=False)</code>","text":"<p>\\(C^2\\) extension of  \\(a\\ln(a)\\) below <code>eps</code>, perhaps with derivatives</p> <p>Parameters:</p> Name Type Description Default <code>arr</code> <code>ndarray</code> <p>a Numpy array</p> required <code>eps</code> <code>float</code> <p>lower bound</p> <code>1e-30</code> <code>deriv</code> <code>int</code> <p>if 1, compute derivative, if 2, second derivative</p> <code>0</code> <code>verbose</code> <code>bool</code> <p>prints debugging info</p> <code>False</code> <p>Returns:</p> Type Description <code>ndarray | TwoArrays | ThreeArrays</code> <p>\\(a\\ln(a)\\) \\(C^2\\)-extended  below <code>eps</code>, perhaps with derivatives</p> Source code in <code>bs_python_utils/bsnputils.py</code> <pre><code>def npxlogx(\n    arr: np.ndarray,\n    eps: float = 1e-30,\n    deriv: int = 0,\n    verbose: bool = False,\n) -&gt; np.ndarray | TwoArrays | ThreeArrays:\n    \"\"\"\n    $C^2$ extension of  $a\\\\ln(a)$ below `eps`, perhaps with derivatives\n\n    Args:\n        arr: a Numpy array\n        eps: lower bound\n        deriv: if 1, compute derivative, if 2, second derivative\n        verbose: prints debugging info\n\n    Returns:\n        $a\\\\ln(a)$  $C^2$-extended  below `eps`, perhaps with derivatives\n    \"\"\"\n    if deriv not in [0, 1, 2]:\n        bs_error_abort(f\"deriv must be 0, 1, or 2; not {deriv}\")\n    if np.min(arr) &gt; eps:\n        return cast(np.ndarray, arr * np.log(arr))\n    else:\n        logeps = log(eps)\n        logarreps = np.log(np.maximum(arr, eps))\n        xlogarreps = arr * logarreps\n        xlogarr_smaller = arr * (arr / eps + logeps - 1.0)\n        if verbose:\n            n_small_args = np.sum(arr &lt; eps)\n            if n_small_args &gt; 0:\n                finals = \"s\" if n_small_args &gt; 1 else \"\"\n                print(\n                    f\"npxlogx: {n_small_args} argument{finals} smaller than {eps}: mini\"\n                    f\" = {np.min(arr)}\"\n                )\n        xlogval = np.where(arr &gt; eps, xlogarreps, xlogarr_smaller)\n        if deriv == 0:\n            return xlogval\n        dxlogarreps = 1.0 + logarreps\n        dxlogarr_smaller = logeps + arr / eps\n        dxlogval = np.where(arr &gt; eps, dxlogarreps, dxlogarr_smaller)\n        if deriv == 1:\n            return cast(TwoArrays, (xlogval, dxlogval))\n        # deriv == 2\n        d2xlogval = 1.0 / np.maximum(arr, eps)\n        return cast(ThreeArrays, (xlogval, dxlogval, d2xlogval))\n</code></pre>"},{"location":"bsnputils.html#bs_python_utils.bsnputils.outer_bivar","title":"<code>outer_bivar(pol1, pol2)</code>","text":"<p>make a <code>BivariatePolynomial</code> from the  product of two <code>Polynomial</code> objects</p> <p>Parameters:</p> Name Type Description Default <code>pol1</code> <code>Polynomial</code> <p>Polynomial in the first variable</p> required <code>pol2</code> <code>Polynomial</code> <p>Polynomial in the second variable</p> required <p>Returns:</p> Type Description <code>BivariatePolynomial</code> <p>a <code>BivariatePolynomial</code> = <code>pol1 * pol2</code></p> Source code in <code>bs_python_utils/bsnputils.py</code> <pre><code>def outer_bivar(pol1: Polynomial, pol2: Polynomial) -&gt; BivariatePolynomial:\n    \"\"\"\n    make a `BivariatePolynomial` from the  product of two `Polynomial` objects\n\n    Args:\n        pol1: Polynomial in the first variable\n        pol2: Polynomial in the second variable\n\n    Returns:\n        a `BivariatePolynomial` = `pol1 * pol2`\n    \"\"\"\n    p1 = pol1.coef\n    p2 = pol2.coef\n    prod_coef = np.outer(p1, p2)\n    return BivariatePolynomial(prod_coef)\n</code></pre>"},{"location":"bsnputils.html#bs_python_utils.bsnputils.print_quantiles","title":"<code>print_quantiles(v, quantiles)</code>","text":"<p>print these quantiles of the array(s)</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>ndarray | Iterable[ndarray]</code> <p>a vector or an iterable of vectors</p> required <code>quantiles</code> <code>ndarray</code> <p>quantiles in [0,1]</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>the corresponding quantiles as a vector or a matrix</p> Source code in <code>bs_python_utils/bsnputils.py</code> <pre><code>def print_quantiles(\n    v: np.ndarray | Iterable[np.ndarray], quantiles: np.ndarray\n) -&gt; np.ndarray:\n    \"\"\"print these quantiles of the array(s)\n\n    Args:\n        v:  a vector or an iterable of vectors\n        quantiles: quantiles in [0,1]\n\n    Returns:\n         the corresponding quantiles as a vector or a matrix\n    \"\"\"\n    nq = check_vector(quantiles)\n    if isinstance(v, np.ndarray):\n        qvals = np.quantile(v, quantiles)\n        for q, qv in zip(quantiles, qvals, strict=True):\n            print(f\"Quantile {q: .3f}: {qv: &gt;10.3f}\")\n    elif isinstance(v, Iterable):\n        v = list(v)\n        for v_i in v:\n            _ = check_vector(v_i)\n        nv = len(v)\n        qvals = np.zeros((nq, nv))\n        for i in range(nv):\n            qvals[:, i] = np.quantile(v[i], quantiles)\n        for iq, q in enumerate(quantiles):\n            s = f\"Quantile {q: .3f}: \"\n            qv = qvals[iq, :]\n            for i in range(nv):\n                s += f\"  {qv[i]: &gt;10.3f}\"\n            print(f\"{s}\")\n    else:\n        bs_error_abort(\"v must be  a vector or a list of vectors\")\n\n    return cast(np.ndarray, qvals)\n</code></pre>"},{"location":"bsnputils.html#bs_python_utils.bsnputils.quantile_transform","title":"<code>quantile_transform(v)</code>","text":"<p>transform a vector of counts into the corresponding quantiles</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>ndarray</code> <p>a vector of counts</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>the corresponding quantiles</p> Source code in <code>bs_python_utils/bsnputils.py</code> <pre><code>def quantile_transform(v: np.ndarray) -&gt; np.ndarray:\n    \"\"\"transform a vector of counts into the corresponding quantiles\n\n    Args:\n        v:  a vector of counts\n\n    Returns:\n         the corresponding quantiles\n    \"\"\"\n    n = check_vector(v)\n    q = np.zeros(n)\n    for i in range(n):\n        q[i] = np.sum(v &lt;= v[i]) / (n + 1)\n    return q\n</code></pre>"},{"location":"bsnputils.html#bs_python_utils.bsnputils.rice_stderr","title":"<code>rice_stderr(y, x, is_sorted=False)</code>","text":"<p>computes the Rice local estimators of the standard error of y | x</p> <p>Parameters:</p> Name Type Description Default <code>y</code> <code>ndarray</code> <p>vector of y-values</p> required <code>x</code> <code>ndarray</code> <p>vector of x-values</p> required <code>is_sorted</code> <code>bool</code> <p>set it to <code>True</code> if <code>x</code> is in increasing order</p> <code>False</code> <p>Returns:</p> Type Description <code>ndarray | float</code> <p>an array of the same size with the stderr(y | x)</p> Source code in <code>bs_python_utils/bsnputils.py</code> <pre><code>def rice_stderr(\n    y: np.ndarray, x: np.ndarray, is_sorted: bool = False\n) -&gt; np.ndarray | float:\n    \"\"\"\n    computes the Rice local estimators of the standard error of y | x\n\n    Args:\n        y: vector of y-values\n        x: vector of x-values\n        is_sorted: set it to `True` if `x` is in increasing order\n\n    Returns:\n        an array of the same size with the stderr(y | x)\n    \"\"\"\n    n = check_vector(x)\n    ny = check_vector(y)\n    if ny != n:\n        bs_error_abort(\"x and y should have the same size\")\n\n    if not is_sorted:\n        # need to sort by increasing value of x\n        order_x = np.argsort(x)\n        ys = y[order_x]\n    else:\n        ys = y\n\n    variance_estimator = np.zeros(n)\n\n    # we average over neighbors\n    n_neighbors = int(sqrt(float(n)) / 2.0)\n    facd = 1.0 / (2.0 * n_neighbors)\n    n_neighbors2 = n_neighbors // 2\n\n    # for the first observations\n    yleft = ys[:n_neighbors2]\n    dy = yleft[1:] - yleft[:-1]\n    variance_estimator[:n_neighbors2] = np.sum(dy * dy) * facd\n\n    # for the middle of the sample\n    minus_nn2 = n - n_neighbors2\n    for ix in range(n_neighbors2, minus_nn2):\n        ix_neighbors = slice(ix - n_neighbors2, ix + n_neighbors2)\n        yx = ys[ix_neighbors]\n        dy = yx[1:] - yx[:-1]\n        variance_estimator[ix] = np.sum(dy * dy) * facd\n\n    # and for the last observations\n    yright = ys[minus_nn2:]\n    dy = yright[1:] - yright[:-1]\n    variance_estimator[minus_nn2:] = np.sum(dy * dy) * facd\n\n    stderr_estimator = np.sqrt(variance_estimator)\n\n    return stderr_estimator\n</code></pre>"},{"location":"bsnputils.html#bs_python_utils.bsnputils.set_elements_abovebelow_diagonal","title":"<code>set_elements_abovebelow_diagonal(matrix, scalar, location)</code>","text":"<p>Sets all elements of the given matrix above or below the diagonal to the specified scalar value.</p> <p>Parameters:</p> Name Type Description Default <code>matrix</code> <code>ndarray</code> <p>the input matrix; it must be square</p> required <code>scalar</code> <code>int | float</code> <p>The scalar value to set the elements above or below the diagonal.</p> required <code>location</code> <code>str</code> <p>'above', 'below', 'on_above', 'on_below'.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>The updated matrix with elements above or below the diagonal set to the scalar value,</p> <code>ndarray</code> <p>including the diagonal for the <code>on_</code> options.</p> Source code in <code>bs_python_utils/bsnputils.py</code> <pre><code>def set_elements_abovebelow_diagonal(\n    matrix: np.ndarray, scalar: int | float, location: str\n) -&gt; np.ndarray:\n    \"\"\"\n    Sets all elements of the given matrix above or below the diagonal\n    to the specified scalar value.\n\n    Args:\n        matrix: the input matrix; it must be square\n        scalar: The scalar value to set the elements above or below the diagonal.\n        location: 'above', 'below', 'on_above', 'on_below'.\n\n    Returns:\n        The updated matrix with elements above or below the diagonal set to the scalar value,\n        including the diagonal for the `on_` options.\n    \"\"\"\n    _ = check_square(matrix, \"set_elements_abovebelow_diagonal\")\n    # copy the matrix\n    new_matrix = matrix.copy()\n\n    # Get the indices of elements above or below the diagonal\n    if location == \"above\":\n        row_indices, col_indices = np.triu_indices_from(new_matrix, k=1)\n    elif location == \"below\":\n        row_indices, col_indices = np.tril_indices_from(new_matrix, k=-1)\n    elif location == \"on_above\":\n        row_indices, col_indices = np.triu_indices_from(new_matrix, k=0)\n    elif location == \"on_below\":\n        row_indices, col_indices = np.tril_indices_from(new_matrix, k=0)\n    else:\n        bs_error_abort(\n            f\"\"\"\n        location can only be 'above', 'below', \n        'on_above' or 'on_below', not {location}\n        \"\"\"\n        )\n\n    # Set the elements above or below the diagonal to the scalar value\n    new_matrix[row_indices, col_indices] = scalar\n\n    return new_matrix\n</code></pre>"},{"location":"bssputils.html","title":"bssputils module","text":"<p>Contains <code>scipy</code> utility programs:</p> <ul> <li><code>describe_array</code>: report descriptive statistics on a vectorized array</li> <li><code>spline_reg</code>: spline interpolation in one dimension.</li> </ul>"},{"location":"bssputils.html#bs_python_utils.bssputils.describe_array","title":"<code>describe_array(v, name='v')</code>","text":"<p>descriptive statistics on an array interpreted as a vector</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>ndarray</code> <p>the array</p> required <code>name</code> <code>str | None</code> <p>its name</p> <code>'v'</code> <p>Returns:</p> Type Description <code>Any</code> <p>the <code>scipy.stats.describe</code> object</p> Source code in <code>bs_python_utils/bssputils.py</code> <pre><code>def describe_array(v: np.ndarray, name: str | None = \"v\") -&gt; Any:\n    \"\"\"\n    descriptive statistics on an array interpreted as a vector\n\n    Args:\n        v: the array\n        name: its name\n\n    Returns:\n        the `scipy.stats.describe` object\n    \"\"\"\n    print_stars(f\"{name} has:\")\n    d = sts.describe(v, None)\n    print(f\"Number of elements: {d.nobs}\")\n    print(f\"Minimum: {d.minmax[0]}\")\n    print(f\"Maximum: {d.minmax[1]}\")\n    print(f\"Mean: {d.mean}\")\n    print(f\"Stderr: {sqrt(d.variance)}\")\n    return d\n</code></pre>"},{"location":"bssputils.html#bs_python_utils.bssputils.spline_reg","title":"<code>spline_reg(y, x, x_new=None, is_sorted=False, smooth=True)</code>","text":"<p>one-dimensional spline interpolation of vector <code>y</code> on vector <code>x</code></p> <p>Parameters:</p> Name Type Description Default <code>y</code> <code>ndarray</code> <p>vector of y-values</p> required <code>x</code> <code>ndarray</code> <p>vector of x-values</p> required <code>x_new</code> <code>ndarray | None</code> <p>where we evaluate (at the points in <code>x</code> by default)</p> <code>None</code> <code>is_sorted</code> <code>bool | None</code> <p>True if <code>x</code> is sorted in increasing order</p> <code>False</code> <code>smooth</code> <code>bool | None</code> <p>True if we want a smoother; otherwise we go through all points provided</p> <code>True</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>values interpolated at <code>x_new</code>.</p> Source code in <code>bs_python_utils/bssputils.py</code> <pre><code>def spline_reg(\n    y: np.ndarray,\n    x: np.ndarray,\n    x_new: np.ndarray | None = None,\n    is_sorted: bool | None = False,\n    smooth: bool | None = True,\n) -&gt; np.ndarray:\n    \"\"\"\n    one-dimensional spline interpolation of vector `y` on vector `x`\n\n    Args:\n        y: vector of y-values\n        x: vector of x-values\n        x_new: where we evaluate (at the points in `x` by default)\n        is_sorted: True if `x` is sorted in increasing order\n        smooth: True if we want a smoother; otherwise we go through all points provided\n\n    Returns:\n        values interpolated at `x_new`.\n    \"\"\"\n    n = check_vector(x)\n    ny = check_vector(y)\n    if ny != n:\n        bs_error_abort(\"x and y should have the same size\")\n\n    if not is_sorted:\n        # need to sort by increasing value of x\n        order_rhs = np.argsort(x)\n        rhs = x[order_rhs]\n        lhs = y[order_rhs]\n    else:\n        rhs, lhs = x, y\n\n    if smooth:\n        # we compute a local estimator of the stderr of (y | x) and we use it to enter weights\n        sigyx = rice_stderr(lhs, rhs)\n        w = 1 / sigyx\n        spl = UnivariateSpline(rhs, lhs, w=w)\n    else:\n        spl = UnivariateSpline(rhs, lhs)\n\n    xeval = x if x_new is None else x_new\n    y_pred = spl(xeval)\n    return cast(np.ndarray, y_pred)\n</code></pre>"},{"location":"bsstats.html","title":"bsstats module","text":"<p>Contains some statistical routines.</p>"},{"location":"bsstats.html#bs_python_utils.bsstats.TslsResults","title":"<code>TslsResults</code>  <code>dataclass</code>","text":"<p>contains the full results of a TSLS regression</p> Source code in <code>bs_python_utils/bsstats.py</code> <pre><code>@dataclass\nclass TslsResults:\n    \"\"\"contains the full results of a TSLS regression\"\"\"\n\n    iv_estimates: float | np.ndarray | None\n    r2_first_iv: float | np.ndarray | None\n    r2_y: float | None\n    r2_second: float | np.ndarray | None\n    y_proj: float | np.ndarray | None\n    y_coeffs: float | np.ndarray | None\n    X_IV_proj: float | np.ndarray | None\n    b_proj_IV: float | np.ndarray | None\n</code></pre>"},{"location":"bsstats.html#bs_python_utils.bsstats.bs_multivariate_normal_pdf","title":"<code>bs_multivariate_normal_pdf(values_x, means_x, cov_mat)</code>","text":"<p>Multivariate (or univariate) normal probability density function at values_x</p> <p>Parameters:</p> Name Type Description Default <code>values_x</code> <code>ndarray</code> <p>values at which to evaluate the pdf, an <code>n</code>-vector or an <code>(n, nvars)</code> matrix</p> required <code>means_x</code> <code>float | ndarray</code> <p>means of the multivariate normal, a float or an <code>(nvars)</code> vector</p> required <code>cov_mat</code> <code>float | ndarray</code> <p>covariance matrix of the multivariate normal, a float or an <code>(nvars, nvars)</code> matrix</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>the values of the density at <code>values_x</code></p> Source code in <code>bs_python_utils/bsstats.py</code> <pre><code>def bs_multivariate_normal_pdf(\n    values_x: np.ndarray, means_x: float | np.ndarray, cov_mat: float | np.ndarray\n) -&gt; np.ndarray:\n    \"\"\"Multivariate (or univariate) normal probability density function at values_x\n\n    Args:\n        values_x: values at which to evaluate the pdf, an `n`-vector or an `(n, nvars)` matrix\n        means_x: means of the multivariate normal, a float or an `(nvars)` vector\n        cov_mat: covariance matrix of the multivariate normal, a float or an `(nvars, nvars)` matrix\n\n    Returns:\n        the values of the density at `values_x`\n    \"\"\"\n    ndims_values = check_vector_or_matrix(values_x, \"bs_multivariate_normal_pdf\")\n    if ndims_values == 1:  # we are evaluating a univariate normal\n        # if not type(means_x) == float:\n        #     bs_error_abort(f\"means_x should be a float as values_x is a vector\")\n        # if not type(cov_mat) == float:\n        #     bs_error_abort(f\"cov_mat should be a float as values_x is a vector\")\n        sigma2 = cov_mat\n        resid = values_x - means_x\n        dval = np.exp(-0.5 * resid * resid / sigma2) / np.sqrt(2 * np.pi * sigma2)\n        return cast(np.ndarray, dval)\n    else:  # we are evaluating a multivariate normal\n        n, nvars = values_x.shape\n        n_means = check_vector(means_x, \"bs_multivariate_normal_pdf\")\n        if n_means != nvars:\n            bs_error_abort(f\"means_x should be a vector of size {nvars} not {n_means}\")\n        nrows, ncols = check_matrix(cov_mat, \"bs_multivariate_normal_pdf\")\n        if nrows != ncols or nrows != nvars:\n            bs_error_abort(\n                f\"cov_mat should be a matrix ({nvars}, {nvars}) not ({nrows}, {ncols})\"\n            )\n        resid = values_x - means_x\n        argresid = spla.solve(cov_mat, resid.T)\n        argexp = np.zeros(n)\n        for i in range(n):\n            argexp[i] = np.dot(resid[i, :], argresid[:, i])\n        dval = np.exp(-0.5 * argexp) / np.sqrt(\n            ((2 * np.pi) ** nvars) * spla.det(cov_mat)\n        )\n        return cast(np.ndarray, dval)\n</code></pre>"},{"location":"bsstats.html#bs_python_utils.bsstats.emcee_draw","title":"<code>emcee_draw(n_samples, log_pdf, p0, params=None, n_burn_in=100, seed=8754)</code>","text":"<p>uses MCMC to draw <code>n_samples</code> samples from the log pdf with given parameters</p> <p>Parameters:</p> Name Type Description Default <code>n_samples</code> <code>int</code> <p>the number of samples to draw</p> required <code>log_pdf</code> <code>Callable[[ndarray, list], float]</code> <p>the log of the pdf, <code>log_pdf(x, *params)</code>; retuns a float from the array for one sample</p> required <code>p0</code> <code>ndarray</code> <p>the initial values for the walkers</p> required <code>params</code> <code>list | None</code> <p>a list of parameters</p> <code>None</code> <code>n_burn_in</code> <code>int | None</code> <p>the number of burn-in iterations for MCMC</p> <code>100</code> <code>seed</code> <code>int | None</code> <p>to randomly draw the samples from the walkers</p> <code>8754</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>an <code>(n_samples, n_dims)</code> array of samples.</p> Warning <p>The <code>log_pdf</code> function should return minus infinity outside of the support of the pdf, and <code>p0</code> should be contained in that support.</p> Source code in <code>bs_python_utils/bsstats.py</code> <pre><code>def emcee_draw(\n    n_samples: int,\n    log_pdf: Callable[[np.ndarray, list], float],\n    p0: np.ndarray,\n    params: list | None = None,\n    n_burn_in: int | None = 100,\n    seed: int | None = 8754,\n) -&gt; np.ndarray:\n    \"\"\"uses MCMC to draw `n_samples` samples from the log pdf with given parameters\n\n    Args:\n        n_samples: the number of samples to draw\n        log_pdf: the log of the pdf, `log_pdf(x, *params)`;\n            retuns a float from the array for one sample\n        p0: the initial values for the walkers\n        params: a list of parameters\n        n_burn_in: the number of burn-in iterations for MCMC\n        seed: to randomly draw the samples from the walkers\n\n    Returns:\n        an `(n_samples, n_dims)` array of samples.\n\n    Warning:\n        The `log_pdf` function should return minus infinity\n        outside of the support of the pdf, and `p0` should be contained\n        in that support.\n    \"\"\"\n    n_walkers, n_dims = p0.shape\n    # burn in\n    sampler = EnsembleSampler(n_walkers, n_dims, log_pdf, args=params)\n    state = sampler.run_mcmc(p0, n_burn_in)\n    sampler.reset()\n    # generate the samples\n    sampler.run_mcmc(state, n_samples)\n    samples = sampler.get_chain(flat=True)\n    rng = np.random.default_rng(seed)\n    samples = rng.choice(samples, size=n_samples, replace=False)\n    return cast(np.ndarray, samples)\n</code></pre>"},{"location":"bsstats.html#bs_python_utils.bsstats.estimate_pdf","title":"<code>estimate_pdf(x_obs, x_points, MIN_SIZE_NONPAR=200, weights=None)</code>","text":"<p>return an estimate of the conditional densities of <code>x</code> at points <code>values_x</code> (Silverman rule)</p> <p>Parameters:</p> Name Type Description Default <code>x_obs</code> <code>ndarray</code> <p>an <code>n</code>-vector or an <code>(n, nvars)</code> matrix of the observed values of <code>x</code></p> required <code>x_points</code> <code>ndarray</code> <p>an <code>m</code>-vector or an <code>(m, nvars)</code> matrix of x values</p> required <code>MIN_SIZE_NONPAR</code> <code>int</code> <p>minimum size above which we use kernel density estimators</p> <code>200</code> <code>weights</code> <code>ndarray | None</code> <p>an <code>n</code>-vector of weights for the observations, if present</p> <code>None</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>the density estimates at <code>values_x</code></p> Source code in <code>bs_python_utils/bsstats.py</code> <pre><code>def estimate_pdf(\n    x_obs: np.ndarray,\n    x_points: np.ndarray,\n    MIN_SIZE_NONPAR: int = 200,\n    weights: np.ndarray | None = None,\n) -&gt; np.ndarray:\n    \"\"\"return an estimate of the conditional densities of `x` at points `values_x` (Silverman rule)\n\n    Args:\n        x_obs: an `n`-vector or an `(n, nvars)` matrix of the observed values of `x`\n        x_points: an `m`-vector or an `(m, nvars)` matrix of x values\n        MIN_SIZE_NONPAR: minimum size above which we use kernel density estimators\n        weights: an `n`-vector of weights for the observations, if present\n\n    Returns:\n        the density estimates at `values_x`\n    \"\"\"\n    ndims_x = check_vector_or_matrix(x_obs, \"estimate_pdf\")\n    ndims_valx = check_vector_or_matrix(x_points, \"estimate_pdf\")\n\n    if ndims_x == 1:\n        n_obs = x_obs.size\n        if ndims_valx != 1:\n            bs_error_abort(f\"x_points should have one dimension, not {ndims_valx}\")\n        xt_obs = x_obs.reshape((-1, 1))\n        nvars = 1\n        xt_points = x_points.reshape((-1, 1))\n    else:  # ndims_x == 2\n        n_obs, nvars = x_obs.shape\n        if ndims_valx == 1:  # only one x point with  nv elements\n            nv = x_points.size\n        else:  # several x points with  nv elements\n            nv = x_points.shape[1]\n        if nv != nvars:\n            bs_error_abort(f\"x_points should have {nvars} variables, not {nv}\")\n        xt_obs = x_obs\n        xt_points = x_points\n\n    if weights is not None:\n        n_w = check_vector(weights, \"estimate_pdf\")\n        if n_w != n_obs:\n            bs_error_abort(\n                f\"if weights is given, it should be a vector of size {n_obs} not {n_w}\"\n            )\n\n    min_size_np = MIN_SIZE_NONPAR ** ((4.0 + nvars) / 5.0)\n\n    if n_obs &gt; min_size_np:  # cell large enough to use nonparametrics\n        # fit joint density of x\n        kde = sts.gaussian_kde(xt_obs.T, bw_method=\"silverman\", weights=weights)\n        # density of x at values_x\n        f_x = kde.evaluate(xt_points.T)\n    else:\n        # sample too small, we fit a normal\n        if ndims_x == 1:  # univariate\n            mean_x = np.mean(x_obs)\n            var_x = np.var(x_obs)\n            f_x = bs_multivariate_normal_pdf(x_points, mean_x, var_x)\n        else:  # multivariate\n            means_x = np.mean(x_obs, 0)\n            cov_mat = np.cov(x_obs.T)\n            f_x = bs_multivariate_normal_pdf(x_points, means_x, cov_mat)\n        if weights is not None:\n            f_x *= weights / np.mean(weights)\n    return cast(np.ndarray, f_x)\n</code></pre>"},{"location":"bsstats.html#bs_python_utils.bsstats.flexible_reg","title":"<code>flexible_reg(Y, X, mode='NP', var_types=None, n_sub=None, n_res=1, verbose=False)</code>","text":"<p>flexible regression  of <code>Y</code> on <code>X</code></p> <p>Parameters:</p> Name Type Description Default <code>Y</code> <code>ndarray</code> <p>independent variable <code>(nobs)</code> or <code>(nobs, ny)</code></p> required <code>X</code> <code>ndarray</code> <p>covariates <code>(nobs)</code> or <code>(nobs, nx)</code>; should not include a constant term</p> required <code>mode</code> <code>str</code> <p>what flexible means * 'NP': non parametric * 'SPL': spline regression, only on one covariate * '1': linear * '2': quadratic</p> <code>'NP'</code> <code>var_types</code> <code>str | None</code> <p>[for 'NP' only]  specify types of all <code>X</code> variables if not all of them are continuous;  one character per variable * 'c' for continuous * 'u' discrete unordered * 'o' discrete ordered</p> <code>None</code> <code>n_sub</code> <code>int | None</code> <p>[for 'NP' only] size of subsample for cross-validation;             by default it is <code>200^{(m+4)/5}</code></p> <code>None</code> <code>n_res</code> <code>int</code> <p>[for 'NP' only] how many subsamples we draw; 1 if <code>None</code></p> <code>1</code> <code>verbose</code> <code>bool</code> <p>prints stuff if True</p> <code>False</code> <p>Returns:</p> Type Description <code>ndarray</code> <p><code>E(y|X)</code> at the sample points</p> Source code in <code>bs_python_utils/bsstats.py</code> <pre><code>def flexible_reg(\n    Y: np.ndarray,\n    X: np.ndarray,\n    mode: str = \"NP\",\n    var_types: str | None = None,\n    n_sub: int | None = None,\n    n_res: int = 1,\n    verbose: bool = False,\n) -&gt; np.ndarray:\n    \"\"\"flexible regression  of `Y` on `X`\n\n    Args:\n        Y: independent variable `(nobs)` or `(nobs, ny)`\n        X: covariates `(nobs)` or `(nobs, nx)`; should **not** include a constant term\n        mode: what flexible means\n            * 'NP': non parametric\n            * 'SPL': spline regression, only on one covariate\n            * '1': linear\n            * '2': quadratic\n        var_types: [for 'NP' only]  specify types of all `X` variables if not all of them are continuous; \n            one character per variable\n            * 'c' for continuous\n            * 'u' discrete unordered\n            * 'o' discrete ordered\n        n_sub: [for 'NP' only] size of subsample for cross-validation; \\\n            by default it is `200^{(m+4)/5}`\n        n_res: [for 'NP' only] how many subsamples we draw; 1 if `None`\n        verbose: prints stuff if True\n\n    Returns: \n        `E(y|X)` at the sample points\n    \"\"\"\n    if mode == \"NP\":\n        if Y.ndim == 2:\n            ny = Y.shape[1]\n            Y_fit = np.zeros_like(Y)\n            for iy in range(ny):\n                Y_fit[:, iy] = reg_nonpar_fit(\n                    Y[:, iy],\n                    X,\n                    var_types=var_types,\n                    n_sub=n_sub,\n                    n_res=n_res,\n                    verbose=verbose,\n                )\n            return Y_fit\n        else:\n            return reg_nonpar_fit(\n                Y, X, var_types=var_types, n_sub=n_sub, n_res=n_res, verbose=verbose\n            )\n    elif mode == \"SPL\":\n        if X.ndim &gt; 1:\n            bs_error_abort(\"with a spline, only works in one dimension\")\n        return spline_reg(Y, X)\n    else:\n        try:\n            imode = int(mode)\n        except TypeError:\n            bs_error_abort(f\"does not accept mode={mode}\")\n        preg, _, _ = proj_Z(Y, X, p=imode, verbose=verbose)\n        return preg\n</code></pre>"},{"location":"bsstats.html#bs_python_utils.bsstats.kde_resample","title":"<code>kde_resample(data, n_samples, n_bw=10)</code>","text":"<p>Fit a nonparametric density to data by KDE, with cross-validation with starting point at rule of thumb, and generate samples from the estimated density.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>ndarray</code> <p>an <code>(n_obs, n_dims)</code> matrix of data</p> required <code>n_samples</code> <code>int</code> <p>how many iid draws we want</p> required <code>n_bw</code> <code>int</code> <p>how mamy bandwidths we try from 1/10th to 10 times the rule-of-thumb</p> <code>10</code> <p>Returns:</p> Type Description <code>tuple[ndarray, float]</code> <p>an <code>(n_samples, n_dims)</code> matrix of draws, and the bandwidth used.</p> Source code in <code>bs_python_utils/bsstats.py</code> <pre><code>def kde_resample(\n    data: np.ndarray, n_samples: int, n_bw: int = 10\n) -&gt; tuple[np.ndarray, float]:\n    \"\"\"Fit a nonparametric density to data by KDE, with cross-validation with starting point at rule of thumb,\n    and generate samples from the estimated density.\n\n    Args:\n        data: an `(n_obs, n_dims)` matrix of data\n        n_samples: how many iid draws we want\n        n_bw: how mamy bandwidths we try from 1/10th to 10 times the rule-of-thumb\n\n    Returns:\n        an `(n_samples, n_dims)` matrix of draws, and the bandwidth used.\n    \"\"\"\n    n_obs, n_dims = check_matrix(data)\n    h_rot = np.std(data) * (n_obs ** (-1 / (n_dims + 4)))\n    params = {\"bandwidth\": h_rot * np.logspace(-1, 1, n_bw)}\n    grid = GridSearchCV(KernelDensity(), params)\n    grid.fit(data)\n    kde = grid.best_estimator_\n    best_bandwidth = grid.best_params_[\"bandwidth\"]\n    resampled_data = kde.sample(n_samples)\n    return resampled_data, best_bandwidth\n</code></pre>"},{"location":"bsstats.html#bs_python_utils.bsstats.proj_Z","title":"<code>proj_Z(W, Z, p=1, verbose=False)</code>","text":"<p>project <code>W</code> on all interactions of degree <code>p</code> or less of <code>Z</code></p> <p>Parameters:</p> Name Type Description Default <code>W</code> <code>ndarray</code> <p>variable(s) <code>(nobs)</code> or <code>(nobs, nw)</code></p> required <code>Z</code> <code>ndarray</code> <p>instruments <code>(nobs) or</code>(nobs, nz)`; they should not include a constant term</p> required <code>p</code> <code>int</code> <p>maximum total degree for interactions of the columns of <code>Z</code></p> <code>1</code> <code>verbose</code> <code>bool</code> <p>prints stuff if True</p> <code>False</code> <p>Returns:</p> Type Description <code>tuple[ndarray, ndarray, float]</code> <p>the projections of the columns of <code>W</code> on <code>Z</code> etc, the coefficients, and the <code>R^2</code> of each column</p> Source code in <code>bs_python_utils/bsstats.py</code> <pre><code>def proj_Z(\n    W: np.ndarray, Z: np.ndarray, p: int = 1, verbose: bool = False\n) -&gt; tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"project `W` on all interactions of degree `p` or less of `Z`\n\n    Args:\n        W: variable(s) `(nobs)` or `(nobs, nw)`\n        Z: instruments `(nobs) or `(nobs, nz)`;\n            they should **not** include a constant term\n        p: maximum total degree for interactions of the columns of `Z`\n        verbose: prints stuff if True\n\n    Returns:\n        the projections of the columns of `W` on `Z` etc, the coefficients, and the `R^2` of each column\n    \"\"\"\n    nobs = Z.shape[0]\n    if W.shape[0] != nobs:\n        bs_error_abort(\"W and Z should have the same number of rows\")\n    if W.ndim &gt; 2:\n        bs_error_abort(\"W should have 1 or 2 dimensions\")\n    if Z.ndim &gt; 2:\n        bs_error_abort(\"Z should have 1 or 2 dimensions\")\n\n    if Z.ndim == 1:\n        Zp = np.zeros((nobs, 1 + p))\n        Zp[:, 0] = np.ones(nobs)\n        for q in range(1, p + 1):\n            Zp[:, q] = Z**q\n    else:  # Z is a matrix\n        Zp, k = _make_Zp(Z, p)\n        if verbose:\n            print(f\"_proj_Z with degree {p}, using {k} regressors\")\n\n    return _final_proj(Zp, W)\n</code></pre>"},{"location":"bsstats.html#bs_python_utils.bsstats.reg_nonpar","title":"<code>reg_nonpar(y, X, var_types=None, n_sub=None, n_res=1)</code>","text":"<p>nonparametric regression of y on the columns of X; the bandwidth is chosen on a subsample of size <code>nsub</code> if <code>nsub</code> &lt; <code>nobs</code>, and rescaled.</p> <p>Parameters:</p> Name Type Description Default <code>y</code> <code>ndarray</code> <p>a vector of size nobs</p> required <code>X</code> <code>ndarray</code> <p>a (nobs) vector or a matrix of shape (nobs, m)</p> required <code>var_types</code> <code>str | None</code> <p>specify types of all <code>X</code> variables if not all of them are continuous; one character per variable</p> <ul> <li>'c' for continuous</li> <li>'u' discrete unordered</li> <li>'o' discrete ordered.</li> </ul> <code>None</code> <code>n_sub</code> <code>int | None</code> <p>size of subsample for cross-validation;  by default it is <code>200^{(m+4)/5}</code></p> <code>None</code> <code>n_res</code> <code>int | None</code> <p>how many subsamples we draw; 1 by default</p> <code>1</code> <p>Returns:</p> Type Description <code>KernelReg</code> <p>fitted on sample (nobs, with derivatives)</p> <code>ndarray</code> <p>and bandwidths (m)</p> Source code in <code>bs_python_utils/bsstats.py</code> <pre><code>def reg_nonpar(\n    y: np.ndarray,\n    X: np.ndarray,\n    var_types: str | None = None,\n    n_sub: int | None = None,\n    n_res: int | None = 1,\n) -&gt; tuple[KernelReg, np.ndarray]:\n    \"\"\"nonparametric regression of y on the columns of X;\n    the bandwidth is chosen on a subsample of size `nsub` if `nsub` &lt; `nobs`, and rescaled.\n\n    Args:\n        y: a vector of size nobs\n        X: a (nobs) vector or a matrix of shape (nobs, m)\n        var_types: specify types of all `X` variables if not all of them are continuous; one character per variable\n\n            * 'c' for continuous\n            * 'u' discrete unordered\n            * 'o' discrete ordered.\n        n_sub: size of subsample for cross-validation;  by default it is `200^{(m+4)/5}`\n        n_res: how many subsamples we draw; 1 by default\n\n    Returns:\n        fitted on sample (nobs, with derivatives)\n        and bandwidths (m)\n    \"\"\"\n    _ = check_vector_or_matrix(X)\n    n_obs = check_vector(y)\n    if X.shape[0] != n_obs:\n        bs_error_abort(\"X and y should have the same number of observations\")\n    m = 1 if X.ndim == 1 else X.shape[1]\n    if var_types is None:\n        types = \"c\" * m\n    else:\n        if len(var_types) != m:\n            bs_error_abort(\"var_types should have one entry for each column of X\")\n        types = var_types\n\n    if n_sub is None:\n        n_sub = round(200 ** ((m + 4.0) / 5.0))\n\n    k = KernelReg(\n        y,\n        X,\n        var_type=types,\n        defaults=EstimatorSettings(\n            efficient=True, n_sub=n_sub, randomize=True, n_res=n_res\n        ),\n    )\n    return k.fit(), k.bw\n</code></pre>"},{"location":"bsstats.html#bs_python_utils.bsstats.reg_nonpar_fit","title":"<code>reg_nonpar_fit(y, X, var_types=None, n_sub=None, n_res=1, verbose=False)</code>","text":"<p>nonparametric regression of y on the columns of X; the bandwidth is chosen on a subsample of size <code>nsub</code> if <code>nsub</code> &lt; <code>nobs</code>, and rescaled.</p> <p>Parameters:</p> Name Type Description Default <code>y</code> <code>ndarray</code> <p>a vector of size nobs</p> required <code>X</code> <code>ndarray</code> <p>a (nobs) vector or a matrix of shape (nobs, m)</p> required <code>var_types</code> <code>str | None</code> <p>specify types of all <code>X</code> variables if not all of them are continuous; one character per variable</p> <ul> <li>'c' for continuous</li> <li>'u' discrete unordered</li> <li>'o' discrete ordered.</li> </ul> <code>None</code> <code>n_sub</code> <code>int | None</code> <p>size of subsample for cross-validation; by default it is <code>200^{(m+4)/5}</code></p> <code>None</code> <code>n_res</code> <code>int</code> <p>how many subsamples we draw; 1 by default</p> <code>1</code> <code>verbose</code> <code>bool</code> <p>prints stuff if True</p> <code>False</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>fitted values on sample (nobs)</p> Source code in <code>bs_python_utils/bsstats.py</code> <pre><code>def reg_nonpar_fit(\n    y: np.ndarray,\n    X: np.ndarray,\n    var_types: str | None = None,\n    n_sub: int | None = None,\n    n_res: int = 1,\n    verbose: bool = False,\n) -&gt; np.ndarray:\n    \"\"\"nonparametric regression of y on the columns of X; the bandwidth is chosen on a subsample of size `nsub` if `nsub` &lt; `nobs`, and rescaled.\n\n    Args:\n        y: a vector of size nobs\n        X: a (nobs) vector or a matrix of shape (nobs, m)\n        var_types: specify types of all `X` variables if not all of them are continuous; one character per variable\n\n            * 'c' for continuous\n            * 'u' discrete unordered\n            * 'o' discrete ordered.\n        n_sub: size of subsample for cross-validation; by default it is `200^{(m+4)/5}`\n        n_res: how many subsamples we draw; 1 by default\n        verbose: prints stuff if True\n\n    Returns:\n        fitted values on sample (nobs)\n    \"\"\"\n    kfbw = reg_nonpar(y, X, var_types, n_sub, n_res)\n    fitted_vals = cast(np.ndarray, kfbw[0][0])\n    return fitted_vals\n</code></pre>"},{"location":"bsstats.html#bs_python_utils.bsstats.tsls","title":"<code>tsls(y, X, Z)</code>","text":"<p>TSLS of <code>y</code> on <code>X</code> with instruments <code>Z</code></p> <p>Parameters:</p> Name Type Description Default <code>y</code> <code>ndarray</code> <p>independent variable <code>(nobs)</code></p> required <code>X</code> <code>ndarray</code> <p>covariates <code>(nobs, nx)</code></p> required <code>Z</code> <code>ndarray</code> <p>instruments <code>(nobs, nz)</code></p> required <p>Returns:</p> Type Description <code>TslsResults</code> <p>a <code>tsls_results</code> object</p> Source code in <code>bs_python_utils/bsstats.py</code> <pre><code>def tsls(y: np.ndarray, X: np.ndarray, Z: np.ndarray) -&gt; TslsResults:\n    \"\"\"TSLS of `y` on `X` with instruments `Z`\n\n    Args:\n        y: independent variable `(nobs)`\n        X: covariates `(nobs, nx)`\n        Z: instruments `(nobs, nz)`\n\n    Returns:\n        a `tsls_results` object\n    \"\"\"\n    # first stage\n    X_IV_proj, b_proj_IV, r2_first_iv = proj_Z(X, Z)\n    # second stage\n    y_proj, y_coeffs, r2_y = proj_Z(y, Z)\n    _, iv_estimates, r2_second = proj_Z(y_proj, X_IV_proj)\n    return TslsResults(\n        iv_estimates,\n        r2_first_iv,\n        r2_y,\n        r2_second,\n        y_proj,\n        y_coeffs,\n        X_IV_proj,\n        b_proj_IV,\n    )\n</code></pre>"},{"location":"bsutils.html","title":"bsutils module","text":"<p>Contains various utilities programs:</p> <ul> <li><code>printargs</code>: a decorator that reports the arguments of the function it decorates</li> <li><code>bs_name_func</code>: returns the name of the current function or its callers</li> <li><code>bs_error_abort</code>: reports on error and aborts execution</li> <li><code>final_s</code>: whether a word should have a final 's'</li> <li><code>bs_switch</code>: an improved <code>switch</code> statement</li> <li><code>find_first</code>: returns the index of and the first item in an iterable that satisfies a condition</li> <li><code>print_stars</code>: prints a title within lines of stars</li> <li><code>file_print_stars</code>: does the same, to a file</li> <li><code>fstring_integer_with_significant_digits</code>: rounds an integer and returns an f-string</li> <li><code>mkdir_if_needed</code>: creates a directory if it does not exist</li> <li><code>bscomb</code>: a combination \\({n \\choose k}\\) operator</li> <li><code>bslog, bsxlogx, bsexp</code>: \\(C^2\\) extensions of \\(\\log(x), x\\log x, \\exp(x)\\), and their first two derivatives</li> <li><code>bs_projection_point</code>: projects a point on a line in the plane.</li> </ul> Note <p>if the math looks strange in the documentation, just reload the page.</p>"},{"location":"bsutils.html#bs_python_utils.bsutils.bs_error_abort","title":"<code>bs_error_abort(msg='error, aborting')</code>","text":"<p>report error and abort</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>str</code> <p>a message</p> <code>'error, aborting'</code> <p>Returns:</p> Type Description <code>None</code> <p>prints the message and exits with code 1</p> Source code in <code>bs_python_utils/bsutils.py</code> <pre><code>def bs_error_abort(msg: str = \"error, aborting\") -&gt; None:\n    \"\"\"\n    report error and abort\n\n    Args:\n        msg: a message\n\n    Returns:\n        prints the message and exits with code 1\n    \"\"\"\n    print_stars(f\"{bs_name_func(3)}: {msg}\")\n    sys.exit(1)\n</code></pre>"},{"location":"bsutils.html#bs_python_utils.bsutils.bs_name_func","title":"<code>bs_name_func(back=2)</code>","text":"<p>get the name of the current function, or further back in stack</p> <p>Parameters:</p> Name Type Description Default <code>back</code> <code>int</code> <p>2 is current function, 3 the function that called it etc</p> <code>2</code> <p>Returns:</p> Type Description <code>str</code> <p>the name of the function</p> Source code in <code>bs_python_utils/bsutils.py</code> <pre><code>def bs_name_func(back: int = 2) -&gt; str:\n    \"\"\"\n    get the name of the current function, or further back in stack\n\n    Args:\n        back: 2 is current function, 3 the function that called it etc\n\n    Returns:\n        the name of the function\n    \"\"\"\n    stack = traceback.extract_stack()\n    *_, func_name, _ = stack[-back]\n    return cast(str, func_name)\n</code></pre>"},{"location":"bsutils.html#bs_python_utils.bsutils.bs_projection_point","title":"<code>bs_projection_point(x, y, a, b, c)</code>","text":"<p>projection of point (x,y) on line ax+by+c=0</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>y: coordinates</p> required <code>a</code> <code>float</code> <p>b: c: line parameters (as in ax+by+c=0)</p> required <p>Returns:</p> Name Type Description <code>x_proj</code> <code>float</code> <p>y_proj: coordinates of projection point</p> <code>dist</code> <code>float</code> <p>distance of point from line</p> Source code in <code>bs_python_utils/bsutils.py</code> <pre><code>def bs_projection_point(\n    x: float, y: float, a: float, b: float, c: float\n) -&gt; tuple[float, float, float]:\n    \"\"\"\n    projection of point (x,y) on line ax+by+c=0\n\n    Args:\n        x: y: coordinates\n        a: b: c: line parameters (as in ax+by+c=0)\n\n    Returns:\n        x_proj: y_proj: coordinates of projection point\n        dist: distance of point from line\n    \"\"\"\n    a2b2 = a * a + b * b\n    denom = sqrt(a2b2)\n    value = a * x + b * y + c\n    x_proj = x - a * value / a2b2\n    y_proj = y - b * value / a2b2\n    dist = abs(value) / denom\n    return x_proj, y_proj, dist\n</code></pre>"},{"location":"bsutils.html#bs_python_utils.bsutils.bs_switch","title":"<code>bs_switch(match, dico, strict=True, default='no match')</code>","text":"<p>a switch statement that allows for partial matches if strict is False</p> <p>Parameters:</p> Name Type Description Default <code>match</code> <code>str</code> <p>what we look for in the keys</p> required <code>dico</code> <code>dict</code> <p>a dictionary with string keys</p> required <code>strict</code> <code>bool</code> <p>if <code>False</code>, we accept a partial match</p> <code>True</code> <code>default</code> <code>Any</code> <p>what we return if no match is found</p> <code>'no match'</code> <p>Returns:</p> Type Description <code>Any</code> <p>the value for the match, or <code>default</code></p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; calc_dict = {\n\"plus\": lambda x, y: x + y,\n\"minus\": lambda x, y: x - y\n}\n&gt;&gt;&gt; plus = bs_switch('plus', calc_dict, default=\"unintended function\")\n&gt;&gt;&gt; minus = bs_switch('min', calc_dict, strict=False, default=\"unintended function\")\n&gt;&gt;&gt; plus(6, 4)\n10\n&gt;&gt;&gt; minus(6, 4)\n2\n&gt;&gt;&gt; bs_switch('plu', calc_dict)\n\"no match\"\n</code></pre> Source code in <code>bs_python_utils/bsutils.py</code> <pre><code>def bs_switch(\n    match: str, dico: dict, strict: bool = True, default: Any = \"no match\"\n) -&gt; Any:\n    \"\"\"\n    a switch statement that allows for partial matches if strict is False\n\n    Args:\n        match: what we look for in the keys\n        dico: a dictionary with string keys\n        strict: if `False`, we accept a partial match\n        default: what we return if no match is found\n\n    Returns:\n        the value for the match, or `default`\n\n    Examples:\n        &gt;&gt;&gt; calc_dict = {\n        \"plus\": lambda x, y: x + y,\n        \"minus\": lambda x, y: x - y\n        }\n        &gt;&gt;&gt; plus = bs_switch('plus', calc_dict, default=\"unintended function\")\n        &gt;&gt;&gt; minus = bs_switch('min', calc_dict, strict=False, default=\"unintended function\")\n        &gt;&gt;&gt; plus(6, 4)\n        10\n        &gt;&gt;&gt; minus(6, 4)\n        2\n        &gt;&gt;&gt; bs_switch('plu', calc_dict)\n        \"no match\"\n    \"\"\"\n    if strict:\n        for key in dico:\n            if match == key:\n                return dico.get(key)\n    else:\n        for key in dico:\n            if match in key:\n                return dico.get(key)\n    return default\n</code></pre>"},{"location":"bsutils.html#bs_python_utils.bsutils.bscomb","title":"<code>bscomb(n, k)</code>","text":"<p>number of combinations of k among n <code>{n \\choose k}</code></p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> required <code>k</code> <code>int</code> <p>should be smaller than n</p> required <p>Returns:</p> Type Description <code>int</code> <p><code>{n \\choose k}</code>.</p> Source code in <code>bs_python_utils/bsutils.py</code> <pre><code>def bscomb(n: int, k: int) -&gt; int:\n    \"\"\"\n    number of combinations of k among n `{n \\\\choose k}`\n\n    Args:\n        n:\n        k: should be smaller than n\n\n    Returns:\n        `{n \\\\choose k}`.\n    \"\"\"\n    if not isinstance(n, int):\n        bs_error_abort(f\"n should be an integer, not {n}\")\n    if not isinstance(k, int):\n        bs_error_abort(f\"k should be an integer, not {k}\")\n    if n &lt; k:\n        bs_error_abort(f\"k={k} should not be larger than n={n}\")\n    return factorial(n) // (factorial(k) * factorial(n - k))\n</code></pre>"},{"location":"bsutils.html#bs_python_utils.bsutils.bsexp","title":"<code>bsexp(x, bigx=50.0, lowx=-50.0, deriv=0)</code>","text":"<p><code>C^2</code>-extends the exponential above <code>bigx</code> and below <code>lowx</code> perhaps with derivatives</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>argument</p> required <code>bigx</code> <code>float</code> <p>upper bound</p> <code>50.0</code> <code>lowx</code> <code>float</code> <p>lower bound</p> <code>-50.0</code> <code>deriv</code> <code>int</code> <p>if 1, also return first derivative; if 2, the first two derivatives</p> <code>0</code> <p>Returns:</p> Type Description <code>float | TwoFloats | ThreeFloats</code> <p>the exponential <code>C^2</code>-extended above <code>bigx</code> and below <code>lowx</code></p> <code>float | TwoFloats | ThreeFloats</code> <p>perhaps with derivatives</p> Source code in <code>bs_python_utils/bsutils.py</code> <pre><code>def bsexp(\n    x: float,\n    bigx: float = 50.0,\n    lowx: float = -50.0,\n    deriv: int = 0,\n) -&gt; float | TwoFloats | ThreeFloats:\n    \"\"\"\n    `C^2`-extends the exponential above `bigx` and below `lowx`\n    perhaps with derivatives\n\n    Args:\n        x: argument\n        bigx: upper bound\n        lowx: lower bound\n        deriv: if 1, also return first derivative; if 2, the first two derivatives\n\n    Returns:\n        the exponential `C^2`-extended above `bigx` and below `lowx`\n        perhaps with derivatives\n    \"\"\"\n    if deriv not in [0, 1, 2]:\n        bs_error_abort(f\"deriv can only be 0, 1, or 2; not {deriv}\")\n    if lowx &lt; x &lt; bigx:\n        expx = exp(x)\n        if deriv == 0:\n            return expx\n        if deriv == 1:\n            return expx, expx\n        return expx, expx, expx\n    elif x &lt; lowx:\n        return _bsexp_extend(x, deriv, lowx)\n    else:\n        return _bsexp_extend(x, deriv, bigx)\n</code></pre>"},{"location":"bsutils.html#bs_python_utils.bsutils.bslog","title":"<code>bslog(x, eps=1e-30, deriv=0)</code>","text":"<p>extends the logarithm below <code>eps</code> by taking a second-order approximation perhaps with derivatives</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>argument</p> required <code>eps</code> <code>float</code> <p>lower bound</p> <code>1e-30</code> <code>deriv</code> <code>int</code> <p>if 1, also return first derivative; if 2, the first two derivatives</p> <code>0</code> <p>Returns:</p> Type Description <code>float | TwoFloats | ThreeFloats</code> <p><code>\\ln(x)</code> <code>C^2</code>-extended below <code>eps</code>, perhaps with derivatives</p> Source code in <code>bs_python_utils/bsutils.py</code> <pre><code>def bslog(\n    x: float, eps: float = 1e-30, deriv: int = 0\n) -&gt; float | TwoFloats | ThreeFloats:\n    \"\"\"\n    extends the logarithm below `eps` by taking a second-order approximation\n    perhaps with derivatives\n\n    Args:\n        x: argument\n        eps: lower bound\n        deriv: if 1, also return first derivative; if 2, the first two derivatives\n\n    Returns:\n        `\\\\ln(x)` `C^2`-extended below `eps`, perhaps with derivatives\n    \"\"\"\n    if deriv not in [0, 1, 2]:\n        bs_error_abort(f\"deriv can only be 0, 1, or 2; not {deriv}\")\n    if x &gt; eps:\n        logx = log(x)\n        if deriv == 0:\n            return logx\n        dlogx = 1.0 / x\n        if deriv == 1:\n            return logx, dlogx\n        d2logx = -dlogx * dlogx\n        return logx, dlogx, d2logx\n    else:\n        dx = 1.0 - x / eps\n        log_smaller = log(eps) - dx - dx * dx / 2.0\n        if deriv == 0:\n            return log_smaller\n        dlog_smaller = (1.0 + dx) / eps\n        if deriv == 1:\n            return log_smaller, dlog_smaller\n        d2log_smaller = -1.0 / eps / eps\n        return log_smaller, dlog_smaller, d2log_smaller\n</code></pre>"},{"location":"bsutils.html#bs_python_utils.bsutils.bsxlogx","title":"<code>bsxlogx(x, eps=1e-30, deriv=0)</code>","text":"<p>extends <code>x \\ln(x)</code> below <code>eps</code> by making it go to zero in a <code>C^2</code> extension perhaps with derivatives</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>argument</p> required <code>eps</code> <code>float</code> <p>lower bound</p> <code>1e-30</code> <code>deriv</code> <code>int</code> <p>if 1, also return first derivative; if 2, the first two derivatives</p> <code>0</code> <p>Returns:</p> Type Description <code>float | TwoFloats | ThreeFloats</code> <p><code>x \\ln(x)</code> <code>C^2</code>-extended below <code>eps</code>, perhaps with derivatives</p> Source code in <code>bs_python_utils/bsutils.py</code> <pre><code>def bsxlogx(\n    x: float, eps: float = 1e-30, deriv: int = 0\n) -&gt; float | TwoFloats | ThreeFloats:\n    \"\"\"\n    extends `x \\\\ln(x)` below `eps` by making it go to zero in a `C^2` extension\n    perhaps with derivatives\n\n    Args:\n        x: argument\n        eps: lower bound\n        deriv: if 1, also return first derivative; if 2, the first two derivatives\n\n    Returns:\n        `x \\\\ln(x)`  `C^2`-extended below `eps`, perhaps with derivatives\n    \"\"\"\n    if deriv not in [0, 1, 2]:\n        bs_error_abort(f\"deriv can only be 0, 1, or 2; not {deriv}\")\n    if x &gt; eps:\n        logx = log(x)\n        if deriv == 0:\n            return x * logx\n        if deriv == 1:\n            return x * logx, 1.0 + logx\n        return x * logx, 1.0 + logx, 1.0 / x\n    else:\n        logeps = log(eps)\n        dx = x / eps\n        log_smaller = x * logeps - eps / 2.0 + x * dx / 2.0\n        if deriv == 0:\n            return log_smaller\n        if deriv == 1:\n            return log_smaller, logeps + dx\n        return log_smaller, logeps + dx, 1.0 / eps\n</code></pre>"},{"location":"bsutils.html#bs_python_utils.bsutils.file_print_stars","title":"<code>file_print_stars(file_handle, title=None, n=70)</code>","text":"<p>prints to a file a title within stars</p> <p>Parameters:</p> Name Type Description Default <code>file_handle</code> <code>TextIOBase</code> <p>file handle</p> required <code>title</code> <code>str | None</code> <p>title</p> <code>None</code> <code>n</code> <code>int</code> <p>length of line</p> <code>70</code> <p>Returns:</p> Type Description <code>None</code> <p>prints a starred line to the file, or two around the title</p> Source code in <code>bs_python_utils/bsutils.py</code> <pre><code>def file_print_stars(\n    file_handle: TextIOBase, title: str | None = None, n: int = 70\n) -&gt; None:\n    \"\"\"\n    prints to a file a title within stars\n\n    Args:\n        file_handle: file handle\n        title:  title\n        n:   length of line\n\n    Returns:\n        prints a starred line to the file, or two around the title\n    \"\"\"\n    line_stars = \"*\" * n\n    file_handle.write(\"\\n\")\n    file_handle.write(line_stars)\n    file_handle.write(\"\\n\")\n    if title:\n        file_handle.write(title.center(n))\n        file_handle.write(\"\\n\")\n        file_handle.write(line_stars)\n        file_handle.write(\"\\n\")\n    file_handle.write(\"\\n\")\n</code></pre>"},{"location":"bsutils.html#bs_python_utils.bsutils.final_s","title":"<code>final_s(n, word)</code>","text":"<p>pluralizes word if n &gt; 1</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>how many times</p> required <code>word</code> <code>str</code> <p>to be pluralized, maybe</p> required <p>Returns:</p> Type Description <code>str</code> <p><code>1 word</code> or <code>n words</code></p> Source code in <code>bs_python_utils/bsutils.py</code> <pre><code>def final_s(n: int, word: str) -&gt; str:\n    \"\"\"\n    pluralizes word if n &gt; 1\n\n    Args:\n        n: how many times\n        word: to be pluralized, maybe\n\n    Returns:\n        `1 word` or `n words`\n    \"\"\"\n    suffix = \"s\" if n &gt; 1 else \"\"\n    return f\"{n} {word}{suffix}\"\n</code></pre>"},{"location":"bsutils.html#bs_python_utils.bsutils.find_first","title":"<code>find_first(iterable, condition=lambda : True)</code>","text":"<p>Returns the index of and the first item in the <code>iterable</code> that satisfies the <code>condition</code>.</p> <p>Parameters:</p> Name Type Description Default <code>iterable</code> <code>Iterable</code> <p>where to look</p> required <code>condition</code> <code>Callable</code> <p>must return a boolean</p> <code>lambda : True</code> <p>Returns:</p> Type Description <code>Any</code> <p>If the condition is not given, returns 0 and the first item of</p> <code>Any</code> <p>the iterable.</p> <code>Any</code> <p>Raises <code>StopIteration</code> if no item satisfyng the condition is found.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; find_first( (1,2,3), condition=lambda x: x % 2 == 0)\n(1, 2)\n&gt;&gt;&gt; find_first(range(3, 100))\n(0, 3)\n&gt;&gt;&gt; find_first( () )\nTraceback (most recent call last):\n...\nStopIteration\n</code></pre> Source code in <code>bs_python_utils/bsutils.py</code> <pre><code>def find_first(iterable: Iterable, condition: Callable = lambda x: True) -&gt; Any:\n    \"\"\"\n    Returns the index of and the first item in the `iterable` that\n    satisfies the `condition`.\n\n    Args:\n        iterable: where to look\n        condition: must return a boolean\n\n    Returns:\n        If the condition is not given, returns 0 and the first item of\n        the iterable.\n\n        Raises `StopIteration` if no item satisfyng the condition is found.\n\n    Examples:\n        &gt;&gt;&gt; find_first( (1,2,3), condition=lambda x: x % 2 == 0)\n        (1, 2)\n        &gt;&gt;&gt; find_first(range(3, 100))\n        (0, 3)\n        &gt;&gt;&gt; find_first( () )\n        Traceback (most recent call last):\n        ...\n        StopIteration\n\n\n    \"\"\"\n    return next((i, x) for i, x in enumerate(iterable) if condition(x))\n</code></pre>"},{"location":"bsutils.html#bs_python_utils.bsutils.fstring_integer_with_significant_digits","title":"<code>fstring_integer_with_significant_digits(number, m)</code>","text":"<p>returns an f-string with <code>number</code> rounded to <code>m</code> significant digits</p> <p>Parameters:</p> Name Type Description Default <code>number</code> <code>int</code> <p>the integer we want to round</p> required <code>m</code> <code>int</code> <p>how many digits we keep; the rest is filled with zeroes</p> required Return <p>a string with the rounded integer</p> <p>Examples:</p> <p>fstring_integer_with_significant_digits(12345, 0) ' 0' fstring_integer_with_significant_digits(12345, 3) '12,300' fstring_integer_with_significant_digits(12345, 7) '12345'</p> Source code in <code>bs_python_utils/bsutils.py</code> <pre><code>def fstring_integer_with_significant_digits(number: int, m: int) -&gt; str:\n    \"\"\"returns an f-string with `number` rounded to `m` significant digits\n\n    Args:\n        number: the integer we want to round\n        m:  how many digits we keep; the rest is filled with zeroes\n\n    Return:\n        a string with the rounded integer\n\n    Examples:\n    &gt;&gt;&gt; fstring_integer_with_significant_digits(12345, 0)\n    ' 0'\n    &gt;&gt;&gt; fstring_integer_with_significant_digits(12345, 3)\n    '12,300'\n    &gt;&gt;&gt; fstring_integer_with_significant_digits(12345, 7)\n    '12345'\n    \"\"\"\n    if (not isinstance(number, int)) or (not isinstance(m, int)):\n        bs_error_abort(\"Both arguments should be integers.\")\n    if number == 0:\n        return f\"{number:d}\"\n    else:\n        digits = len(str(abs(int(number))))\n        if digits &lt;= m:\n            return f\"{int(number):d}\"\n        else:\n            power = digits - m\n            rounded = round(number / 10**power) * 10**power\n            return f\"{int(rounded): ,d}\"\n</code></pre>"},{"location":"bsutils.html#bs_python_utils.bsutils.mkdir_if_needed","title":"<code>mkdir_if_needed(p)</code>","text":"<p>create the directory if it does not exist</p> <p>Parameters:</p> Name Type Description Default <code>p</code> <code>Path | str</code> <p>a path</p> required <p>Returns:</p> Type Description <code>Path</code> <p>the directory Path</p> Source code in <code>bs_python_utils/bsutils.py</code> <pre><code>def mkdir_if_needed(p: Path | str) -&gt; Path:\n    \"\"\"\n    create the directory if it does not exist\n\n    Args:\n        p: a path\n\n    Returns:\n        the directory Path\n\n    \"\"\"\n    try:\n        q = Path(p)\n    except OSError:\n        bs_error_abort(f\"{p} is not a path\")\n    if not q.exists():\n        q.mkdir(parents=True)\n    return q\n</code></pre>"},{"location":"bsutils.html#bs_python_utils.bsutils.print_stars","title":"<code>print_stars(title=None, n=70)</code>","text":"<p>prints a title within stars</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str | None</code> <p>title</p> <code>None</code> <code>n</code> <code>int</code> <p>number of stars on line</p> <code>70</code> <p>Returns:</p> Type Description <code>None</code> <p>prints a starred line, or two around the title</p> Source code in <code>bs_python_utils/bsutils.py</code> <pre><code>def print_stars(title: str | None = None, n: int = 70) -&gt; None:\n    \"\"\"\n    prints a title within stars\n\n    Args:\n        title:  title\n        n: number of stars on line\n\n    Returns:\n        prints a starred line, or two around the title\n    \"\"\"\n    line_stars = \"*\" * n\n    print()\n    print(line_stars)\n    if title:\n        print(title.center(n))\n        print(line_stars)\n    print()\n</code></pre>"},{"location":"bsutils.html#bs_python_utils.bsutils.printargs","title":"<code>printargs(func)</code>","text":"<p>Decorator that reports the arguments of the function</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable</code> <p>the decorated function</p> required Source code in <code>bs_python_utils/bsutils.py</code> <pre><code>def printargs(func: Callable) -&gt; Callable:\n    \"\"\"\n    Decorator that reports the arguments of the function\n\n    Args:\n      func: the decorated function\n    \"\"\"\n\n    @wraps(func)\n    def wrapper(*args, **kwargs):\n        print(\n            f\"Function {func.__name__} called with args = {args} and kwargs = {kwargs}\"\n        )\n        return func(*args, **kwargs)\n\n    return wrapper\n</code></pre>"},{"location":"chebyshev.html","title":"chebyshev module","text":"<p>Chebyshev interpolation and integration in 1, 2, and 4 dimensions</p> Note <p>if the math looks strange in the documentation, just reload the page.</p> <ul> <li><code>Interval</code>, <code>Rectangle</code>: basic classes to define the integration domain</li> <li><code>move_from1m1, move_to1m1</code>: rescale to and from the \\([-1,1]\\) interval</li> <li><code>cheb_get_nodes_1d</code>: get Chebyshev nodes and weights on an interval </li> <li><code>cheb_eval_fun_at_nodes_1d</code>: evaluates a function at is nodes on an interval</li> <li><code>cheb_get_coefficients_1d</code>: get the Chebyshev coefficients for a function</li> <li><code>cheb_interp_1d</code>: interpolate a function on an interval given its definition or its coefficients</li> <li><code>cheb_interp_1d_from_nodes</code>: interpolate a function on an interval given its values at the nodes</li> <li><code>cheb_find_root</code>: finds the roots of a function in an interval</li> <li><code>cheb_integrate_from_coeffs_1d</code>: integrates a function given its coefficients</li> <li><code>cheb_integrate_from_nodes_1d</code>: integrates a function given its values at the nodes (less precise)</li> <li><code>cheb_get_nodes_2d</code>: get Chebyshev nodes and weights on a rectangle</li> <li><code>cheb_eval_fun_at_nodes_2d</code>: evaluates a function at is nodes on a rectangle</li> <li><code>cheb_get_coefficients_2d</code>: get the Chebyshev coefficients for a function of 2 arguments</li> <li><code>cheb_interp_2d</code>: interpolate a function on a rectangle given its definition or its coefficients</li> <li><code>cheb_interp_2d_from_nodes</code>: interpolate a function on a rectangle given its values at the nodes</li> <li><code>cheb_integrate_from_nodes_4d</code>: integrate over a product of rectangles given values at the tensor products of the 2d nodes.</li> </ul>"},{"location":"chebyshev.html#bs_python_utils.chebyshev.Interval","title":"<code>Interval</code>  <code>dataclass</code>","text":"<p>a real interval \\([x_0,x_1]\\)</p> Source code in <code>bs_python_utils/chebyshev.py</code> <pre><code>@dataclass\nclass Interval:\n    \"\"\"a real interval $[x_0,x_1]$\"\"\"\n\n    x0: float\n    x1: float\n\n    def __post_init__(self):\n        x0, x1 = self.x0, self.x1\n        if x0 &gt; x1:\n            bs_error_abort(f\"x0 = {x0} is larger than x1 = {x1}\")\n\n    def bounds(self):\n        return self.x0, self.x1\n</code></pre>"},{"location":"chebyshev.html#bs_python_utils.chebyshev.Rectangle","title":"<code>Rectangle</code>  <code>dataclass</code>","text":"<p>a product interval \\([x_0,x_1]   imes [y_0, y_1]\\)</p> Source code in <code>bs_python_utils/chebyshev.py</code> <pre><code>@dataclass\nclass Rectangle:\n    \"\"\"a product interval $[x_0,x_1] \\times [y_0, y_1]$\"\"\"\n\n    x_interval: Interval\n    y_interval: Interval\n</code></pre>"},{"location":"chebyshev.html#bs_python_utils.chebyshev.cheb_eval_fun_at_nodes_1d","title":"<code>cheb_eval_fun_at_nodes_1d(fun, nodes=None, interval=None, degree=None)</code>","text":"<p>evaluate a function at the Chebyshev nodes on an interval</p> <p>Parameters:</p> Name Type Description Default <code>fun</code> <code>ArrayFunctionOfArray</code> <p>the function to evaluate on an interval</p> required <code>nodes</code> <code>ndarray | None</code> <p>the Chebyshev nodes on that interval, if precomputed</p> <code>None</code> <code>interval</code> <code>Interval | None</code> <p>the Interval</p> <code>None</code> <code>degree</code> <code>int | None</code> <p>the degree of the Chebyshev  expansion</p> <code>None</code> Notes <p><code>interval</code>, <code>degree</code> are required if <code>nodes</code> is not provided</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>the values of the function at the Chebyshev nodes</p> Source code in <code>bs_python_utils/chebyshev.py</code> <pre><code>def cheb_eval_fun_at_nodes_1d(\n    fun: ArrayFunctionOfArray,\n    nodes: np.ndarray | None = None,\n    interval: Interval | None = None,\n    degree: int | None = None,\n) -&gt; np.ndarray:\n    \"\"\"evaluate a function at the Chebyshev nodes on an interval\n\n    Args:\n        fun: the function to evaluate on an interval\n        nodes: the Chebyshev nodes on that interval, if precomputed\n        interval: the Interval\n        degree: the degree of the Chebyshev  expansion\n\n    Notes:\n        `interval`, `degree` are required if `nodes` is not provided\n\n    Returns:\n        the values of the function at the Chebyshev nodes\n    \"\"\"\n    if nodes is None:\n        if degree is None or interval is None:\n            bs_error_abort(\"if nodes is not provided, then degree and interval must be\")\n        degree = cast(int, degree)\n        interval = cast(Interval, interval)\n        nodes, _ = cheb_get_nodes_1d(interval, degree)\n    vals_at_nodes = fun(nodes)\n    return vals_at_nodes\n</code></pre>"},{"location":"chebyshev.html#bs_python_utils.chebyshev.cheb_eval_fun_at_nodes_2d","title":"<code>cheb_eval_fun_at_nodes_2d(fun, nodes=None, rectangle=None, degree=None)</code>","text":"<p>evaluate a function at the Chebyshev nodes on a rectangle $</p> <p>Parameters:</p> Name Type Description Default <code>fun</code> <code>ArrayFunctionOfArray</code> <p>the function to evaluate on the rectangle</p> required <code>nodes</code> <code>ndarray | None</code> <p>the Chebyshev nodes on that rectangle, if precomputed</p> <code>None</code> <code>rectangle</code> <code>Rectangle | None</code> <p>the Rectangle</p> <code>None</code> <code>degree</code> <code>int | None</code> <p>the degree of the Chebyshev  expansion in each dimension</p> <code>None</code> Notes <p><code>rectangle</code> and <code>degree</code> are required if <code>nodes</code> is not provided</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>the values of the function at the Chebyshev nodes</p> Source code in <code>bs_python_utils/chebyshev.py</code> <pre><code>def cheb_eval_fun_at_nodes_2d(\n    fun: ArrayFunctionOfArray,\n    nodes: np.ndarray | None = None,\n    rectangle: Rectangle | None = None,\n    degree: int | None = None,\n) -&gt; np.ndarray:\n    \"\"\"evaluate a function at the Chebyshev nodes on a rectangle $\n\n    Args:\n        fun: the function to evaluate on the rectangle\n        nodes: the Chebyshev nodes on that rectangle, if precomputed\n        rectangle: the Rectangle\n        degree: the degree of the Chebyshev  expansion in each dimension\n\n    Notes:\n        `rectangle` and `degree` are required if `nodes` is not provided\n\n    Returns:\n        the values of the function at the Chebyshev nodes\n    \"\"\"\n    if nodes is None:\n        if degree is None or rectangle is None:\n            bs_error_abort(\n                \"if nodes is not provided, then degree and rectangle must be\"\n            )\n        degree = cast(int, degree)\n        rectangle = cast(Rectangle, rectangle)\n        nodes, _ = cheb_get_nodes_2d(rectangle, degree)\n    vals_at_nodes = fun(nodes)\n    return vals_at_nodes\n</code></pre>"},{"location":"chebyshev.html#bs_python_utils.chebyshev.cheb_find_root","title":"<code>cheb_find_root(f, degree, interval=None)</code>","text":"<p>find the roots of \\(f(x)=0\\) in \\([0,1]\\); also return the one(s) within the interval, if given</p> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>ArrayFunctionOfArray</code> <p>the function</p> required <code>degree</code> <code>int</code> <p>the degree of the Chebyshev expansion</p> required <code>interval</code> <code>Interval | None</code> <p>the interval where we want the root</p> <code>None</code> <p>Returns:</p> Type Description <code>ndarray | tuple[ndarray, ndarray | float | None]</code> <p>the roots in \\([0,1]\\);  and the one(s) in <code>interval</code>, if specified</p> Source code in <code>bs_python_utils/chebyshev.py</code> <pre><code>def cheb_find_root(\n    f: ArrayFunctionOfArray, degree: int, interval: Interval | None = None\n) -&gt; np.ndarray | tuple[np.ndarray, np.ndarray | float | None]:\n    \"\"\"find the roots of $f(x)=0$ in $[0,1]$; also return the one(s) within the interval, if given\n\n    Args:\n        f: the function\n        degree: the degree of the Chebyshev expansion\n        interval: the interval where we want the root\n\n    Returns:\n        the roots in $[0,1]$;  and the one(s) in `interval`, if specified\n    \"\"\"\n    interval01 = Interval(0.0, 1.0)\n    coeffs_f = cheb_get_coefficients_1d(f, interval01, degree)\n    roots = cast(np.ndarray, move_from1m1(ncheb.chebroots(coeffs_f), interval01))\n\n    if interval:\n        roots_in_interval = roots[(roots &gt;= interval.x0) &amp; (roots &lt;= interval.x1)]\n        if len(roots_in_interval) == 0:\n            return roots, None\n        elif len(roots_in_interval) == 1:\n            return roots, roots_in_interval[0]\n        else:\n            return roots, roots_in_interval\n    else:\n        return roots\n</code></pre>"},{"location":"chebyshev.html#bs_python_utils.chebyshev.cheb_get_coefficients_1d","title":"<code>cheb_get_coefficients_1d(fun, interval, degree)</code>","text":"<p>get the Chebyshev coefficients for <code>fun</code> on an interval</p> <p>Parameters:</p> Name Type Description Default <code>fun</code> <code>ArrayFunctionOfArray</code> <p>the function</p> required <code>interval</code> <code>Interval</code> <p>the Interval</p> required <code>degree</code> <code>int</code> <p>the degree of the Chebyshev  expansion</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>a <code>degree</code>-vector of coefficients</p> Source code in <code>bs_python_utils/chebyshev.py</code> <pre><code>def cheb_get_coefficients_1d(\n    fun: ArrayFunctionOfArray, interval: Interval, degree: int\n) -&gt; np.ndarray:\n    \"\"\"get the Chebyshev coefficients for `fun` on an interval\n\n    Args:\n        fun: the function\n        interval: the Interval\n        degree: the degree of the Chebyshev  expansion\n\n    Returns:\n        a `degree`-vector of coefficients\n    \"\"\"\n\n    def fun_t(t: np.ndarray) -&gt; np.ndarray:\n        x = cast(np.ndarray, move_from1m1(t, interval))\n        return fun(x)\n\n    c = ncheb.chebinterpolate(fun_t, degree)\n    return cast(np.ndarray, c)\n</code></pre>"},{"location":"chebyshev.html#bs_python_utils.chebyshev.cheb_get_coefficients_2d","title":"<code>cheb_get_coefficients_2d(rectangle, degree, vals_at_nodes=None, fun=None)</code>","text":"<p>get the Chebyshev coefficients for <code>fun</code> on a rectangle, using an OLS fit on the values on the grid of nodes</p> <p>Parameters:</p> Name Type Description Default <code>rectangle</code> <code>Rectangle</code> <p>the Rectangle</p> required <code>degree</code> <code>int</code> <p>the degree of the Chebyshev expansion in each dimension</p> required <code>vals_at_nodes</code> <code>ndarray | None</code> <p>the values on the grid, if precomputed</p> <code>None</code> <code>fun</code> <code>ArrayFunctionOfArray | None</code> <p>the function</p> <code>None</code> Notes <p>if <code>vals_at-nodes</code> is not provided then <code>fun</code> must be.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>the Chebyshev coefficients of the OLS Chebyshev fit, an <code>(M,M)</code> matrix</p> <code>ndarray</code> <p>the approximation is \\(f(x_1,x_2) = \\sum_{k,l} c_{kl} T_k(x_1)T_l(x_2)\\)</p> Source code in <code>bs_python_utils/chebyshev.py</code> <pre><code>def cheb_get_coefficients_2d(\n    rectangle: Rectangle,\n    degree: int,\n    vals_at_nodes: np.ndarray | None = None,\n    fun: ArrayFunctionOfArray | None = None,\n) -&gt; np.ndarray:\n    \"\"\"get the Chebyshev coefficients for `fun` on a rectangle,\n    using an OLS fit on the values on the grid of nodes\n\n    Args:\n        rectangle: the Rectangle\n        degree: the degree of the Chebyshev expansion in each dimension\n        vals_at_nodes: the values on the grid, if precomputed\n        fun: the function\n\n    Notes:\n        if `vals_at-nodes` is not provided then `fun` must be.\n\n    Returns:\n        the Chebyshev coefficients of the OLS Chebyshev fit, an `(M,M)` matrix\n        the approximation is $f(x_1,x_2) = \\\\sum_{k,l} c_{kl} T_k(x_1)T_l(x_2)$\n    \"\"\"\n    if vals_at_nodes is None:\n        if fun is None:\n            bs_error_abort(\"vals_at_nodes was not provided, so fun must be.\")\n        fun = cast(ArrayFunctionOfArray, fun)\n        vals_at_nodes = cheb_eval_fun_at_nodes_2d(\n            fun, rectangle=rectangle, degree=degree\n        )\n    # we need the nodes on $[-1, 1]$\n    interval_1m1 = Interval(x0=-1.0, x1=1.0)\n    nodes1m1, _ = cheb_get_nodes_1d(interval_1m1, degree)\n    # first we fit fixing the node on the first dimension\n    c = np.zeros((degree, degree))\n    c_bar = np.zeros((degree, degree))\n    i_beg = 0\n    for i in range(degree):\n        i_end = i_beg + degree\n        vals_for_i = vals_at_nodes[i_beg:i_end]\n        c_bar[i, :] = ncheb.chebfit(nodes1m1, vals_for_i, degree - 1)\n        i_beg = i_end\n    # then we fit to the values of c_bar\n    for k in range(degree):\n        c[:, k] = ncheb.chebfit(nodes1m1, c_bar[:, k], degree - 1)\n    return c\n</code></pre>"},{"location":"chebyshev.html#bs_python_utils.chebyshev.cheb_get_nodes_1d","title":"<code>cheb_get_nodes_1d(interval, degree)</code>","text":"<p>get the Chebyshev nodes and weights on the interval \\([x0, x1]\\)</p> <p>Parameters:</p> Name Type Description Default <code>interval</code> <code>Interval</code> <p>the Interval \\([x_0, x_1]\\)</p> required <code>degree</code> <code>int</code> <p>the degree of the highest Chebyshev polynomial</p> required <p>Returns:</p> Type Description <code>TwoArrays</code> <p>two <code>degree</code>-vectors of Chebyshev nodes and weights on the interval \\([x_0, x_1]\\)</p> <code>TwoArrays</code> <p>so that <code>g(nodes) @ weights</code> approximates the unweighted integral of \\(g(x)\\) on \\([x_0,x_1]\\)</p> Source code in <code>bs_python_utils/chebyshev.py</code> <pre><code>def cheb_get_nodes_1d(interval: Interval, degree: int) -&gt; TwoArrays:\n    \"\"\"get the Chebyshev nodes and weights on the interval $[x0, x1]$\n\n    Args:\n        interval: the Interval $[x_0, x_1]$\n        degree: the degree of the highest Chebyshev polynomial\n\n    Returns:\n        two `degree`-vectors of Chebyshev nodes and weights on the interval $[x_0, x_1]$\n        so that `g(nodes) @ weights` approximates the unweighted integral of $g(x)$ on $[x_0,x_1]$\n    \"\"\"\n    nodes1m1, weights1m1 = ncheb.chebgauss(degree)  # om=n [-1, 1]\n    x0, x1 = interval.bounds()\n    nodes = move_from1m1(nodes1m1, interval)\n    weights = (x1 - x0) * weights1m1 * np.sqrt(1.0 - nodes1m1 * nodes1m1) / 2.0\n    return cast(np.ndarray, nodes), cast(np.ndarray, weights)\n</code></pre>"},{"location":"chebyshev.html#bs_python_utils.chebyshev.cheb_get_nodes_2d","title":"<code>cheb_get_nodes_2d(rectangle, degree)</code>","text":"<p>get the Chebyshev nodes and weights on a rectangle</p> <p>Parameters:</p> Name Type Description Default <code>rectangle</code> <code>Rectangle</code> <p>the Rectangle</p> required <code>degree</code> <code>int</code> <p>the degree of the highest Chebyshev polynomial in each dimension</p> required <p>Returns:</p> Type Description <code>TwoArrays</code> <p>two \\((  ext{degree}^2, 2)\\)`-matrices of Chebyshev nodes and weights</p> <code>TwoArrays</code> <p>on the rectangle \\([x0, x1]      imes [y0, y1]\\)</p> Source code in <code>bs_python_utils/chebyshev.py</code> <pre><code>def cheb_get_nodes_2d(rectangle: Rectangle, degree: int) -&gt; TwoArrays:\n    \"\"\"get the Chebyshev nodes and weights on a rectangle\n\n    Args:\n        rectangle: the Rectangle\n        degree: the degree of the highest Chebyshev polynomial in each dimension\n\n    Returns:\n        two $(\\text{degree}^2, 2)$`-matrices of Chebyshev nodes and weights\n        on the rectangle $[x0, x1]\\times [y0, y1]$\n    \"\"\"\n    nodes1d_x, weights1d_x = cheb_get_nodes_1d(rectangle.x_interval, degree)\n    nodes1d_y, weights1d_y = cheb_get_nodes_1d(rectangle.y_interval, degree)\n    nodes2d = bsgrid(nodes1d_x, nodes1d_y)\n    weights2d = bsgrid(weights1d_x, weights1d_y)\n    return nodes2d, weights2d[:, 0] * weights2d[:, 1]\n</code></pre>"},{"location":"chebyshev.html#bs_python_utils.chebyshev.cheb_integrate_from_coeffs_1d","title":"<code>cheb_integrate_from_coeffs_1d(c, interval)</code>","text":"<p>integrate a function on an interval using the coefficients of its Chebyshev expansion</p> <p>Parameters:</p> Name Type Description Default <code>c</code> <code>ndarray</code> <p>the Chebyshev coefficients for <code>fun</code></p> required <code>interval</code> <code>Interval</code> <p>the Interval</p> required <p>Returns:</p> Type Description <code>float</code> <p>the value of the integral over the interval</p> Source code in <code>bs_python_utils/chebyshev.py</code> <pre><code>def cheb_integrate_from_coeffs_1d(c: np.ndarray, interval: Interval) -&gt; float:\n    \"\"\"integrate a function on an interval using the coefficients of its Chebyshev expansion\n\n    Args:\n        c: the Chebyshev coefficients for `fun`\n        interval: the Interval\n\n    Returns:\n        the value of the integral over the interval\n    \"\"\"\n    x0, x1 = interval.bounds()\n    Mc = check_vector(c)\n    k_even = slice(0, Mc, 2)\n    k_vals = np.arange(0, Mc, 2)\n    val_integral = np.sum(c[k_even] / (1.0 - k_vals * k_vals)) * (x1 - x0)\n    return cast(float, val_integral)\n</code></pre>"},{"location":"chebyshev.html#bs_python_utils.chebyshev.cheb_integrate_from_coeffs_2d","title":"<code>cheb_integrate_from_coeffs_2d(c, rectangle)</code>","text":"<p>integrate a function on an interval using the coefficients of its Chebyshev expansion</p> <p>Parameters:</p> Name Type Description Default <code>c</code> <code>ndarray</code> <p>the Chebyshev coefficients for <code>fun</code></p> required <code>rectangle</code> <code>Rectangle</code> <p>the Rectangle</p> required <p>Returns:</p> Type Description <code>float</code> <p>the value of the integral over the interval</p> Source code in <code>bs_python_utils/chebyshev.py</code> <pre><code>def cheb_integrate_from_coeffs_2d(c: np.ndarray, rectangle: Rectangle) -&gt; float:\n    \"\"\"integrate a function on an interval using the coefficients of its Chebyshev expansion\n\n    Args:\n        c: the Chebyshev coefficients for `fun`\n        rectangle: the Rectangle\n\n    Returns:\n        the value of the integral over the interval\n    \"\"\"\n    x0, x1 = rectangle.x_interval.bounds()\n    y0, y1 = rectangle.y_interval.bounds()\n    M = check_square(c)\n    k_even = slice(0, M, 2)\n    k_vals = np.arange(0, M, 2)\n    denom = 1.0 - k_vals * k_vals\n    val_integral = cast(float, np.sum(c[k_even, k_even] / np.outer(denom, denom)))\n    return cast(float, val_integral * (x1 - x0) * (y1 - y0))\n</code></pre>"},{"location":"chebyshev.html#bs_python_utils.chebyshev.cheb_integrate_from_nodes_1d","title":"<code>cheb_integrate_from_nodes_1d(vals_at_nodes, weights)</code>","text":"<p>integrate a function given its values at the Chebyshev nodes</p> <p>Parameters:</p> Name Type Description Default <code>vals_at_nodes</code> <code>ndarray</code> <p>the values of the function at these nodes</p> required <code>weights</code> <code>ndarray</code> <p>the Chebyshev nodes</p> required <p>Returns:</p> Type Description <code>float</code> <p>the value of the integral</p> Notes <p>this is much less precise than <code>cheb_integrate_from_coeffs_1d</code></p> Source code in <code>bs_python_utils/chebyshev.py</code> <pre><code>def cheb_integrate_from_nodes_1d(\n    vals_at_nodes: np.ndarray,\n    weights: np.ndarray,\n) -&gt; float:\n    \"\"\"integrate a function given its values at the Chebyshev nodes\n\n    Args:\n        vals_at_nodes: the values of the function at these nodes\n        weights: the Chebyshev nodes\n\n    Returns:\n        the value of the integral\n\n    Notes:\n        this is much less precise than `cheb_integrate_from_coeffs_1d`\n    \"\"\"\n    Mv = check_vector(vals_at_nodes)\n    Mw = check_vector(weights)\n    if Mv != Mw:\n        bs_error_abort(\n            f\"weights and vals_at_nodes must have the same length, not {Mw} and {Mv}\"\n        )\n    return cast(float, weights @ vals_at_nodes)\n</code></pre>"},{"location":"chebyshev.html#bs_python_utils.chebyshev.cheb_integrate_from_nodes_2d","title":"<code>cheb_integrate_from_nodes_2d(vals_at_nodes, weights)</code>","text":"<p>integrate a function given its values at the Chebyshev nodes</p> <p>Parameters:</p> Name Type Description Default <code>vals_at_nodes</code> <code>ndarray</code> <p>the values of the function on the grid of 2d nodes</p> required <code>weights</code> <code>ndarray</code> <p>the Chebyshev weights in 2d</p> required <p>Returns:</p> Type Description <code>float</code> <p>the value of the integral</p> Warning <p>this is much less precise than <code>cheb_integrate_from_coeffs_2d</code></p> Source code in <code>bs_python_utils/chebyshev.py</code> <pre><code>def cheb_integrate_from_nodes_2d(\n    vals_at_nodes: np.ndarray,\n    weights: np.ndarray,\n) -&gt; float:\n    \"\"\"integrate a function given its values at the Chebyshev nodes\n\n    Args:\n        vals_at_nodes: the values of the function on the grid of 2d nodes\n        weights: the Chebyshev weights in 2d\n\n    Returns:\n        the value of the integral\n\n    Warning:\n        this is much less precise than `cheb_integrate_from_coeffs_2d`\n    \"\"\"\n    Mv = check_vector(vals_at_nodes)\n    Mw = check_vector(weights)\n    if Mv != Mw:\n        bs_error_abort(\n            f\"weights and vals_at_nodes must have the same length, not {Mw} and {Mv}\"\n        )\n    return cast(float, vals_at_nodes @ weights)\n</code></pre>"},{"location":"chebyshev.html#bs_python_utils.chebyshev.cheb_integrate_from_nodes_4d","title":"<code>cheb_integrate_from_nodes_4d(vals_at_nodes4d, weights2d)</code>","text":"<p>integrate a function on the square of a rectangle given its values at the 4d Chebyshev nodes</p> <p>Parameters:</p> Name Type Description Default <code>vals_at_nodes4d</code> <code>ndarray</code> <p>the values of the function on the square of the grid of 2d nodes, an \\((M^2, M^2)\\) matrix</p> required <code>weights2d</code> <code>ndarray</code> <p>the Chebyshev weights on the rectangular grid, an \\(M^2\\)-vector</p> required <p>Returns:</p> Type Description <code>float</code> <p>the value of the integral</p> Warning <p>it would be better to have a <code>cheb_integrate_from_coeffs_4d</code></p> Source code in <code>bs_python_utils/chebyshev.py</code> <pre><code>def cheb_integrate_from_nodes_4d(\n    vals_at_nodes4d: np.ndarray, weights2d: np.ndarray\n) -&gt; float:\n    \"\"\"integrate a function on the square of a rectangle given its values at the 4d Chebyshev nodes\n\n    Args:\n        vals_at_nodes4d: the values of the function on the square of the grid of 2d nodes, an $(M^2, M^2)$ matrix\n        weights2d: the Chebyshev weights on the rectangular grid, an $M^2$-vector\n\n    Returns:\n        the value of the integral\n\n    Warning:\n        it would be better to have a `cheb_integrate_from_coeffs_4d`\n    \"\"\"\n    Mv2 = check_square(vals_at_nodes4d)\n    Mw2 = check_vector(weights2d)\n    if Mv2 != Mw2:\n        bs_error_abort(\n            \"weights2d and vals_at_nodes4d should have the same number of rows, not\"\n            f\" {Mv2} and {Mw2}\"\n        )\n    return cast(float, weights2d @ (vals_at_nodes4d @ weights2d))\n</code></pre>"},{"location":"chebyshev.html#bs_python_utils.chebyshev.cheb_interp_1d","title":"<code>cheb_interp_1d(x_vals, interval, c=None, fun=None, degree=None)</code>","text":"<p>interpolate a function on on interval using Chebyshev polynomials</p> <p>Parameters:</p> Name Type Description Default <code>x_vals</code> <code>ndarray</code> <p>the values at which to interpolate</p> required <code>interval</code> <code>Interval</code> <p>the Interval</p> required <code>c</code> <code>ndarray | None</code> <p>the Chebyshev coefficients for <code>fun</code>, if already known; otherwise we compute them</p> <code>None</code> <code>fun</code> <code>ArrayFunctionOfArray | None</code> <p>the function to interpolate</p> <code>None</code> <code>degree</code> <code>int | None</code> <p>the degree of the Chebyshev expansion</p> <code>None</code> Notes <p><code>fun</code> and <code>degree</code> are required if <code>c</code> is not provided</p> <p>Returns:</p> Type Description <code>TwoArrays</code> <p>the values of the interpolation at <code>x_vals</code> and the Chebyshev coefficients <code>c</code></p> Source code in <code>bs_python_utils/chebyshev.py</code> <pre><code>def cheb_interp_1d(\n    x_vals: np.ndarray,\n    interval: Interval,\n    c: np.ndarray | None = None,\n    fun: ArrayFunctionOfArray | None = None,\n    degree: int | None = None,\n) -&gt; TwoArrays:\n    \"\"\"interpolate a function on on interval using Chebyshev polynomials\n\n    Args:\n        x_vals: the values at which to interpolate\n        interval: the Interval\n        c: the Chebyshev coefficients for `fun`, if already known; otherwise we compute them\n        fun: the function to interpolate\n        degree: the degree of the Chebyshev expansion\n\n    Notes:\n        `fun` and `degree` are required if `c` is not provided\n\n    Returns:\n        the values of the interpolation at `x_vals` and the Chebyshev coefficients `c`\n    \"\"\"\n    if c is None:\n        if degree is None or fun is None:\n            bs_error_abort(\"since c is not  provided, fun and degree must be.\")\n        degree = cast(int, degree)\n        fun = cast(ArrayFunctionOfArray, fun)\n        c = cheb_get_coefficients_1d(fun, interval, degree)\n    y_vals = ncheb.chebval(move_to1m1(x_vals, interval), c)\n    return y_vals, c\n</code></pre>"},{"location":"chebyshev.html#bs_python_utils.chebyshev.cheb_interp_1d_from_nodes","title":"<code>cheb_interp_1d_from_nodes(f_vals_at_nodes, x, interval=None)</code>","text":"<p>interpolate \\(f(x)\\) given the values \\(f(x_m)\\) for \\(m=1,\\ldots,M^2\\) at the Chebyshev nodes on an intervak</p> <p>Parameters:</p> Name Type Description Default <code>f_vals_at_nodes</code> <code>ndarray</code> <p>an \\(M^2\\) vector of values \\(f(x_m)\\)</p> required <code>x</code> <code>ndarray</code> <p>a scalar where we want \\(f(x)\\)</p> required <code>interval</code> <code>Interval | None</code> <p>the interval on which the function acts; by default, \\([0,1]\\)</p> <code>None</code> <p>Returns:</p> Type Description <code>float</code> <p>the interpolated value of \\(f(x)\\).</p> Source code in <code>bs_python_utils/chebyshev.py</code> <pre><code>def cheb_interp_1d_from_nodes(\n    f_vals_at_nodes: np.ndarray, x: np.ndarray, interval: Interval | None = None\n) -&gt; float:\n    \"\"\"interpolate $f(x)$ given the values $f(x_m)$ for $m=1,\\\\ldots,M^2$\n    at the Chebyshev nodes on an intervak\n\n    Args:\n        f_vals_at_nodes: an $M^2$ vector of values $f(x_m)$\n        x: a scalar where we want $f(x)$\n        interval: the interval on which the function acts; by default, $[0,1]$\n\n    Returns:\n        the interpolated value of $f(x)$.\n    \"\"\"\n    if interval is None:\n        interval = Interval(x0=0.0, x1=1.0)\n    # we need the nodes on $[-1, 1]$\n    interval_1m1 = Interval(x0=-1.0, x1=1.0)\n    degree = f_vals_at_nodes.size\n    nodes1m1, _ = cheb_get_nodes_1d(interval_1m1, degree)\n    coeffs_f = ncheb.chebfit(nodes1m1, f_vals_at_nodes, degree - 1)\n    f_x, _ = cheb_interp_1d(x, interval, c=coeffs_f)\n    return cast(float, f_x)\n</code></pre>"},{"location":"chebyshev.html#bs_python_utils.chebyshev.cheb_interp_2d","title":"<code>cheb_interp_2d(xy_vals, rectangle, c=None, fun=None, degree=None, vals_at_nodes=None)</code>","text":"<p>interpolate a function on a rectangle using Chebyshev polynomials</p> <p>Parameters:</p> Name Type Description Default <code>xy_vals</code> <code>ndarray</code> <p>the values at which to interpolate, an <code>(n,2)</code> matrix or a 2-vector</p> required <code>rectangle</code> <code>Rectangle</code> <p>the Rectangle</p> required <code>c</code> <code>ndarray | None</code> <p>the Chebyshev coefficients for <code>fun</code>, if already known; otherwise we compute them</p> <code>None</code> <code>fun</code> <code>ArrayFunctionOfArray | None</code> <p>the function to interpolate</p> <code>None</code> <code>degree</code> <code>int | None</code> <p>the degree of the Chebyshev expansion</p> <code>None</code> <code>vals_at_nodes</code> <code>ndarray | None</code> <p>the values on the grid, if precomputed</p> <code>None</code> Notes <p><code>degree</code> is required if <code>c</code> is not provided, as well as either <code>fun</code> or <code>vals_at_nodes</code></p> <p>Returns:</p> Type Description <code>TwoArrays | tuple[float, ndarray]</code> <p>the <code>n</code>-vector of values of the interpolation at <code>xy_vals</code> and the Chebyshev coefficients <code>c</code></p> Source code in <code>bs_python_utils/chebyshev.py</code> <pre><code>def cheb_interp_2d(\n    xy_vals: np.ndarray,\n    rectangle: Rectangle,\n    c: np.ndarray | None = None,\n    fun: ArrayFunctionOfArray | None = None,\n    degree: int | None = None,\n    vals_at_nodes: np.ndarray | None = None,\n) -&gt; TwoArrays | tuple[float, np.ndarray]:\n    \"\"\"interpolate a function on a rectangle using Chebyshev polynomials\n\n    Args:\n        xy_vals: the values at which to interpolate, an `(n,2)` matrix or a 2-vector\n        rectangle: the Rectangle\n        c: the Chebyshev coefficients for `fun`, if already known; otherwise we compute them\n        fun: the function to interpolate\n        degree: the degree of the Chebyshev expansion\n        vals_at_nodes: the values on the grid, if precomputed\n\n    Notes:\n        `degree` is required if `c` is not provided, as well as either `fun` or `vals_at_nodes`\n\n    Returns:\n        the `n`-vector of values of the interpolation at `xy_vals` and the Chebyshev coefficients `c`\n    \"\"\"\n    if c is None:\n        if degree is None:\n            bs_error_abort(\"either c or degree must be provided\")\n        degree = cast(int, degree)\n        c = cheb_get_coefficients_2d(\n            rectangle, degree, vals_at_nodes=vals_at_nodes, fun=fun\n        )\n    # transform xy_vals to $[-1,1]\\times [-1,1]$\n    xy_vals1 = np.zeros_like(xy_vals)\n    if xy_vals.ndim == 2:\n        xy_vals1[:, 0] = move_to1m1(xy_vals[:, 0], rectangle.x_interval)\n        xy_vals1[:, 1] = move_to1m1(xy_vals[:, 1], rectangle.y_interval)\n        n_vals = xy_vals.shape[0]\n        deg = c.shape[0]\n        c2 = np.zeros((deg, n_vals))\n        for k, c_k in enumerate(c):\n            c2[k, :] = ncheb.chebval(xy_vals1[:, 1], c_k)\n        f_vals = np.zeros(n_vals)\n        for i in range(n_vals):\n            f_vals[i] = ncheb.chebval(xy_vals1[i, 0], c2[:, i])\n    else:\n        xy_vals1[0] = move_to1m1(xy_vals[0], rectangle.x_interval)\n        xy_vals1[1] = move_to1m1(xy_vals[1], rectangle.y_interval)\n        deg = c.shape[0]\n        c2 = np.zeros(deg)\n        for k, c_k in enumerate(c):\n            c2[k] = ncheb.chebval(xy_vals1[1], c_k)\n        f_vals = ncheb.chebval(xy_vals1[0], c2)\n    return f_vals, c\n</code></pre>"},{"location":"chebyshev.html#bs_python_utils.chebyshev.cheb_interp_2d_from_nodes","title":"<code>cheb_interp_2d_from_nodes(f_vals_at_nodes, x, rectangle=None)</code>","text":"<p>interpolate \\(f(x)\\) given the values \\(f(x_m)\\) for \\(m=1,\\ldots,M^2\\) at the Chebyshev nodes on a rectangle</p> <p>Parameters:</p> Name Type Description Default <code>f_vals_at_nodes</code> <code>ndarray</code> <p>an \\(M^2\\) vector of values \\(f(x_m)\\)</p> required <code>x</code> <code>ndarray</code> <p>a 2-vector where we want \\(f(x)\\)</p> required <code>rectangle</code> <code>Rectangle | None</code> <p>the rectangle on which the function acts; by default, \\([0,1]^2\\)</p> <code>None</code> <p>Returns:</p> Type Description <code>float</code> <p>the interpolated value of \\(f(x)\\).</p> Source code in <code>bs_python_utils/chebyshev.py</code> <pre><code>def cheb_interp_2d_from_nodes(\n    f_vals_at_nodes: np.ndarray, x: np.ndarray, rectangle: Rectangle | None = None\n) -&gt; float:\n    \"\"\"interpolate $f(x)$ given the values $f(x_m)$ for $m=1,\\\\ldots,M^2$\n    at the Chebyshev nodes on a rectangle\n\n    Args:\n        f_vals_at_nodes: an $M^2$ vector of values $f(x_m)$\n        x: a 2-vector where we want $f(x)$\n        rectangle: the rectangle on which the function acts; by default, $[0,1]^2$\n\n    Returns:\n        the interpolated value of $f(x)$.\n\n    \"\"\"\n    if rectangle is None:\n        interval01 = Interval(x0=0.0, x1=1.0)\n        rectangle = Rectangle(x_interval=interval01, y_interval=interval01)\n    degree = round(sqrt(f_vals_at_nodes.size))\n    coeffs_f = cheb_get_coefficients_2d(\n        rectangle, degree, vals_at_nodes=f_vals_at_nodes\n    )\n    f_x, _ = cheb_interp_2d(x, rectangle, c=coeffs_f)\n    return cast(float, f_x)\n</code></pre>"},{"location":"chebyshev.html#bs_python_utils.chebyshev.move_from1m1","title":"<code>move_from1m1(t, interval)</code>","text":"<p>get the position of <code>t</code> in \\([-1,1]\\) and move it in the same position in <code>interval</code></p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>FloatOrArray</code> <p>position(s) within `\\([-1,1]\\)</p> required <code>interval</code> <code>Interval</code> <p>the Interval</p> required <p>Returns:</p> Type Description <code>FloatOrArray</code> <p><code>x</code> rescaled to \\([-1,1]\\)</p> Source code in <code>bs_python_utils/chebyshev.py</code> <pre><code>def move_from1m1(t: FloatOrArray, interval: Interval) -&gt; FloatOrArray:\n    \"\"\"get the position of `t` in $[-1,1]$ and move it in the same position in `interval`\n\n    Args:\n        t: position(s) within `$[-1,1]$\n        interval: the Interval\n\n    Returns:\n        `x` rescaled to $[-1,1]$\n    \"\"\"\n    x0, x1 = interval.bounds()\n    return cast(FloatOrArray, ((x1 - x0) * t + (x0 + x1)) / 2.0)\n</code></pre>"},{"location":"chebyshev.html#bs_python_utils.chebyshev.move_to1m1","title":"<code>move_to1m1(x, interval)</code>","text":"<p>get the position of <code>x</code> in <code>interval</code> and move it to the same position in \\([-1,1]\\)</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>FloatOrArray</code> <p>position(s) within <code>interval</code></p> required <code>interval</code> <code>Interval</code> <p>the Interval</p> required <p>Returns:</p> Type Description <code>FloatOrArray</code> <p><code>x</code> rescaled to \\([-1,1]\\)</p> Source code in <code>bs_python_utils/chebyshev.py</code> <pre><code>def move_to1m1(x: FloatOrArray, interval: Interval) -&gt; FloatOrArray:\n    \"\"\"get the position of `x` in `interval` and move it to the same position in $[-1,1]$\n\n    Args:\n        x: position(s) within `interval`\n        interval: the Interval\n\n    Returns:\n        `x` rescaled to $[-1,1]$\n    \"\"\"\n    x0, x1 = interval.bounds()\n    return cast(FloatOrArray, (2.0 * x - (x0 + x1)) / (x1 - x0))\n</code></pre>"},{"location":"distance_covariances.html","title":"distance_covariances module","text":"<p>Distance covariance and partial distance covariance \u00e0 la Szekely and Rizzo; evaluation and tests of independence and conditional independence:</p> <ul> <li><code>DcovResults</code>, <code>PdcovResults</code>: classes for distance covariances</li> <li><code>dcov_dcor</code>: `evaluates the distance covariance and correlation of two random variables</li> <li><code>pdcov_pdcor</code>: evaluates the partial distance covariance and correlation of <code>X</code> and <code>Y</code> given <code>Z</code></li> <li><code>pvalue_dcov</code>: test of no dependence between <code>X</code> and <code>Y</code> given <code>Z</code>.</li> </ul>"},{"location":"distance_covariances.html#bs_python_utils.distance_covariances.dcov_dcor","title":"<code>dcov_dcor(X, Y, unbiased=False)</code>","text":"<p>evaluate the distance covariance and correlation of <code>X</code> and <code>Y</code></p> <p>Parameters:</p> Name Type Description Default <code>X</code> <code>ndarray</code> <p><code>n</code> observations of a random variable or vector</p> required <code>Y</code> <code>ndarray</code> <p><code>n</code> observations of a random variable or vector</p> required <code>unbiased</code> <code>bool</code> <p>if <code>True</code>, we use the Szekely and Rizzo 2014 formula</p> <code>False</code> <p>Returns:</p> Type Description <code>DcovResults</code> <p><code>dCov^2(X,Y)</code> and <code>dCor^2(X,Y)</code></p> Source code in <code>bs_python_utils/distance_covariances.py</code> <pre><code>def dcov_dcor(X: np.ndarray, Y: np.ndarray, unbiased: bool = False) -&gt; DcovResults:\n    \"\"\"\n    evaluate the distance covariance and correlation of `X` and `Y`\n\n    Args:\n        X: `n` observations of a random variable or vector\n        Y: `n` observations of a random variable or vector\n        unbiased: if `True`, we use the Szekely and Rizzo 2014 formula\n\n    Returns:\n        `dCov^2(X,Y)` and `dCor^2(X,Y)`\n    \"\"\"\n    X_dist = _compute_distances(X)\n    n = X_dist.shape[0]\n    X_dd = _double_decenter(X_dist, unbiased)\n    Y_dist = _compute_distances(Y)\n    Y_dd = _double_decenter(Y_dist, unbiased)\n    dcov2 = _dcov_prod(X_dd, Y_dd, unbiased)\n    dcor2 = dcov2 / sqrt(\n        _dcov_prod(X_dd, X_dd, unbiased) * _dcov_prod(Y_dd, Y_dd, unbiased)\n    )\n    return DcovResults(\n        dcov=dcov2,\n        dcor=dcor2,\n        X_dd=X_dd,\n        Y_dd=Y_dd,\n        unbiased=unbiased,\n        dcov_stat=n * dcov2,\n    )\n</code></pre>"},{"location":"distance_covariances.html#bs_python_utils.distance_covariances.pdcov_pdcor","title":"<code>pdcov_pdcor(X, Y, Z)</code>","text":"<p>evaluate the partial distance covariance and correlation of <code>X</code> and <code>Y</code> given <code>Z</code></p> <p>Parameters:</p> Name Type Description Default <code>X</code> <code>ndarray</code> <p><code>n</code> observations of a random variable or vector</p> required <code>Y</code> <code>ndarray</code> <p><code>n</code> observations of a random variable or vector</p> required <code>Z</code> <code>ndarray</code> <p><code>n</code> observations of a random variable or vector</p> required <p>Returns:</p> Type Description <code>PdcovResults</code> <p>a <code>PdcovResults</code> instance</p> Source code in <code>bs_python_utils/distance_covariances.py</code> <pre><code>def pdcov_pdcor(X: np.ndarray, Y: np.ndarray, Z: np.ndarray) -&gt; PdcovResults:\n    \"\"\"\n    evaluate the partial distance covariance and correlation of `X` and `Y` given `Z`\n\n    Args:\n        X: `n` observations of a random variable or vector\n        Y: `n` observations of a random variable or vector\n        Z: `n` observations of a random variable or vector\n\n    Returns:\n        a `PdcovResults` instance\n    \"\"\"\n    unbiased = True\n    X_dist = _compute_distances(X)\n    X_dd = _double_decenter(X_dist, unbiased)\n    Y_dist = _compute_distances(Y)\n    Y_dd = _double_decenter(Y_dist, unbiased)\n    Z_dist = _compute_distances(Z)\n    Z_dd = _double_decenter(Z_dist, unbiased)\n    C_XX = _dcov_prod(X_dd, X_dd, unbiased)\n    C_XY = _dcov_prod(X_dd, Y_dd, unbiased)\n    C_YY = _dcov_prod(Y_dd, Y_dd, unbiased)\n    C_XZ = _dcov_prod(X_dd, Z_dd, unbiased)\n    C_YZ = _dcov_prod(Y_dd, Z_dd, unbiased)\n    C_ZZ = _dcov_prod(Z_dd, Z_dd, unbiased)\n    pdcov = C_XY - (C_XZ * C_YZ) / C_ZZ\n    pdcor = pdcov / sqrt((C_XX - C_XZ * C_XZ / C_ZZ) * (C_YY - C_YZ * C_YZ / C_ZZ))\n    n = X.shape[0]\n    return PdcovResults(\n        pdcov=pdcov, pdcor=pdcor, pdcov_stat=n * pdcov, X_dd=X_dd, Y_dd=Y_dd, Z_dd=Z_dd\n    )\n</code></pre>"},{"location":"distance_covariances.html#bs_python_utils.distance_covariances.pvalue_dcov","title":"<code>pvalue_dcov(dcov_results, ndraws=199)</code>","text":"<p>test of no dependence between <code>X</code> and <code>Y</code> given <code>Z</code></p> <p>Parameters:</p> Name Type Description Default <code>dcov_results</code> <code>DcovResults</code> <p>results from <code>dcov_dcor</code></p> required <code>ndraws</code> <code>int</code> <p>the number of draws we use</p> <code>199</code> <p>Returns:</p> Type Description <code>float</code> <p>the bootstrapped  p-value of the test</p> Source code in <code>bs_python_utils/distance_covariances.py</code> <pre><code>def pvalue_dcov(dcov_results: DcovResults, ndraws: int = 199) -&gt; float:\n    \"\"\"\n    test of no dependence between `X` and `Y` given `Z`\n\n    Args:\n        dcov_results:  results from `dcov_dcor`\n        ndraws: the number of draws we use\n\n    Returns:\n        the bootstrapped  p-value of the test\n    \"\"\"\n    X_dd = dcov_results.X_dd\n    Y_dd = dcov_results.Y_dd\n    dcov_stat = dcov_results.dcov_stat\n    unbiased = dcov_results.unbiased\n    dcov_stats_boot = _dcov_bootstrap(X_dd, Y_dd, unbiased, ndraws)\n    sum_small = cast(int, np.sum(dcov_stat &lt; dcov_stats_boot))\n    return (1.0 + sum_small) / (1.0 + ndraws)\n</code></pre>"},{"location":"distance_covariances.html#bs_python_utils.distance_covariances.pvalue_pdcov","title":"<code>pvalue_pdcov(pdcov_results, ndraws=199)</code>","text":"<p>test of no dependence between <code>X</code> and <code>Y</code> given <code>Z</code></p> <p>Parameters:</p> Name Type Description Default <code>pdcov_results</code> <code>PdcovResults</code> <p>the results of <code>pdcov_pdcor</code></p> required <code>ndraws</code> <code>int</code> <p>the number of draws we use</p> <code>199</code> <p>Returns:</p> Type Description <code>float</code> <p>the bootstrapped  p-value of the test</p> Source code in <code>bs_python_utils/distance_covariances.py</code> <pre><code>def pvalue_pdcov(pdcov_results: PdcovResults, ndraws: int = 199) -&gt; float:\n    \"\"\"\n    test of no dependence between `X` and `Y` given `Z`\n\n    Args:\n        pdcov_results: the results of `pdcov_pdcor`\n        ndraws: the number of draws we use\n\n    Returns:\n        the bootstrapped  p-value of the test\n    \"\"\"\n    X_dd = pdcov_results.X_dd\n    Y_dd = pdcov_results.Y_dd\n    Z_dd = pdcov_results.Z_dd\n    pdcov_stat = pdcov_results.pdcov_stat\n    pdcov_stats_boot = _pdcovs_bootstrap(X_dd, Y_dd, Z_dd, ndraws)\n    sum_small = cast(int, np.sum(pdcov_stat &lt; pdcov_stats_boot))\n    return (1.0 + sum_small) / (1.0 + ndraws)\n</code></pre>"},{"location":"pandas_utils.html","title":"pandas_utils module","text":"<p>Utility functions for pandas:</p> <ul> <li><code>bspd_print</code>: pretty-prints a data frame</li> <li><code>bspd_cross_products</code>: generates cross-products of variables</li> <li><code>bspd_statsdf</code>: makes a dataframe with columns from an array specified column names.</li> <li><code>bspd_prepareplot</code>: prepares a dataframe for plotting (very specific).</li> </ul>"},{"location":"pandas_utils.html#bs_python_utils.pandas_utils.bspd_cross_products","title":"<code>bspd_cross_products(df, l1, l2=None, with_squares=True)</code>","text":"<p>Returns a DataFrame with cross-products of the variables of <code>df</code> whose names are in <code>l1</code> and <code>l2</code>.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>any data frame</p> required <code>l1</code> <code>list[str]</code> <p>a list of names of variables that belong to <code>df</code></p> required <code>l2</code> <code>list[str] | None</code> <p>ibidem; <code>l1</code> by default</p> <code>None</code> <code>with_squares</code> <code>bool | None</code> <p>if <code>False</code>, we drop the squares. <code>True</code> by default.</p> <code>True</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>the data frame of cross-products with concatenated names.</p> Source code in <code>bs_python_utils/pandas_utils.py</code> <pre><code>def bspd_cross_products(\n    df: pd.DataFrame,\n    l1: list[str],\n    l2: list[str] | None = None,\n    with_squares: bool | None = True,\n) -&gt; pd.DataFrame:\n    \"\"\"Returns a DataFrame with cross-products of the variables of `df`\n    whose names are in `l1` and `l2`.\n\n    Args:\n        df: any data frame\n        l1: a list of names of variables that belong to `df`\n        l2: ibidem; `l1` by default\n        with_squares: if `False`, we drop the squares. `True` by default.\n\n    Returns:\n        the data frame of cross-products with concatenated names.\n    \"\"\"\n\n    lp2 = l1 if l2 is None else l2\n    l12 = list(product(l1, lp2))\n    cross_pairs = [[x[0], x[1]] for x in l12 if x[0] != x[1]]\n    unique_pairs = []\n    for _i, c in enumerate(cross_pairs):\n        print(c)\n        c_ordered = c if c[0] &lt; c[1] else list(reversed(c))\n        print(c_ordered)\n        if c_ordered not in unique_pairs:\n            unique_pairs.append(c_ordered)\n        print(unique_pairs)\n\n    col_names = sorted([(x[0], x[1], f\"{x[0]}*{x[1]}\") for x in unique_pairs])\n\n    if with_squares:\n        col_names_squares = sorted(\n            [(x[0], x[1], f\"{x[0]}**2\") for x in l12 if x[0] == x[1]]\n        )\n        col_names += col_names_squares\n\n    df_cprods = pd.DataFrame(\n        {col_name: df[x0] * df[x1] for (x0, x1, col_name) in col_names}\n    )\n\n    return df_cprods\n</code></pre>"},{"location":"pandas_utils.html#bs_python_utils.pandas_utils.bspd_prepareplot","title":"<code>bspd_prepareplot(df)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>any dataframe whose column names either all end in '_n' for n an integer, or none does</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>a properly melted dataframe for plotting, with columns 'Sample', 'Statistic', 'Value',</p> <code>DataFrame</code> <p>and 'Group' if there are several integers.</p> Source code in <code>bs_python_utils/pandas_utils.py</code> <pre><code>def bspd_prepareplot(df: pd.DataFrame) -&gt; pd.DataFrame:\n    \"\"\"\n    Args:\n        df: any dataframe whose column names either all end in '_n' for n an integer, or none does\n\n    Returns:\n        a properly melted dataframe for plotting, with columns 'Sample', 'Statistic', 'Value',\n        and 'Group' if there are several integers.\n    \"\"\"\n    # check the names of the columns\n    values_integers = _check_names_n(df.columns)\n    n_values_integers = len(values_integers)\n\n    df2 = df.copy()\n    df2[\"Sample\"] = np.arange(df.shape[0])\n    dfm = pd.melt(\n        df2,\n        id_vars=\"Sample\",\n        value_vars=list(df.columns),\n        var_name=\"Statistic\",\n        value_name=\"Value\",\n    )\n    if n_values_integers in [0, 1]:\n        return dfm\n    else:  # at least two different groups of statistics\n        stat_group = dfm[\"Statistic\"].str.split(\"_\", n=1, expand=True)\n        dfm.drop(columns=[\"Statistic\"], inplace=True)\n        dfm[\"Statistic\"] = stat_group[0]\n        dfm[\"Group\"] = stat_group[1]\n        return dfm\n</code></pre>"},{"location":"pandas_utils.html#bs_python_utils.pandas_utils.bspd_print","title":"<code>bspd_print(df, s='', max_rows=None, max_cols=None, precision=None)</code>","text":"<p>Pretty-prints a data frame</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>any data frame</p> required <code>s</code> <code>str</code> <p>an optional title string</p> <code>''</code> <code>max_rows</code> <code>int | None</code> <p>maximum number of rows to print (all by default)</p> <code>None</code> <code>max_cols</code> <code>int | None</code> <p>maximum number of columns to print (all by default)</p> <code>None</code> <code>precision</code> <code>int | None</code> <p>of numbers. 3 digits by default.</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>nothing.</p> Source code in <code>bs_python_utils/pandas_utils.py</code> <pre><code>def bspd_print(\n    df: pd.DataFrame,\n    s: str = \"\",\n    max_rows: int | None = None,\n    max_cols: int | None = None,\n    precision: int | None = None,\n) -&gt; None:\n    \"\"\"Pretty-prints a data frame\n\n    Args:\n        df: any data frame\n        s: an optional title string\n        max_rows: maximum number of rows to print (all by default)\n        max_cols: maximum number of columns to print (all by default)\n        precision: of numbers. 3 digits by default.\n\n    Returns:\n        nothing.\n    \"\"\"\n\n    print_stars(s)\n    with pd.option_context(\n        \"display.max_rows\",\n        max_rows,\n        \"display.max_columns\",\n        max_cols,\n        \"display.precision\",\n        precision,\n    ):\n        print(df)\n</code></pre>"},{"location":"pandas_utils.html#bs_python_utils.pandas_utils.bspd_statsdf","title":"<code>bspd_statsdf(T, col_names)</code>","text":"<p>Make a dataframe with columns from the array(s) in <code>T</code> and names from <code>col_names</code>.</p> <p>Parameters:</p> Name Type Description Default <code>T</code> <code>ndarray | list[ndarray]</code> <p>a list of n_T matrices or vectors with N rows, or a matrix or a vector with N rows</p> required <code>col_names</code> <code>str | list[str] | list[str | list[str]]</code> <p>a list of n_T name objects; a name object must be a string or a list of strings, with the names for the column(s) of the corresponding T matrix</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>a dataframe with the named columns.</p> Source code in <code>bs_python_utils/pandas_utils.py</code> <pre><code>def bspd_statsdf(\n    T: np.ndarray | list[np.ndarray],\n    col_names: str | list[str] | list[str | list[str]],\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Make a dataframe with columns from the array(s) in `T` and names from `col_names`.\n\n    Args:\n        T: a list of n_T matrices or vectors with N rows, or a matrix or a vector with N rows\n        col_names: a list of n_T name objects; a name object must be a string or a list of strings,\n            with the names for the column(s) of the corresponding T matrix\n\n    Returns:\n        a dataframe with the named columns.\n    \"\"\"\n    if isinstance(T, list):\n        n_T = len(T)\n        _check_colnames(col_names, n_T)\n        shape_T = []\n        for i in range(n_T):\n            shape_T.append(T[i].shape)\n        set_nrows = {shape_i[0] for shape_i in shape_T}\n        if len(set_nrows) &gt; 1:\n            bs_error_abort(\"All T arrays should have the same number of rows.\")\n        big_T = T[0]\n        big_names = _list_str(col_names[0], suffix=\"_1\")\n        for i in range(1, n_T):\n            big_T = np.column_stack((big_T, T[i]))\n            big_names.extend(_list_str(col_names[i], suffix=f\"_{i+1}\"))\n\n        df = pd.DataFrame(big_T, columns=big_names, copy=True)\n\n    else:  # only one element in T\n        ndims_T = check_vector_or_matrix(T)\n        if ndims_T == 1:\n            if not isinstance(col_names, str):\n                bs_error_abort(f\"T is a vector but col_names is {col_names}\")\n            df = pd.DataFrame(T, columns=[col_names], copy=True)\n        elif ndims_T == 2:\n            N, K = T.shape\n            K2 = len(col_names)\n            if K2 != K:\n                bs_error_abort(f\"T is {T.shape} but col_names has {K2} elements\")\n            df = pd.DataFrame(T, columns=col_names, copy=True)\n\n    return df\n</code></pre>"},{"location":"sklearn_utils.html","title":"sklearn_utils module","text":"<p>Contains Lasso <code>scikit-learn</code> utility programs:</p> <ul> <li><code>skl_npreg_lasso</code>: Lasso regression on polynomial interactions of the covariates</li> <li><code>plot_lasso_path</code>: plots the Lasso coefficient paths.</li> </ul>"},{"location":"sklearn_utils.html#bs_python_utils.sklearn_utils.plot_lasso_path","title":"<code>plot_lasso_path(y, X, eps=0.001)</code>","text":"<p>plot Lasso coefficient paths</p> <p>Parameters:</p> Name Type Description Default <code>y</code> <code>ndarray</code> <p>shape <code>(nobs)</code></p> required <code>X</code> <code>ndarray</code> <p>shape  <code>(nobs, nfeatures)</code></p> required <code>eps</code> <code>float</code> <p>length of path</p> <code>0.001</code> <p>Returns:</p> Type Description <code>None</code> <p>plots the paths.</p> Source code in <code>bs_python_utils/sklearn_utils.py</code> <pre><code>def plot_lasso_path(y: np.ndarray, X: np.ndarray, eps: float = 1e-3) -&gt; None:\n    \"\"\"\n    plot Lasso coefficient paths\n\n    Args:\n        y:  shape `(nobs)`\n        X: shape  `(nobs, nfeatures)`\n        eps: length of path\n\n    Returns:\n        plots the paths.\n    \"\"\"\n    # Compute paths\n    print(\"Computing regularization path using the lasso...\")\n    alphas_lasso, coefs_lasso, _ = lasso_path(X, y, eps)\n\n    plt.clf()\n    # Display results\n    plt.figure(1)\n    colors = cycle([\"b\", \"r\", \"g\", \"c\", \"k\"])\n    neg_log_alphas_lasso = -np.log10(alphas_lasso)\n    for coef_l, c in zip(coefs_lasso, colors, strict=True):\n        plt.plot(neg_log_alphas_lasso, coef_l, c=c)\n\n    plt.xlabel(\"-Log(alpha)\")\n    plt.ylabel(\"coefficients\")\n    plt.title(\"Lasso Paths\")\n    plt.axis(\"tight\")\n\n    plt.show()\n\n    return\n</code></pre>"},{"location":"sklearn_utils.html#bs_python_utils.sklearn_utils.skl_npreg_lasso","title":"<code>skl_npreg_lasso(y, X, alpha, degree=4)</code>","text":"<p>Lasso nonparametric regression of <code>y</code> over polynomials of <code>X</code></p> <p>Parameters:</p> Name Type Description Default <code>y</code> <code>ndarray</code> <p>shape <code>(nobs)</code></p> required <code>X</code> <code>ndarray</code> <p>shape  <code>(nobs, nfeatures)</code></p> required <code>alpha</code> <code>float</code> <p>Lasso penalty parameter</p> required <code>degree</code> <code>int</code> <p>highest total degree</p> <code>4</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>the <code>(nobs)</code> array <code>E(y\\vert X)</code> over the sample</p> Source code in <code>bs_python_utils/sklearn_utils.py</code> <pre><code>def skl_npreg_lasso(\n    y: np.ndarray, X: np.ndarray, alpha: float, degree: int = 4\n) -&gt; np.ndarray:\n    \"\"\"\n    Lasso nonparametric regression of `y` over polynomials of `X`\n\n    Args:\n        y:  shape `(nobs)`\n        X: shape  `(nobs, nfeatures)`\n        alpha:  Lasso penalty parameter\n        degree: highest total degree\n\n    Returns:\n        the `(nobs)` array `E(y\\\\vert X)` over the sample\n    \"\"\"\n\n    # first scale the X variables\n    stdsc = StandardScaler()\n    sfit = stdsc.fit(X)\n    X_scaled = sfit.transform(X)\n    pf = PolynomialFeatures(degree)\n    # Create the features and fit\n    X_poly = pf.fit_transform(X_scaled)\n    # now run Lasso\n    reg = Lasso(alpha=alpha).fit(X_poly, y)\n    expy_X = reg.predict(X_poly)\n    return cast(np.ndarray, expy_X)\n</code></pre>"},{"location":"streamlit_utils.html","title":"streamlit_utils module","text":"<p>Contains various utility programs for Streamlit apps:</p> <ul> <li><code>st_table_estimate</code>: to print a table of estimates with standard errors</li> <li><code>st_download_numpy_as_csv</code>: button to download a Numpy array to a CSV file</li> <li><code>st_download_dataframe_as_csv</code>: button to download a Pandas dataframe to a CSV file.</li> </ul>"},{"location":"streamlit_utils.html#bs_python_utils.streamlit_utils.st_download_dataframe_as_csv","title":"<code>st_download_dataframe_as_csv(df, file_name)</code>","text":"<p>button to download a DataFrame to a csv file</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>a Pandas DataFrame</p> required <code>file_name</code> <code>str</code> <p>the datafrme will be downloaded in file_name.csv</p> required <p>Returns:</p> Type Description <code>None</code> <p>nothing</p> Source code in <code>bs_python_utils/streamlit_utils.py</code> <pre><code>def st_download_dataframe_as_csv(df: pd.DataFrame, file_name: str) -&gt; None:\n    \"\"\"button to download a DataFrame to a csv file\n\n    Args:\n        df: a Pandas DataFrame\n        file_name: the datafrme will be downloaded in file_name.csv\n\n    Returns:\n        nothing\n    \"\"\"\n    csv = _convert_dataframe_to_csv(df)\n    _ = st.download_button(\n        label=f\"Download the {file_name} as a CSV file\",\n        data=csv,\n        file_name=f\"{file_name}.csv\",\n        mime=\"text/csv\",\n    )\n</code></pre>"},{"location":"streamlit_utils.html#bs_python_utils.streamlit_utils.st_download_numpy_as_csv","title":"<code>st_download_numpy_as_csv(arr, file_name)</code>","text":"<p>button to download an array to a csv file</p> <p>Parameters:</p> Name Type Description Default <code>arr</code> <code>ndarray</code> <p>a Numpy array</p> required <code>file_name</code> <code>str</code> <p>the array will be downloaded in file_name.csv</p> required <p>Returns:</p> Type Description <code>None</code> <p>nothing</p> Source code in <code>bs_python_utils/streamlit_utils.py</code> <pre><code>def st_download_numpy_as_csv(arr: np.ndarray, file_name: str) -&gt; None:\n    \"\"\"button to download an array to a csv file\n\n    Args:\n        arr: a Numpy array\n        file_name: the array will be downloaded in file_name.csv\n\n    Returns:\n        nothing\n    \"\"\"\n    csv = _convert_arr_to_csv(arr)\n    _ = st.download_button(\n        label=f\"Download the {file_name} as a CSV file\",\n        data=csv,\n        file_name=f\"{file_name}.csv\",\n        mime=\"text/csv\",\n    )\n</code></pre>"},{"location":"streamlit_utils.html#bs_python_utils.streamlit_utils.st_table_estimates","title":"<code>st_table_estimates(coeff_names, estimates, stderrs, true_coeffs=None)</code>","text":"<p>returns a table of the estimates</p> <p>Parameters:</p> Name Type Description Default <code>coeff_names</code> <code>list[str]</code> <p>the names of the coefficients</p> required <code>estimates</code> <code>ndarray</code> <p>the estimated values of the coefficients</p> required <code>stderrs</code> <code>ndarray</code> <p>the standard errors of the estimates</p> required <code>true_coeffs</code> <code>ndarray | None</code> <p>the true values of the coefficients, if available</p> <code>None</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>the table</p> Source code in <code>bs_python_utils/streamlit_utils.py</code> <pre><code>def st_table_estimates(\n    coeff_names: list[str],\n    estimates: np.ndarray,\n    stderrs: np.ndarray,\n    true_coeffs: np.ndarray | None = None,\n) -&gt; pd.DataFrame:\n    \"\"\"returns a table of the estimates\n\n    Args:\n        coeff_names: the names of the coefficients\n        estimates: the estimated values of the coefficients\n        stderrs: the standard errors of the estimates\n        true_coeffs: the true values of the coefficients, if available\n\n    Returns:\n        the table\n    \"\"\"\n    st.write(\"The coefficients are:\")\n    if true_coeffs:\n        df_coeffs_estimates = pd.DataFrame(\n            {\n                \"True\": true_coeffs,\n                \"Estimated\": estimates,\n                \"Standard errors\": stderrs,\n            },\n            index=coeff_names,\n        )\n    else:\n        df_coeffs_estimates = pd.DataFrame(\n            {\n                \"Estimated\": estimates,\n                \"Standard errors\": stderrs,\n            },\n            index=coeff_names,\n        )\n\n    return df_coeffs_estimates\n</code></pre>"}]}